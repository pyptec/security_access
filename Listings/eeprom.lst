C51 COMPILER V9.59.0.0   EEPROM                                                            06/11/2021 11:57:44 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Objects\eeprom.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE eeprom.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\eeprom.lst) TABS(2) OBJECT(.\Objects\eeprom.obj)

line level    source

   1          
   2          #include <eeprom.h>
   3          #include <reg51.h>
   4          #include <string.h>
   5          
   6          /*funciones externas*/
   7          extern void          _nop_     (void);
   8          extern void Delay (void);
   9          extern void Delay_20us(unsigned int cnt);
  10          extern void Delay_1ms(unsigned int cnt);
  11          extern long   atol (const char *s1);
  12          extern void Debug_txt_Tibbo(unsigned char * str);
  13          extern int sprintf  (char *, const char *, ...);
  14          extern void Debug_chr_Tibbo(unsigned char Dat);
  15          void Formato_eeprom();
  16          
  17          //******************************************************************************************
  18          //    RUTINAS DE EEPROM 24FC1025
  19          //******************************************************************************************
  20          sbit sda = P1^2;
  21          sbit scl = P1^3;
  22          //******************************************************************************************
  23          
  24          bit memory_flag;
  25          unsigned char byte_rd;
  26          unsigned char l_data_eeprom;
  27          unsigned char l_chr;
  28          
  29          /*define posiciones de memoria*/
  30          #define EE_ID_CLIENTE   0x0000
  31          
  32          #define EE_TICKET_ID          0X0200
  33          #define EE_FECHA_VENCIMIENTO    0X0350
  34          
  35          
  36          //*******************************************************************************************
  37          void ackd(void)
  38          {
  39   1        unsigned int i;
  40   1        memory_flag=1;
  41   1        scl=1;
  42   1        sda=1;
  43   1        for (i=0; i<1100; i++)             //500
  44   1        {
  45   2          if (sda==0)
  46   2          {
  47   3            memory_flag=0;
  48   3          scl=0;
  49   3      
  50   3          break;
  51   3          }
  52   2        }
  53   1        
  54   1        if (memory_flag==1)
C51 COMPILER V9.59.0.0   EEPROM                                                            06/11/2021 11:57:44 PAGE 2   

  55   1        { 
  56   2      
  57   2        }  
  58   1      } 
  59          //*******************************************************************************************
  60          //*******************************************************************************************
  61          void ack_lect(void)
  62          {
  63   1        int i;
  64   1        scl=1;
  65   1        sda=1;
  66   1        memory_flag=1;
  67   1        for (i=0; i<650; i++)
  68   1        {
  69   2          if (sda==0)
  70   2          {
  71   3            memory_flag=0;
  72   3          scl=0;
  73   3          break;
  74   3          }
  75   2        }
  76   1      } 
  77          //*******************************************************************************************
  78          void p_me (void)
  79          {
  80   1          scl=1;
  81   1          _nop_();
  82   1          scl=0;
  83   1      }
  84          //*******************************************************************************************
  85          void e_d_m (unsigned char a_serial_eeprom)
  86          {
  87   1        unsigned char nbits;
  88   1          for (nbits=0; nbits<8; nbits++)
  89   1        {
  90   2          a_serial_eeprom <<=1;
  91   2          if (CY==1)
  92   2          { 
  93   3            sda=1;
  94   3          }
  95   2          else
  96   2          {
  97   3            sda=0;
  98   3          }
  99   2          scl=1;
 100   2          p_me();         
 101   2        }
 102   1        return;
 103   1      }
 104          //********************************************************************************************
 105          void start (void)
 106          {
 107   1        sda=1;
 108   1        scl=1;
 109   1        _nop_();
 110   1        sda=0;
 111   1        scl=0;
 112   1        return;
 113   1      }
 114          //*******************************************************************************************
 115          void stop (void)
 116          {
C51 COMPILER V9.59.0.0   EEPROM                                                            06/11/2021 11:57:44 PAGE 3   

 117   1        scl=0;
 118   1        sda=0;
 119   1        _nop_();
 120   1        scl=1;
 121   1        sda=1;
 122   1        return;
 123   1      }
 124          //*******************************************************************************************
 125          unsigned char l_d_m (void)
 126          {
 127   1        unsigned char nbits;
 128   1          for (nbits=0; nbits<8; nbits++)
 129   1        {
 130   2          scl=0;
 131   2            if (sda==1) 
 132   2            {
 133   3            l_data_eeprom = l_data_eeprom| 0x01;
 134   3            if (nbits<=6) 
 135   3            {
 136   4              l_data_eeprom<<=1;
 137   4              scl=1;
 138   4            }
 139   3            }
 140   2            if (sda==0)
 141   2            {
 142   3              l_data_eeprom = l_data_eeprom & 0xFE;
 143   3            if (nbits<=6) 
 144   3            {
 145   4                l_data_eeprom <<=1;
 146   4              scl=1;
 147   4            }
 148   3            }
 149   2          }
 150   1        scl=0;
 151   1        return l_data_eeprom;
 152   1      }
 153          //*******************************************************************************************
 154          //*******************************************************************************************
 155          //  ESCRIBE EN EEPROM                                   *
 156          //*******************************************************************************************
 157          //void wr_eeprom (unsigned char control,unsigned char dir_h,unsigned char dir_l,unsigned char data_eeprom)
 158          void wr_eeprom (unsigned char control,unsigned int Dir, unsigned char data_eeprom)
 159          {
 160   1        unsigned char dir_h, dir_l;
 161   1        dir_l=Dir;
 162   1        Dir>>=8;
 163   1        dir_h=Dir;
 164   1      
 165   1      
 166   1        scl=0;
 167   1        sda=0;
 168   1      //  wait();
 169   1          start();
 170   1        e_d_m(control);
 171   1        ackd();
 172   1        e_d_m(dir_h);
 173   1        ackd();
 174   1        e_d_m(dir_l);
 175   1        ackd();
 176   1        e_d_m(data_eeprom);
 177   1        ackd();
 178   1        stop();
C51 COMPILER V9.59.0.0   EEPROM                                                            06/11/2021 11:57:44 PAGE 4   

 179   1        Delay_1ms(13);
 180   1        
 181   1        scl=1;
 182   1        sda=1;
 183   1        Delay_20us(98);                   /*wait long*/
 184   1        Delay_20us(98);
 185   1      }
 186          //*******************************************************************************************
 187          //  ESCRIBE EN EEPROM                                   *
 188          //*******************************************************************************************
 189          /*
 190          void wrpage_eeprom (unsigned char control,unsigned char dir_h,unsigned char dir_l,unsigned char data_eepro
             -m)  
 191          {
 192            unsigned int j;
 193            scl=0;
 194            sda=0;
 195            wait();
 196          
 197            wait();
 198          
 199              start();
 200            e_d_m(control);
 201            ack();
 202            e_d_m(dir_h);
 203            ack();
 204            e_d_m(dir_l);
 205            ack();
 206            for (j=0; j<=127; j++)
 207            {
 208              e_d_m(data_eeprom);
 209              ack();
 210            }
 211            stop();
 212            Delay_1ms(13);
 213            scl=1;
 214            sda=1;
 215           return;
 216          }                                              */
 217          //******************************************************************************************* 
 218          //******************************************************************************************* 
 219          //  LEE EN EEPROM                                     *
 220          //*******************************************************************************************
 221          //unsigned char rd_eeprom (unsigned char control,unsigned char dir_h,unsigned char dir_l) 
 222          unsigned char rd_eeprom (unsigned char control,unsigned int Dir) 
 223          {
 224   1      
 225   1        unsigned char dir_h, dir_l;
 226   1        dir_l=Dir;
 227   1        Dir>>=8;
 228   1        dir_h=Dir;
 229   1      
 230   1        scl=0;
 231   1        sda=0;
 232   1       // wait();
 233   1        start();
 234   1        e_d_m(control);
 235   1        ack_lect();
 236   1        e_d_m(dir_h);
 237   1          ack_lect();
 238   1        e_d_m(dir_l);
 239   1        ack_lect();
C51 COMPILER V9.59.0.0   EEPROM                                                            06/11/2021 11:57:44 PAGE 5   

 240   1        start();
 241   1        e_d_m(control+0x01);
 242   1        ackd();
 243   1        scl=0;
 244   1        l_d_m();
 245   1        stop();
 246   1          scl=1;
 247   1        sda=1;
 248   1        return l_data_eeprom;
 249   1      }
 250          /*----------------------------------------------------------------------------------
 251          Funcion q recibe el numero de ticket en un arreglo
 252          error=1 valida los 10 digitos del ticket y si no es numerico los escribe en cero
 253          j= proposito general
 254          Noticket= variable de 32 bits tiene el numero del ticket
 255          -----------------------------------------------------------------------------------*/
 256          void graba_serie(unsigned char *buffer)
 257          {
 258   1        
 259   1        unsigned char  j;
 260   1        unsigned char error=0;
 261   1        
 262   1        
 263   1      /*valido q los datos recibidos sean numericos*/
 264   1        
 265   1        *(buffer+10)=0;
 266   1        
 267   1        for (j=0; j<=9; j++)
 268   1        {
 269   2          if  ((*(buffer+j)<0x30)||(*(buffer+j)>0x39))
 270   2          {
 271   3            error=1;
 272   3            
 273   3            Debug_txt_Tibbo((unsigned char *) "Error de ticket");
 274   3            Debug_txt_Tibbo((unsigned char *) buffer);
 275   3            Debug_txt_Tibbo((unsigned char *) "\n\r");
 276   3          }
 277   2        
 278   2        }
 279   1        
 280   1        
 281   1        /* son numericos*/
 282   1          if (error==0)
 283   1          {
 284   2            Write_EEprom_Ticket(buffer);
 285   2              
 286   2          }
 287   1          else
 288   1          {
 289   2            wr_eeprom(0xa8,EE_TICKET_ID,00);
 290   2            wr_eeprom(0xa8,EE_TICKET_ID+1,00);
 291   2            wr_eeprom(0xa8,EE_TICKET_ID+2,00);
 292   2            wr_eeprom(0xa8,EE_TICKET_ID+3,00);  
 293   2            
 294   2          }
 295   1      }
 296          void Write_EEprom_Ticket(unsigned char *buffer)
 297          {
 298   1        unsigned char  cod_3,cod_2,cod_1,cod_0;
 299   1        unsigned long int Noticket,Bnoticket=0;
 300   1        Debug_txt_Tibbo((unsigned char *) "Numero de ticket:");
 301   1        Debug_txt_Tibbo((unsigned char *) buffer);
C51 COMPILER V9.59.0.0   EEPROM                                                            06/11/2021 11:57:44 PAGE 6   

 302   1        Debug_txt_Tibbo((unsigned char *) "\n\r");
 303   1        Noticket= atol(buffer);
 304   1          
 305   1        Debug_txt_Tibbo((unsigned char *) "No de ticket HEX:");
 306   1        Bnoticket=Noticket>>24;
 307   1        cod_3=Bnoticket;
 308   1        Debug_chr_Tibbo(cod_3);
 309   1          
 310   1        Bnoticket=Noticket >>16;
 311   1        cod_2=Bnoticket;
 312   1        Debug_chr_Tibbo(cod_2);
 313   1            
 314   1        Bnoticket=Noticket >>8;
 315   1        cod_1=Bnoticket;
 316   1        Debug_chr_Tibbo(cod_1);
 317   1            
 318   1        cod_0=Noticket;
 319   1        Debug_chr_Tibbo(cod_0);
 320   1        Debug_txt_Tibbo((unsigned char *) "\n\r");
 321   1            
 322   1        wr_eeprom(0xa8,EE_TICKET_ID,cod_3);
 323   1        wr_eeprom(0xa8,EE_TICKET_ID+1,cod_2);
 324   1        wr_eeprom(0xa8,EE_TICKET_ID+2,cod_1);
 325   1        wr_eeprom(0xa8,EE_TICKET_ID+3,cod_0); 
 326   1      }
 327          /*----------------------------------------------------------------------------------
 328          Procedimiento que lee el No de Ticket en EEprom y lo retorna en un strint
 329          -----------------------------------------------------------------------------------*/
 330          unsigned char *Lee_No_Ticket()
 331          {
 332   1        unsigned long int Noticket;
 333   1        unsigned char Lee_No_Ticket[11];
 334   1        unsigned char num_chr;
 335   1        Noticket=Read_EEprom_Ticket();
 336   1        sprintf( Lee_No_Ticket,"%lu",Noticket);
 337   1        num_chr=strlen(Lee_No_Ticket);
 338   1        Lee_No_Ticket[num_chr] = 0;
 339   1        Debug_txt_Tibbo((unsigned char *) Lee_No_Ticket);
 340   1        Debug_txt_Tibbo((unsigned char *) "\n\r");
 341   1        return Lee_No_Ticket;
 342   1      }
 343          /*----------------------------------------------------------------------------------
 344          Procedimiento que lee el No de Ticket en EEprom y lo retorna en un long int
 345          -----------------------------------------------------------------------------------*/
 346          unsigned long int  Read_EEprom_Ticket()
 347          {
 348   1        unsigned char cod3,cod2,cod1,cod0;
 349   1        unsigned long int Noticket=0;
 350   1        cod3=rd_eeprom(0xa8,EE_TICKET_ID);
 351   1        cod2=rd_eeprom(0xa8,EE_TICKET_ID+1);
 352   1        cod1=rd_eeprom(0xa8,EE_TICKET_ID+2);
 353   1        cod0=rd_eeprom(0xa8,EE_TICKET_ID+3);
 354   1        
 355   1        Noticket=((Noticket| cod3)<<8);
 356   1        Noticket=((Noticket| cod2)<<8);
 357   1        Noticket=((Noticket| cod1)<<8);
 358   1        Noticket=Noticket| cod0;
 359   1        return Noticket;
 360   1      }
 361          /*----------------------------------------------------------------------------------
 362          Procedimiento que incrementa en uno el numero del Ticket y la graba en  EEprom 
 363          -----------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   EEPROM                                                            06/11/2021 11:57:44 PAGE 7   

 364          void Incremente_Ticket()
 365          {
 366   1        
 367   1        unsigned long int Noticket;
 368   1        unsigned char Lee_No_Ticket[11];
 369   1        Noticket=Read_EEprom_Ticket();
 370   1        Noticket=Noticket+1;
 371   1        sprintf( Lee_No_Ticket,"%lu",Noticket);
 372   1        Write_EEprom_Ticket(Lee_No_Ticket);
 373   1      }
 374          
 375          //***********************************************************************************************
 376          //Rutina que lee la eeprom 
 377          //***********************************************************************************************
 378          void LeerMemoria(unsigned int addres, unsigned char *res)
 379            {
 380   1      unsigned char i;
 381   1      do {
 382   2        *res=rd_eeprom(0xa8,addres);;
 383   2        i=*res;
 384   2        addres++;
 385   2        res++;
 386   2      }while(i !='\0');
 387   1        *res='\0';
 388   1        }
 389          void EscribirMemoria(unsigned int addres,unsigned char *res)
 390            {
 391   1      
 392   1      
 393   1      while(*res !='\0'){
 394   2        if(*res =='\r'){*res='\0';}  
 395   2        wr_eeprom(0xa8,addres,*res);
 396   2       
 397   2          addres++;
 398   2          res++;
 399   2        }
 400   1       wr_eeprom(0xa8,addres,*res);
 401   1         addres++;
 402   1          res++;
 403   1        wr_eeprom(0xa8,addres,0);
 404   1      
 405   1      }
 406          void Formato_eeprom()
 407          {
 408   1      unsigned char dato=0xff;
 409   1      unsigned int i;
 410   1        for(i=0; i< EE_FECHA_VENCIMIENTO; i++)
 411   1        {
 412   2            wr_eeprom(0xa8,i,dato);
 413   2        }
 414   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1398    ----
   CONSTANT SIZE    =     59    ----
   XDATA SIZE       =      3      58
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.59.0.0   EEPROM                                                            06/11/2021 11:57:44 PAGE 8   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
