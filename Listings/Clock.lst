C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE CLOCK
OBJECT MODULE PLACED IN .\Objects\Clock.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Clock.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listin
                    -gs\Clock.lst) TABS(2) OBJECT(.\Objects\Clock.obj)

line level    source

   1          
   2          #include <Clock.h>
   3          #include <reg51.h>
   4          
   5          /*funcion prototipo*/
   6          extern void Delay (void);
   7          extern void Delay_20us(unsigned int cnt);
   8          extern void Debug_Fecha_actual(unsigned char *buffer);
   9          extern float pow   (float x, float y);
  10          extern void Debug_chr_Tibbo(unsigned char Dat);
  11          extern void Debug_txt_Tibbo(unsigned char * str);
  12          extern void Debug_HexDec(unsigned char xfc);
  13          /*variables externas */
  14          extern unsigned char  Debug_Tibbo;
  15          
  16          sbit sck = P1^4 ;                 /* define I/O functions     */
  17          sbit io  = P1^5 ;
  18          sbit rst = P1^6 ;
  19          /*CMD DE ESCRITURA RELOJ*/
  20          #define WDIA            0x86
  21          #define WMES            0x88
  22          #define WANO            0x8C
  23          #define WHORA           0x84
  24          #define WMIN            0x82
  25          #define WSEG            0x80
  26          #define WDIA_SEMANA     0x8A
  27          /*CMD DE LECTURA DEL RELOJ*/
  28          #define RDIA            0x87
  29          #define RMES            0x89
  30          #define RANO            0x8D
  31          #define RHORA           0x85
  32          #define RMIN            0x83
  33          #define RSEG            0x81
  34          #define RDIA_SEMANA     0x8B
  35          
  36          #define True                    0x01
  37          #define False                   0x00
  38          
  39          enum Dia_Semana{
  40            Domingo=1,Lunes, Martes, Miercoles, Jueves, Viernes, Sabado 
  41          };
  42          enum expedidor {
  43           Sector,        
  44           Bloque,        
  45           Tipo_Tarjeta,
  46           Apb,
  47           Horario,
  48           Pico_Placa,
  49           Type_Vehiculo,
  50           Uid_0,
  51           Uid_1,
  52           Uid_2,
  53           Uid_3,
  54           Expira_ano,
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 2   

  55           Expira_mes,
  56           Expira_dia,
  57           DateTime_year,
  58           DateTime_month,
  59           DateTime_day,
  60           DateTime_hour,
  61           DateTime_minutes 
  62           
  63          };
  64          
  65          unsigned char data_clk;
  66          //*********************************************************************************
  67          
  68          //*********************************************************************************
  69          void p_ck (void)
  70          {
  71   1          sck=1;
  72   1          Delay();
  73   1          sck=0;
  74   1      }
  75          //*********************************************************************************
  76          void eb_clk(char dir_clk) {
  77   1        int nbits;
  78   1        for (nbits=0; nbits<8; nbits++)
  79   1        {
  80   2          dir_clk >>=1;
  81   2          if (CY==1)
  82   2          { 
  83   3            io=1;
  84   3          }
  85   2          else
  86   2          {
  87   3            io=0;
  88   3          }
  89   2          p_ck();
  90   2        }
  91   1      }
  92          //*********************************************************************************
  93          unsigned char lee_clk (unsigned char dir_clk) {            
  94   1      int nbits;
  95   1        rst=1;
  96   1        Delay_20us(3);
  97   1        eb_clk(dir_clk);
  98   1        for (nbits=0; nbits<8; nbits++)
  99   1        {
 100   2          if (io==1) 
 101   2          {
 102   3          data_clk = data_clk | 0x80;
 103   3          if (nbits<=6) {
 104   4           data_clk >>=1;
 105   4           }
 106   3          }
 107   2          if (io==0)
 108   2          {
 109   3            data_clk = data_clk & 0x7F;
 110   3          if (nbits<=6) 
 111   3           {
 112   4            data_clk >>=1;
 113   4           }
 114   3          }
 115   2          p_ck();
 116   2          } 
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 3   

 117   1        rst=0;
 118   1        return data_clk;
 119   1      }
 120          //*********************************************************************************
 121          void wr_clk (unsigned char dir_clk, unsigned char byte) {            
 122   1        rst=1;
 123   1        Delay_20us(3);
 124   1        eb_clk(dir_clk);
 125   1        dir_clk=byte;
 126   1        eb_clk(dir_clk);
 127   1        rst=0;
 128   1        
 129   1       }
 130          //****************************************************************************
 131           unsigned char two_one (unsigned char byte_h,unsigned char byte_l)
 132          {
 133   1        unsigned char byte_out;
 134   1        byte_h=byte_h&0x0f;
 135   1        byte_h<<=4;
 136   1        byte_l=byte_l&0x0f;
 137   1        byte_out=byte_h|byte_l;
 138   1        return byte_out;
 139   1      }
 140          /*------------------------------------------------------------------------------
 141          
 142          ------------------------------------------------------------------------------*/
 143          unsigned char validar_clk(unsigned char *datos_clock)
 144          {
 145   1        unsigned char validador=0;
 146   1        
 147   1        
 148   1          if ((*datos_clock >= '0') &&(*datos_clock <= '9'))                                /*valida el dia parte alta */
 149   1          {
 150   2          
 151   2             if ((*(datos_clock+1) >= '0') &&(*(datos_clock+1) <= '9'))                     /*valida el dia parte baja*/
 152   2            {
 153   3              
 154   3               if ((*(datos_clock+3) >= '0') &&(*(datos_clock+3) <= '9'))             /*valida el mes parte alta*/
 155   3              {
 156   4                if ((*(datos_clock+4) >= '0') &&(*(datos_clock+4) <= '9'))            /*valida el mes parte baja */
 157   4                {
 158   5                 if ((*(datos_clock+8) >= '0') &&(*(datos_clock+8) <= '9'))         /*año baja*/      
 159   5                  {
 160   6                   if ((*(datos_clock+0x0b) >= '0')&&(*(datos_clock+0x0b) <= '9'))          /*hora alta*/ 
 161   6                    {
 162   7                    if ((*(datos_clock+0x0c) >= '0') &&(*(datos_clock+0x0c) <= '9'))          /*hora baja*/ 
 163   7                      {
 164   8                     if ((*(datos_clock+0x0e) >= '0') &&(*(datos_clock+0x0e) <= '9'))       /*minutos alta*/
 165   8                        {
 166   9                      if ((*(datos_clock+0x0f) >= '0') &&(*(datos_clock+0x0f) <= '9'))        /*minutos baja*/
 167   9                        {
 168  10                       if ((*(datos_clock+0x11) >= '0') &&(*(datos_clock+0x11) <= '9'))       /*segundos alta*/
 169  10                            {
 170  11                        if ((*(datos_clock+0x12) >= '0') &&(*(datos_clock+0x12) <= '9'))        /*segundos baja*/
 171  11                          {
 172  12                          if ((*(datos_clock+0x14) >= '0') &&(*(datos_clock+0x14) <= '9'))        /*dia de la semana*/
 173  12                           {
 174  13                                  validador=0;
 175  13                           }
 176  12                              }
 177  11                              else
 178  11                              {
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 4   

 179  12                                validador =1;
 180  12                              }
 181  11                            }
 182  10                            else
 183  10                            {
 184  11                              validador =1;
 185  11                          
 186  11                            }
 187  10                          }
 188   9                          else
 189   9                          {
 190  10                            validador =1;
 191  10                        
 192  10                          }
 193   9                      
 194   9                        }
 195   8                        else
 196   8                        {
 197   9                          validador =1;
 198   9                        
 199   9                        }
 200   8                      }
 201   7                      else
 202   7                      {
 203   8                        validador =1;
 204   8                        //break;
 205   8                      }
 206   7                    }
 207   6                    else
 208   6                    {
 209   7                      validador =1;
 210   7                      
 211   7                    }               
 212   6                  }
 213   5                  else
 214   5                  {
 215   6                    validador =1;
 216   6                    
 217   6                  }
 218   5                }
 219   4                
 220   4              }
 221   3              else
 222   3              {
 223   4                validador =1;
 224   4                
 225   4              }
 226   3            
 227   3            }
 228   2            
 229   2            else
 230   2            {
 231   3              validador =1;
 232   3            
 233   3            }
 234   2          
 235   2          }
 236   1          
 237   1          else 
 238   1          {
 239   2            validador =1;
 240   2            
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 5   

 241   2          }
 242   1        
 243   1        return validador;
 244   1        
 245   1      }
 246          /*------------------------------------------------------------------------------
 247          Escribo el reloj en ascii en bloque 
 248          
 249          ------------------------------------------------------------------------------*/
 250          
 251          void Block_write_clock_ascii(unsigned char *datos_clock)  
 252          
 253          {     
 254   1        unsigned char temp;
 255   1      //dia,mes,año,hora,minutos,segundos,Dia de la semana 
 256   1          Debug_txt_Tibbo((unsigned char *) "PROGRAMAMOS HORA");
 257   1          Debug_txt_Tibbo((unsigned char *) "\r\n");
 258   1            /*dia*/
 259   1            wr_clk(WDIA,two_one(*datos_clock,*(datos_clock+1)));                    //dia
 260   1            datos_clock++;
 261   1            datos_clock++;
 262   1            datos_clock++;
 263   1            /*mes*/
 264   1            wr_clk(WMES,two_one(*datos_clock,*(datos_clock+1)));                    //mes
 265   1            datos_clock++;
 266   1            datos_clock++;
 267   1            datos_clock++;
 268   1            datos_clock++;
 269   1            datos_clock++;
 270   1            /*año*/
 271   1            wr_clk(WANO,two_one(*datos_clock,*(datos_clock+1)));                    //año
 272   1            datos_clock++;
 273   1            datos_clock++;
 274   1            datos_clock++;
 275   1            /*hora*/
 276   1            wr_clk(WHORA,two_one(*datos_clock,*(datos_clock+1)));                   //hora
 277   1            datos_clock++;
 278   1            datos_clock++;
 279   1            datos_clock++;
 280   1            /*minutos*/
 281   1            wr_clk(WMIN,two_one(*datos_clock,*(datos_clock+1)));                    //minutos
 282   1            datos_clock++;
 283   1            datos_clock++;
 284   1            datos_clock++;
 285   1            /*segundos*/
 286   1            wr_clk(WSEG,two_one(*datos_clock,*(datos_clock+1)));                    //segundos
 287   1            datos_clock++;
 288   1            datos_clock++;
 289   1            datos_clock++;
 290   1            /*dia de la semana*/
 291   1            temp =*datos_clock & 0x07;
 292   1            wr_clk(WDIA_SEMANA,temp);                               //dia de la semana
 293   1        
 294   1      }
 295          /*------------------------------------------------------------------------------
 296          rutinas de conversiones  de bcd a hex
 297          ------------------------------------------------------------------------------*/
 298          unsigned char bcd_hex (unsigned char l_data)
 299           {
 300   1        unsigned char temp,j;
 301   1        temp=l_data;
 302   1        temp>>=4;
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 6   

 303   1        temp=temp & 0x0f;
 304   1        if (temp!=0x00)
 305   1        {
 306   2          l_data=l_data & 0x0f;
 307   2          for (j=0;j<temp;j++)
 308   2          {
 309   3              l_data=l_data+0x0a;
 310   3          } 
 311   2        }
 312   1        return l_data;
 313   1       }
 314           /*------------------------------------------------------------------------------
 315           Rutina que convierte de Hex a bcd 
 316          ------------------------------------------------------------------------------*/
 317          unsigned char hex_bcd (unsigned char byte)
 318          {
 319   1        unsigned char nibble_h; 
 320   1        unsigned char nibble_l;
 321   1        unsigned char k,byte_out;
 322   1      
 323   1        nibble_h=0x00;
 324   1        nibble_l=0x00;
 325   1      
 326   1        for (k=0;k<byte;k++)
 327   1        {
 328   2          nibble_l=nibble_l+0x01;
 329   2          if (nibble_l==0x0a)
 330   2          {
 331   3            nibble_l=0x00;
 332   3            nibble_h=nibble_h+0x01;
 333   3          }
 334   2         }
 335   1         nibble_h<<=4;
 336   1         nibble_h=nibble_h & 0xf0;
 337   1         nibble_l=nibble_l & 0x0f;
 338   1         byte_out=(nibble_h | nibble_l);
 339   1         return byte_out;
 340   1        
 341   1      }
 342          void hex_ascii(unsigned char * datos,unsigned char * fecha_asii)
 343          {
 344   1        unsigned char dato;
 345   1        //unsigned fecha_asii[7];
 346   1        
 347   1          dato=hex_bcd (*datos);
 348   1          *fecha_asii=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 349   1          *(fecha_asii+1)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 350   1          datos++;
 351   1        
 352   1          dato=hex_bcd (*(datos));
 353   1            *(fecha_asii+2)=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 354   1            *(fecha_asii+3)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 355   1          datos++;
 356   1        
 357   1          dato=hex_bcd (*(datos));
 358   1            *(fecha_asii+4)=((dato&0xf0)>>4)| 0x30;     /*dato parte alta*/
 359   1            *(fecha_asii+5)=(dato&0x0f)| 0x30;            /*dato parte bajo*/
 360   1          
 361   1            *(fecha_asii+6)=0;
 362   1        
 363   1      }
 364          /*------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 7   

 365            CONVIERTE DE 1BYTE HEXADECIMAL A DECIMAL                      
 366          valorhex= pasa el byte en Hex y lo convierte en decimal
 367          buffer=   se debuelve la conversion en un arreglo en ascii
 368          ------------------------------------------------------------------------------*/
 369          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex)
 370          {
 371   1        unsigned char numero, centena, decena;
 372   1      
 373   1        centena=0;
 374   1        decena=0;
 375   1        numero=valorhex;
 376   1      
 377   1        while (numero>=0x064)                           /* resto centena en ascii100*/
 378   1        {
 379   2          numero=numero-0x64;
 380   2          centena=centena+1;
 381   2        }
 382   1          *buffer=centena|0x30;
 383   1          buffer++;
 384   1        while (numero>=0x0a)                            /* resto 10 decena en ascii*/
 385   1        {
 386   2          numero=numero-0x0a;
 387   2          decena=decena+1;
 388   2        }
 389   1        *buffer=decena|0x30;
 390   1        buffer++;
 391   1        *buffer=numero|0x30;                            /*unidad en ascii */
 392   1        buffer++;
 393   1        *buffer= 0;
 394   1      
 395   1      }
 396          /*------------------------------------------------------------------------------
 397            CONVIERTE DE 2BYTE HEXADECIMAL A DECIMAL                      
 398          
 399          ------------------------------------------------------------------------------*/
 400          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l)
 401          {
 402   1        unsigned int valor,numero;
 403   1        unsigned char temp,dmil, mil, centena, decena;
 404   1      
 405   1        valor=0;
 406   1        dmil=0;
 407   1        mil=0;
 408   1        centena=0;
 409   1        decena=0;
 410   1        
 411   1         
 412   1        temp=id_h;
 413   1        temp=temp&0xf0;
 414   1        temp>>=4;
 415   1      
 416   1        valor=valor+(pow(16,3))*temp;
 417   1        temp=id_h;
 418   1        temp=temp&0x0f;
 419   1        valor=valor+(pow(16,2))*temp;
 420   1      
 421   1        temp=id_l;
 422   1        temp=temp&0xf0;
 423   1        temp>>=4;
 424   1        valor=valor+(pow(16,1))*temp;
 425   1        temp=id_l;
 426   1        temp=temp&0x0f;
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 8   

 427   1        valor=valor+(pow(16,0))*temp;
 428   1        numero=valor;
 429   1      
 430   1        while (numero>=0x2710)        // resto 10.000 
 431   1        {
 432   2          numero=numero-0x2710;
 433   2          dmil=dmil+1;
 434   2        }
 435   1        *buffer=dmil|0x30;
 436   1          buffer++;
 437   1        while (numero>=0x03e8)        // resto 1.000
 438   1        {
 439   2          numero=numero-0x03e8;
 440   2          mil=mil+1;
 441   2        }
 442   1        *buffer=mil|0x30;
 443   1          buffer++;
 444   1        while (numero>=0x064)         // resto 100
 445   1        {
 446   2          numero=numero-0x64;
 447   2          centena=centena+1;
 448   2        }
 449   1        *buffer=centena|0x30;
 450   1          buffer++;
 451   1        while (numero>=0x0a)        // resto 10
 452   1        {
 453   2          numero=numero-0x0a;
 454   2          decena=decena+1;
 455   2        }
 456   1        *buffer=decena|0x30;
 457   1        buffer++;
 458   1        *buffer=numero|0x30;
 459   1        buffer++;
 460   1        *buffer=00;
 461   1        
 462   1      }
 463          /*------------------------------------------------------------------------------
 464           Lee el dato del reloj en bloque 
 465          ------------------------------------------------------------------------------*/
 466          void Block_read_clock_ascii(unsigned char *datos_clock)
 467          {
 468   1        unsigned char dato;
 469   1      
 470   1        //dia,mes,año,hora,minutos,segundos,Dia de la semana
 471   1          
 472   1          /*año*/
 473   1          dato=(lee_clk(RANO));
 474   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 475   1          datos_clock++;
 476   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 477   1          datos_clock++;
 478   1        
 479   1        /*mes*/
 480   1          dato=(lee_clk(RMES));
 481   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 482   1          datos_clock++;
 483   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 484   1          datos_clock++;    
 485   1      
 486   1          /*dia*/
 487   1          dato=(lee_clk(RDIA));                       //;bcd_hex(lee_clk(DIA));
 488   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 9   

 489   1          datos_clock++;
 490   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 491   1          datos_clock++;
 492   1          
 493   1          
 494   1          /*hora*/            
 495   1          dato=(lee_clk(RHORA));
 496   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 497   1          datos_clock++;
 498   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 499   1          datos_clock++;        
 500   1          
 501   1          /*minutos*/   
 502   1          dato=(lee_clk(RMIN));   
 503   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 504   1          datos_clock++;
 505   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 506   1          datos_clock++;  
 507   1          *datos_clock=0;
 508   1                      
 509   1      } 
 510          void Block_read_clock_ascii_rasberry(unsigned char *datos_clock)
 511          {
 512   1        unsigned char dato;
 513   1      
 514   1        //dia,mes,año,hora,minutos,segundos,Dia de la semana
 515   1        /*mes*/
 516   1          dato=(lee_clk(RMES));
 517   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 518   1          datos_clock++;
 519   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 520   1          datos_clock++;    
 521   1      
 522   1          /*dia*/
 523   1          dato=(lee_clk(RDIA));                       //;bcd_hex(lee_clk(DIA));
 524   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 525   1          datos_clock++;
 526   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 527   1          datos_clock++;
 528   1          
 529   1        
 530   1          /*año*/
 531   1          dato=(lee_clk(RANO));
 532   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 533   1          datos_clock++;
 534   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 535   1          datos_clock++;
 536   1        
 537   1        
 538   1          
 539   1          /*hora*/            
 540   1          dato=(lee_clk(RHORA));
 541   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 542   1          datos_clock++;
 543   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 544   1          datos_clock++;        
 545   1          
 546   1          /*minutos*/   
 547   1          dato=(lee_clk(RMIN));   
 548   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 549   1          datos_clock++;
 550   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 10  

 551   1          datos_clock++;  
 552   1          *datos_clock='.';
 553   1          datos_clock++;      
 554   1          
 555   1            /*segundos*/    
 556   1          dato=(lee_clk(RSEG));   
 557   1          *datos_clock=((dato&0xf0)>>4)| 0x30;      /*dato parte alta*/
 558   1          datos_clock++;
 559   1          *datos_clock=(dato&0x0f)| 0x30;           /*dato parte bajo*/
 560   1          
 561   1          datos_clock++;  
 562   1          *datos_clock=0;
 563   1                      
 564   1      } 
 565          
 566          void Block_read_Clock_Hex(unsigned char *datos_clock)
 567          {
 568   1        
 569   1        /*año*/
 570   1        *datos_clock=bcd_hex(lee_clk(RANO));      
 571   1         datos_clock++;
 572   1        /*mes*/
 573   1        *datos_clock=bcd_hex(lee_clk(RMES));      
 574   1         datos_clock++;
 575   1        /*Dia*/
 576   1        *datos_clock=bcd_hex(lee_clk(RDIA));      
 577   1         datos_clock++;
 578   1        /*hora*/  
 579   1        *datos_clock=bcd_hex(lee_clk(RHORA));     
 580   1         datos_clock++;
 581   1        /*minutos*/ 
 582   1        *datos_clock=bcd_hex(lee_clk(RMIN));      
 583   1         datos_clock++;
 584   1      
 585   1      }
 586          void  hora_entrada_vehiculo(unsigned char *Atributos_Expedidor)
 587          {
 588   1        
 589   1        *(Atributos_Expedidor + DateTime_year)    = lee_clk(RANO);
 590   1        *(Atributos_Expedidor + DateTime_month)   = lee_clk(RMES);
 591   1        *(Atributos_Expedidor + DateTime_day)     = lee_clk(RDIA);  
 592   1        *(Atributos_Expedidor + DateTime_hour)    = lee_clk(RHORA); 
 593   1        *(Atributos_Expedidor + DateTime_minutes) = lee_clk(RMIN);
 594   1        
 595   1      }
 596          /*------------------------------------------------------------------------------
 597           Lee el dato del reloj en bloque 
 598          ------------------------------------------------------------------------------*/
 599          void Block_read_Clock(unsigned char *datos_clock)
 600          {
 601   1        /*año*/ 
 602   1        *datos_clock = lee_clk(RANO);     
 603   1         datos_clock++;
 604   1        /*mes*/
 605   1        *datos_clock = lee_clk(RMES);     
 606   1         datos_clock++;
 607   1        /*Dia*/
 608   1        *datos_clock = lee_clk(RDIA);     
 609   1         datos_clock++;
 610   1        /*hora*/  
 611   1        *datos_clock = lee_clk(RHORA);      
 612   1         datos_clock++;
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 11  

 613   1        /*minutos*/ 
 614   1        *datos_clock = lee_clk(RMIN);     
 615   1         datos_clock++;
 616   1        /*segundos*/  
 617   1        *datos_clock = lee_clk(RSEG);
 618   1        datos_clock++;
 619   1        *datos_clock=00;
 620   1          
 621   1      }
 622          void cond_ini_clock()
 623          {
 624   1        sck=0;          //Reloj
 625   1        rst=0;
 626   1        io=1;
 627   1      }
 628          
 629          /*------------------------------------------------------------------------------
 630          funcion q verifica la fecha maxima de salida 
 631          VERIFICA PAGO (sin_pago)....                                      
 632          SI PAGO, VERIFICA QUE LA FECHA MAX DE SALIDA NO EXCEDE A LA ACTUAL (acceso_ok)              
 633          (0) vencida
 634          (1) ok en rango
 635          
 636          ------------------------------------------------------------------------------*/
 637          char check_fechaOut(char *buffer)
 638          {
 639   1        unsigned long int fecha_inicio,fecha_fin;
 640   1        unsigned char datos_clk[6];
 641   1        char temp;
 642   1        
 643   1        
 644   1          Block_read_Clock_Hex(datos_clk);                              /*leo el clock actual*/
 645   1          fecha_inicio =  datos_clk[0] * 365 + datos_clk[1] * 30 + datos_clk[2] ;
 646   1          fecha_fin = *(buffer ) * 365 + *(buffer + 1) * 30  + *(buffer + 2);
 647   1          
 648   1            
 649   1          if (fecha_fin >= fecha_inicio )           
 650   1          {
 651   2            temp = True;
 652   2          }
 653   1          else
 654   1          {
 655   2            temp = False;
 656   2          }
 657   1            
 658   1      
 659   1        
 660   1        return temp;
 661   1      }
 662          
 663          //*******************************************************************************************
 664          /*
 665          void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos)
 666          {
 667          
 668          
 669            int ano_inT;
 670            bit bisiesto=0;
 671          
 672            unsigned char ano_out, mes_out, dia_out, hora_out, min_out;
 673            unsigned char Horas_Dcto, Minutos_Dcto, Xtemp; 
 674          
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 12  

 675            bit Tiempo_Dcto=0;
 676          
 677          if ((*(buffer+0x0b)==0x00)&&(*(buffer+0x0c)==0x00)&&(*(buffer+0x0d)==0x00)&&(*(buffer+0x0e)==0x00)&&(*(buf
             -fer+0x0f)==0x00))
 678          {
 679          
 680          //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 681          //  Descuento Maximo 999 minutos  = 16 Horas  39 Minutos
 682          //--------------------------------------------------------------------------------------------------------
             -------------------------------------
 683            if (Val_DctoMinutos >= 60 )
 684            {
 685              Horas_Dcto=Val_DctoMinutos/60;
 686              Minutos_Dcto=Val_DctoMinutos-(Horas_Dcto*60);
 687          
 688            }
 689            else
 690            {
 691              Minutos_Dcto=Val_DctoMinutos;
 692              Horas_Dcto=0;
 693            }
 694          //********************************************************************************************************
             -*************************************
 695          //  Aumenta Primero Minutos
 696          //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 697            if (Minutos_Dcto!=0)
 698            {
 699              min_out=*(buffer+4)+Minutos_Dcto;         
 700              if (min_out>59)                   // Si los minutos no sube de 60 no hay que aumentar nada
 701              {
 702          //----------------------------------------------------
 703                Xtemp=(int)(min_out/60);          // Numero de Horas a aumentar
 704                min_out=min_out-(Xtemp*60);         // Total de minutos
 705          //----------------------------------------------------
 706                hora_out=*(buffer+3)+Xtemp;         /*horas*/
 707          /*
 708                if (hora_out>23)
 709                {
 710                  Xtemp= hora_out/24;             // Numero Dias a aumentar
 711                  hora_out=hora_out-(Xtemp*24);       // Total de Horas
 712          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 713                  dia_out=*(buffer+2)+Xtemp;
 714                  if ((*(buffer+1)==1)||(*(buffer+1)==3)||(*(buffer+1)==5)||(*(buffer+1)==7)||(*(buffer+1)==8)||(*(buffe
             -r+1)==10)||(*(buffer+1)==12))   // Meses de 31 dias
 715                  {
 716                    if (dia_out>31)
 717                    {
 718                      dia_out=dia_out-31;
 719                      mes_out=*(buffer+1)+1;
 720                      if (mes_out>12)
 721                      {
 722                        ano_out=*(buffer+0)+1;
 723                        mes_out=1;
 724                      }
 725                      else
 726                      {
 727                        ano_out=*(buffer+0);
 728                      }
 729                    }
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 13  

 730                    else
 731                    {
 732                      mes_out=*(buffer+1);                        /*mes*/
 733            /*          ano_out=*(buffer+0);                        /*año*/
 734            /*        } 
 735                  }
 736                  else if ((*(buffer+1)==4)||(*(buffer+1)==6)||(*(buffer+1)==9)||(*(buffer+1)==11))                   // Meses de
             - 30 dias
 737                  {
 738                    if (dia_out>30)
 739                    {
 740                      dia_out=dia_out-30;
 741                      mes_out=*(buffer+1)+1;
 742                      ano_out=*(buffer+0);          
 743                    }
 744                    else
 745                    {
 746                      mes_out=*(buffer+1);
 747                      ano_out=*(buffer+0);  
 748                    }
 749          
 750                  }
 751                  else if (*(buffer+1)==2)                                        // Febtrero Es biciesto?
 752                  {
 753          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 754                    ano_inT=*(buffer+0)+2000;
 755                    bisiesto=0;
 756          
 757          /*
 758                    float flotante=12.345;
 759                    int entero;
 760          
 761                    entero=(int)flotante;
 762          */
 763            
 764          /*          division=(ano_inT/4);
 765                    intpart=division;
 766                    decpart= ano_inT - (intpart*4);
 767                    if (decpart==0)
 768                    {
 769                      division=(ano_inT/10);
 770                        intpart = division;
 771                        decpart = ano_inT - (intpart*10);
 772                      if (decpart==0)
 773                      {
 774                        division=(ano_inT/40);
 775                          intpart = division;
 776                          decpart = ano_inT - (intpart*40);
 777          
 778          
 779                        if (decpart==0)
 780                        {
 781                          bisiesto=1;
 782                        }
 783                        else
 784                        {
 785                          bisiesto=0;
 786                        }
 787                      }
 788                      else
 789                      {
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 14  

 790                        bisiesto=1;
 791                      }
 792                    }
 793          */
 794          
 795            /*        if ((*(buffer+0)==16)||(*(buffer+0)==20)||(*(buffer+0)==24)||(*(buffer+0)==28)||(*(buffer+0)==32)||
             -(*(buffer+0)==36))
 796                    {
 797                      bisiesto=1;
 798                    }   
 799          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
 800                    if (bisiesto==1)
 801                    {
 802                      if (dia_out>29)
 803                      {
 804                        ano_out=*(buffer+0);
 805                        dia_out=dia_out-29;
 806                        mes_out=*(buffer+1)+1;
 807                    
 808                      }
 809                      else
 810                      {
 811                        ano_out=*(buffer+0);  
 812                        dia_out=dia_out;
 813                        mes_out=*(buffer+1);
 814                      }
 815                    }
 816                    else
 817                    {
 818                      if (dia_out>28)
 819                      {
 820                        dia_out=dia_out-28;
 821                        mes_out=*(buffer+1)+1;
 822                        ano_out=*(buffer+0);
 823                      }
 824                      else
 825                      {
 826                        dia_out=dia_out;
 827                        mes_out=*(buffer+1);
 828                        ano_out=*(buffer+0);  
 829                      }
 830                    }
 831          //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 832                  }
 833                  else                                                // Error fecha
 834                  {
 835                    dia_out=dia_out;
 836                    mes_out=*(buffer+1);
 837                    ano_out=*(buffer+0);  
 838                  }
 839                }
 840                else
 841                {
 842                  dia_out=*(buffer+2);
 843                  mes_out=*(buffer+1);
 844                  ano_out=*(buffer+0);
 845                }
 846              }
 847              else
 848              {
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 15  

 849                hora_out=*(buffer+3);
 850                dia_out=*(buffer+2);
 851                mes_out=*(buffer+1);
 852                ano_out=*(buffer+0);
 853              }
 854            }
 855            else
 856            {
 857              min_out=*(buffer+4);
 858              hora_out=*(buffer+3);
 859              dia_out=*(buffer+2);
 860              mes_out=*(buffer+1);
 861              ano_out=*(buffer+0);
 862            }
 863          //********************************************************************************************************
             -*************************************
 864          //  AUMENTA HORAS
 865          //--------------------------------------------------------------------------------------------------------
             --------------------------------------
 866              if (Horas_Dcto!=0)
 867              {
 868                  hora_out=hora_out+Horas_Dcto;
 869                  if (hora_out>23)
 870                  {
 871                    Xtemp= hora_out/24;             // Numero Dias a aumentar
 872                    hora_out=hora_out-(Xtemp*24);       // Total de Horas
 873            //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
 874                    dia_out=dia_out+Xtemp;
 875                    if ((mes_out==1)||(mes_out==3)||(mes_out==5)||(mes_out==7)||(mes_out==8)||(mes_out==10)||(mes_out==12
             -))    // Meses de 31 dias
 876                    {
 877                      if (dia_out>31)
 878                      {
 879                        dia_out=dia_out-31;
 880                        mes_out=mes_out+1;
 881                        if (mes_out>12)
 882                        {
 883                          ano_out=ano_out+1;
 884                          mes_out=1;
 885                        }
 886                        else
 887                        {
 888                          ano_out=ano_out;
 889                        }
 890                      }
 891                    }
 892                    else if ((mes_out==4)||(mes_out==6)||(mes_out==9)||(mes_out==11))                   // Meses de 30 dias
 893                    {
 894                      if (dia_out>30)
 895                      {
 896                        dia_out=dia_out-30;
 897                        mes_out=mes_out+1;
 898                        ano_out=ano_out;          
 899                      }
 900                      else
 901                      {
 902                        mes_out=mes_out;
 903                        ano_out=ano_out;  
 904                      }
 905                    }
 906                    else if (mes_out==2)                                        // Febtrero Es biciesto?
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 16  

 907                    {
 908          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 909                      ano_inT=ano_out+2000;
 910                      bisiesto=0;
 911          
 912          
 913          /*            division=(ano_inT/4);
 914                      intpart = division;
 915                      decpart= ano_inT - (intpart*4);
 916            
 917            
 918                      if (decpart==0)
 919                      {
 920                        division=(ano_inT/10);
 921                          intpart = division;
 922                          decpart = ano_inT - (intpart*10);
 923                        if (decpart==0)
 924                        {
 925                          division=(ano_inT/40);
 926                            intpart = division;
 927                            decpart = ano_inT - (intpart*40);
 928                          if (decpart==0)
 929                          {
 930                            bisiesto=1;
 931                          }
 932                          else
 933                          {
 934                            bisiesto=0;
 935                          }
 936                        }
 937                        else
 938                        {
 939                          bisiesto=1;
 940                        }
 941                      }
 942          */
 943            /*          if ((ano_out==16)||(ano_out==20)||(ano_out==24)||(ano_out==28)||(ano_out==32)||(ano_out==36))
 944                      {
 945                        bisiesto=1;
 946                      }   
 947          
 948          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------          
 949                      if (bisiesto==1)
 950                      {
 951                        if (dia_out>29)
 952                        {
 953                          dia_out=dia_out-29;
 954                          mes_out=mes_out+1;
 955                          ano_out=ano_out;            
 956                        }
 957                        else
 958                        {
 959                          dia_out=dia_out;
 960                          mes_out=mes_out;
 961                          ano_out=ano_out;
 962                        }
 963                      }
 964                      else
 965                      {
 966                        if (dia_out>28)
C51 COMPILER V9.59.0.0   CLOCK                                                             08/02/2021 16:39:49 PAGE 17  

 967                        {
 968                          dia_out=dia_out-28;
 969                          mes_out=mes_out+1;
 970                          ano_out=ano_out;                          
 971                        }
 972                      }
 973            //-------------------------------------------------------------------------------------------------------
             ----------------------------------------
 974                    }
 975            
 976                  }
 977              }
 978          
 979          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 980            *(buffer+0x0b)=ano_out;
 981            *(buffer+0x0c)=mes_out;
 982            *(buffer+0x0d)=dia_out;
 983            *(buffer+0x0e)=hora_out;
 984            *(buffer+0x0f)=min_out;   
 985          //--------------------------------------------------------------------------------------------------------
             ---------------------------------------
 986            }
 987            
 988          
 989          }
 990          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3332    ----
   CONSTANT SIZE    =     20    ----
   XDATA SIZE       =      1      63
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
