C51 COMPILER V9.59.0.0   ACCESCAN                                                          07/14/2020 08:20:38 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE ACCESCAN
OBJECT MODULE PLACED IN .\Objects\Accescan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Accescan.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\Accescan.lst) TABS(2) OBJECT(.\Objects\Accescan.obj)

line level    source

   1          #include <Accescan.h>
   2          #include <reg51.h>
   3                    /*funciones prototipo*/
   4          extern void Block_write_clock_ascii(unsigned char *datos_clock);
   5          extern void PantallaLCD(unsigned char cod_msg);
   6          extern void Reloj_Pantalla_Lcd();
   7          extern unsigned char rx_Data(void);
   8          extern void Debug_txt_Tibbo(unsigned char * str);
   9          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  10          extern void Debug_Dividir_texto();
  11          extern void tx_aux(unsigned char caracter);
  12          extern unsigned char Dir_board();
  13          extern void Block_read_clock_ascii(unsigned char *datos_clock);
  14          extern void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l);
  15          extern void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  16          extern void PantallaLCD(unsigned char cod_msg);
  17          extern void LCD_txt (unsigned char * msg,char enable_char_add );
  18          extern unsigned char  ValidaSensoresPaso(void);
  19          extern void tx_aux(unsigned char caracter);
  20          extern void PantallaLCD_LINEA_2(unsigned char cod_msg, unsigned char *buffer);
  21          extern unsigned char hex_bcd (unsigned char byte);
  22          extern void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd
             -);
  23          extern void  send_port(unsigned char *buffer_port, unsigned char length_char);
  24          extern unsigned char validar_clk(unsigned char *datos_clock);
  25          extern void graba_serie(unsigned char *buffer);
  26          extern unsigned char *Lee_No_Ticket();
  27          extern char  *strcpy  (char *s1, const char *s2);
  28          /*------------------------------------------------------------------------------*/
  29                /*variables externas */
  30          extern unsigned int Timer_tivo;
  31          extern unsigned char Timer_wait;
  32          extern unsigned char Tipo_Vehiculo;
  33          extern unsigned char USE_LPR;
  34          extern unsigned char  Debug_Tibbo;
  35          /*------------------------------------------------------------------------------*/
  36            /*bit externos*/
  37          sbit rx_ip = P0^0;        
  38          sbit lock = P1^7;           //Relevo 
  39          sbit Atascado = P0^3;       //Rele de on/off del verificador o transporte
  40          sbit led_err_imp = P0^2;      //Error   
  41          /*------------------------------------------------------------------------------*/
  42          
  43          #define STX                     02 
  44          #define ETX                     03 
  45          #define FUERA_DE_LINEA          0xb6
  46          #define ON_LINE                 0xAA
  47          
  48          /*mensajes de pantalla*/
  49          #define BIENVENIDO              0XFE
  50          #define SIN_PAGO                0XE7
  51          #define LECTURA_DE_TARJETAS     0xB0
  52          
  53          /*tipo de vehiculo*/
C51 COMPILER V9.59.0.0   ACCESCAN                                                          07/14/2020 08:20:38 PAGE 2   

  54          #define AUTOMOVIL           0X00
  55          #define MOTO                0X01
  56          
  57          //unsigned char S1_B2[]={0x13, 0x03, 0x1D, 0x0B, 0x0E, 00, 00, 00, 00, 00, 0x01, 0x13, 0x03, 0x1D, 0x0E, 0
             -x1D};
  58          //unsigned char S1_B0[]={0x32, 0x31, 0x30, 0x37, 0x31, 0x35, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01};
  59          //unsigned char S_B[]={0xE7, 00, 00, 00, 00, 00, 00, 00, 00, 00, 01};
  60          /*------------------------------------------------------------------------------
  61          Rutina q valida los cmd del pto paralelo
  62          recibe el buffer de los datos
  63          length_trama= longitud de la trama
  64          ------------------------------------------------------------------------------*/
  65          void Valida_Trama_Pto(unsigned char *buffer, unsigned char length_trama)
  66          {
  67   1         unsigned char buff[11];
  68   1        /*-------------------------------CMD H reloj para el board y la pantalla lcd-----------------------------
             --------------*/
  69   1          if((length_trama==25)&&(*buffer==STX)&&(*(buffer+2)=='H')&&*(buffer+(length_trama-1))==ETX)                         
             -/*cmd de Accescan que me envia el reloj actualizado*/
  70   1          { 
  71   2            if(validar_clk(buffer+3)==0)
  72   2            {
  73   3            Block_write_clock_ascii(buffer+3);                                                                                /* se escribe el reloj de har
             -dware*/
  74   3          
  75   3            Reloj_Pantalla_Lcd();                                                                                             /* Escribo el reloj actual  en la p
             -antalla lcd*/
  76   3          
  77   3            }   
  78   2          }
  79   1          /*-------------------------------CMD B6 fuera de linea -------------------------------------------------
             -------------*/
  80   1          else if(*buffer==FUERA_DE_LINEA)                                                                                    /*cmd de Accescan que dice q e
             -sta fuera de linea*/
  81   1          {
  82   2            if (Timer_wait>=20)                                                                                               /* se envia el msj fuera de linea*/
  83   2            {                                                                                                                 /* con un tiempo de retardo =((1/(22118400/12
             -)*65535)*30)*/
  84   3              PantallaLCD(FUERA_DE_LINEA);
  85   3              led_err_imp=0;                                                                                                  /*error led on*/
  86   3              //Timer_wait=0;
  87   3              lock=0;                                                                                                         /*relevo off despues de 1 minuto*/
  88   3              Atascado=0; 
  89   3            }
  90   2          }
  91   1          /*-------------------------------CMD AA en linea -------------------------------------------------------
             ------------*/
  92   1          else if ((*buffer==ON_LINE) )                                                                                       /*en linea*/
  93   1          {
  94   2            
  95   2            if (Timer_wait>=20)                                                                                               /* se envia el msj fuera de linea*/
  96   2            { 
  97   3              Timer_wait=0;                                                                                                   /*se inicia el timer*/
  98   3              lock=0;
  99   3              led_err_imp=1;                                                                                                  /*relevo off despues de 1 minuto*/
 100   3              Atascado=0; 
 101   3            } 
 102   2            
 103   2            if ((Debug_Tibbo==0)&&(USE_LPR==1)&& (Timer_tivo>=600))
 104   2            {
 105   3              Timer_tivo=0;
 106   3              Debug_Tibbo=1;
C51 COMPILER V9.59.0.0   ACCESCAN                                                          07/14/2020 08:20:38 PAGE 3   

 107   3              Debug_txt_Tibbo((unsigned char *) "LIVE");
 108   3              Debug_Tibbo=0;
 109   3            }
 110   2            
 111   2            
 112   2          } 
 113   1      
 114   1          
 115   1      
 116   1          else if ((length_trama==19)&&(*buffer==STX)&&(*(buffer+1)=='O')&&*(buffer+(length_trama-1))==ETX)             
             -      /*mensaje de bienvenidos*/
 117   1          {
 118   2            PantallaLCD(BIENVENIDO);
 119   2          }
 120   1          else if ((length_trama==1)&&(*buffer==0xA1))                                                                        /*cmd 0xA1 audio caja qu
             -e es igual a no registra pago */
 121   1          {
 122   2               PantallaLCD(SIN_PAGO);
 123   2          }
 124   1                    /*-------------------------------CMD de wiegand---------------------------------------------------*
             -/
 125   1          else if ((length_trama==6)&&(*buffer==STX)&&(*(buffer+1)=='W')&&*(buffer+(length_trama-1))==ETX)                
             -    /* cmd q comunica con monitor po wigan*/
 126   1          {
 127   2              if (USE_LPR==1)
 128   2              {
 129   3                    /*-------------------------------mensaje en la pantalla--------------------------------------------
             --------*/
 130   3                    ByteHex_Decimal(buff,*(buffer+2));                                                                        /*convierto el primer byte_he
             -x a decimal    */
 131   3                    buff[3]=' ';
 132   3                    Two_ByteHex_Decimal(buff+4,*(buffer+3),*(buffer+4)) ;                                                     /*convierto un byte
             - de 16 bits a decimal*/                                                 
 133   3                  
 134   3                    PantallaLCD_LINEA_2(LECTURA_DE_TARJETAS,buff);
 135   3                                                                                                                              /*transmito el codigo de la tarjeta a la panta
             -lla lcd*/
 136   3                    /*-------------------------------------------------------------------------------------------------
             --------*/
 137   3                
 138   3                    while(!ValidaSensoresPaso());
 139   3                      
 140   3                    Cmd_LPR_Salida_wiegand(buff);
 141   3              }                                                                             
 142   2              
 143   2              else
 144   2              {
 145   3                 /*-------------------------------mensaje en la pantalla---------------------------------------------
             -------*/
 146   3                    ByteHex_Decimal(buff,*(buffer+2));                                                                        /*convierto el primer byte_he
             -x a decimal    */
 147   3                    buff[3]=' ';
 148   3                    Two_ByteHex_Decimal(buff+4,*(buffer+3),*(buffer+4)) ;                                                     /*convierto un byte
             - de 16 bits a decimal*/                                                 
 149   3                    PantallaLCD_LINEA_2(LECTURA_DE_TARJETAS,buff);                                                            /*transmito el codigo d
             -e la tarjeta a la pantalla lcd*/
 150   3                                                                                                          
 151   3                /*---------------------------------------------------------------------------------------------------
             ------*/  
 152   3              
 153   3              }
 154   2          }
C51 COMPILER V9.59.0.0   ACCESCAN                                                          07/14/2020 08:20:38 PAGE 4   

 155   1          /*numero de serie del ticket 02 , No serie 10dig,  03*/
 156   1          else if ((length_trama==12)&&(*buffer==STX)&&*(buffer+(length_trama-1))==ETX)
 157   1          {
 158   2            graba_serie(buffer+1);                                                                                          /*graba el No de concecutivo  en eep
             -rom*/
 159   2                
 160   2          }
 161   1      }
 162          
 163          /*------------------------------------------------------------------------------
 164          Rutina q valida los cmd de Monitor
 165          ------------------------------------------------------------------------------*/
 166          /*
 167          void Valida_Trama_Monitor(unsigned char *buffer, unsigned char length_trama)
 168          {   
 169            length_trama=1;
 170              if  ((*(buffer+2)==ETX)&&(*(buffer+1)=='P'))                                                                            /* APERTURA DE BARRETA
             -*/ 
 171          /*        {
 172                    lock=1;                                                                                                           /*habilita el relevo ON*/
 173          //          Timer_wait=0;
 174          //        }
 175          //    else if (*buffer=='<')
 176          //    {                                                                                                                       /*placa*/
 177          //    }
 178          //}
 179          /*------------------------------------------------------------------------------
 180          
 181          ------------------------------------------------------------------------------*/
 182          /*
 183          void Cmd_Monitor()
 184          {
 185              
 186            
 187          }
 188          */
 189          /*------------------------------------------------------------------------------
 190          Transmito un caracter al software monitor 
 191          ------------------------------------------------------------------------------*/
 192          void Monitor_chr (unsigned char *str,unsigned char num_char)
 193          {
 194   1        unsigned char j;
 195   1        for (j=0; j<num_char; j++)
 196   1          {
 197   2          tx_aux(*str);
 198   2          str++;
 199   2          }
 200   1      }
 201            
 202          /*------------------------------------------------------------------------------
 203          Transmito CMD de salida wiegand 
 204          ------------------------------------------------------------------------------*/
 205          void Cmd_LPR_Salida_wiegand(unsigned char *buffer)
 206          {
 207   1        unsigned char Buffer_Lpr[30];
 208   1        unsigned char j=3;
 209   1        Buffer_Lpr[0]=STX;                                      /*inicio de cmd STx*/
 210   1        Buffer_Lpr[1]=Dir_board();                              /*direccion de la tarjeta*/
 211   1        Buffer_Lpr[2]='S';                                      /*cmd S que salida wiegand*/
 212   1        if(Tipo_Vehiculo!=0)                                    /*Tipo de vehiculo*/
 213   1          {
 214   2            Buffer_Lpr[j++]='M';                                /*moto*/
C51 COMPILER V9.59.0.0   ACCESCAN                                                          07/14/2020 08:20:38 PAGE 5   

 215   2          }
 216   1          else
 217   1          {
 218   2            Buffer_Lpr[j++]='C';                                /*carro*/
 219   2          }
 220   1        
 221   1          
 222   1          
 223   1          for (j=4; *buffer != '\0'; j++)                       /*numero del tab o tarjeta Mf*/
 224   1            {
 225   2                Buffer_Lpr[j]=*buffer;
 226   2                buffer++;
 227   2              
 228   2            }
 229   1            Buffer_Lpr[j++]=':';                                /*separador del tab  o tarjeta MF*/
 230   1                        
 231   1            Block_read_clock_ascii(Buffer_Lpr+j);               /*año,mes,dia,hora,minutos,*/
 232   1            Buffer_Lpr[j+10]=':';                               /*separador fecha*/
 233   1            Buffer_Lpr[j+11]=ETX;                               /*fin de la trama*/
 234   1          
 235   1                
 236   1          
 237   1            Monitor_chr(Buffer_Lpr,j+12);                       /*rutina de envio de la trama a monitor*/
 238   1      }
 239          /*------------------------------------------------------------------------------
 240          
 241          ------------------------------------------------------------------------------*/
 242          //void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2)
 243          //{
 244            
 245            
 246          //  unsigned char Buffer_Lpr[30];
 247          //  unsigned temp;
 248          //  unsigned char j=3;
 249          //  Buffer_Lpr[0]=STX;                                /*inicio de cmd STx*/
 250          //  Buffer_Lpr[1]=Dir_board();                        /*direccion de la tarjeta*/
 251          //  Buffer_Lpr[2]='S';                                /*numero de digitos de transmicion NO IMPORTA NO ES VALIDADO EN PRINC
             -IPAL*/
 252            
 253          //    if(*(buffer_S1_B2+8)!=0)                        /*Tipo de vehiculo*/
 254          //    {
 255            //    Buffer_Lpr[j++]='M';                          /*moto*/
 256            //  }
 257            //  else
 258            //  {
 259            //    Buffer_Lpr[j++]='C';                          /*carro*/
 260            //  }
 261            
 262            
 263          //  do
 264            //{
 265            // Buffer_Lpr[j++]=*buffer_S1_B0;                 /*ticket o consecutivo*/
 266            //  buffer_S1_B0++;
 267            //}while (*buffer_S1_B0!=0);
 268            
 269            
 270            
 271            
 272            
 273              //Buffer_Lpr[j++]=':';                            /*separador de la fecha de entrada*/
 274          
 275            //  temp=hex_bcd(*(buffer_S1_B2+0));                /*año a ascii*/
C51 COMPILER V9.59.0.0   ACCESCAN                                                          07/14/2020 08:20:38 PAGE 6   

 276            //  Buffer_Lpr[j++]=((temp & 0xf0)>>4)| 0x30;
 277            //  Buffer_Lpr[j++]=((temp & 0x0f))| 0x30;
 278              
 279            //  temp=hex_bcd(*(buffer_S1_B2+1));                /*mes a ascii*/
 280            //  Buffer_Lpr[j++]=((temp & 0xf0)>>4)| 0x30;
 281            //  Buffer_Lpr[j++]=((temp & 0x0f))| 0x30;
 282            
 283            //  temp=hex_bcd(*(buffer_S1_B2+2));                /*Dia a ascii*/
 284            //  Buffer_Lpr[j++]=((temp & 0xf0)>>4)| 0x30;
 285            //  Buffer_Lpr[j++]=((temp & 0x0f))| 0x30;
 286            
 287            //  temp=hex_bcd(*(buffer_S1_B2+3));                /*Hora a ascii*/
 288            //  Buffer_Lpr[j++]=((temp & 0xf0)>>4)| 0x30;
 289            //  Buffer_Lpr[j++]=((temp & 0x0f))| 0x30;
 290            
 291            //  temp=hex_bcd(*(buffer_S1_B2+4));                /*Minutos a ascii*/
 292            //  Buffer_Lpr[j++]=((temp & 0xf0)>>4)| 0x30;
 293            //  Buffer_Lpr[j++]=((temp & 0x0f))| 0x30;
 294            
 295              
 296            
 297            //  Buffer_Lpr[j++]=':';                            /*separador tipo fecha*/
 298                                                              /**/
 299                  
 300            //  Buffer_Lpr[j++]=ETX;  
 301            
 302            //  Monitor_chr(Buffer_Lpr,j);                        /*rutina de envio de la trama a monitor*/
 303          //}
 304          //void Cmd_Lpr_Int()
 305          //{
 306          //  unsigned char Buffer_Lpr[30];
 307          //  unsigned char j=3;
 308          //  unsigned char *ticket;/
 309          //  Buffer_Lpr[0]=STX;                                /*inicio de cmd STx*/
 310          //  Buffer_Lpr[1]=Dir_board();                        /*direccion de la tarjeta*/
 311          //  Buffer_Lpr[2]='E';                                /*numero de digitos de transmicion NO IMPORTA NO ES VALIDADO EN PRINC
             -IPAL*/
 312          //  if (Tipo_Vehiculo==AUTOMOVIL)         //cambio del vehiculo
 313          //  {
 314          //    Buffer_Lpr[3]='C';
 315          //    Buffer_Lpr[4]=0;
 316          //  }
 317          //  else
 318          //    {
 319          //      Buffer_Lpr[3]=('M');
 320          //      Buffer_Lpr[4]=0;
 321          //    }
 322          //    
 323          //  ticket=Lee_No_Ticket();
 324          //  strcpy( Buffer_Lpr,ticket);
 325          //}
 326          
 327            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    944    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----      54
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   ACCESCAN                                                          07/14/2020 08:20:38 PAGE 7   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
