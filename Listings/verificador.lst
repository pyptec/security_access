C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          
  12          
  13          extern void send_portERR(unsigned char cod_err);
  14          
  15          
  16          
  17          
  18          extern void PantallaLCD(unsigned char cod_msg);
  19          extern void PantallaLCD_LINEA_2(unsigned char cod_msg, unsigned char *buffer);
  20          
  21          //extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          
  23          
  24          /*funciones prototipo de clock*/
  25          
  26          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  27          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  28          void Block_read_clock_ascii(unsigned char *datos_clock);
  29          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  30          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l);
  31          extern char check_fechaOut(char *buffer);
  32          extern char lee_clk (unsigned char dir_clk);
  33          extern unsigned char bcd_hex (unsigned char l_data);
  34          extern void hex_ascii(unsigned char * datos,unsigned char * fecha_asii);
  35          
  36          extern void Cmd_Lpr_Int();
  37          extern void Delay_10ms(unsigned int cnt);
  38          
  39          /*funciones prototipo string */
  40          
  41          extern char  *strcat  (char *s1, const char *s2);
  42          extern char  *strcpy  (char *s1, const char *s2);
  43          extern unsigned int strlen  (const char *);
  44          
  45          /*funciones prototipo de EEprom*/
  46          
  47          extern unsigned char *Lee_No_Ticket();
  48          void Incremente_Ticket();
  49          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  50          
  51          /*funciones prototipo del transporte MODULO io_sensores*/
  52          
  53          extern unsigned char  ValidaSensoresPaso(void);
  54          unsigned char Valida_Sensor1_Auto();
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 2   

  55          extern unsigned char Dir_board();
  56          extern void sel_Pulsa(void);
  57          void sel_Sensor2(void);
  58          char ValidaSensor(void);
  59          unsigned char Dir_Board_Monitor();
  60          
  61          /*funciones prototipo del transporte MODULO TIBBO*/
  62          
  63          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  64          extern void Debug_txt_Tibbo(unsigned char * str);
  65          extern void Debug_chr_Tibbo(unsigned char Dat);
  66          extern void Debug_HexDec(unsigned char xfc);
  67          
  68          /*funciones prototipo del transporte MODULO LINTECH*/
  69          
  70          extern void Aut_Card_check_Status(void);
  71          extern void Check_Status(unsigned char Detalle);
  72          extern void Dwload_EEprom (void);
  73          extern void Mov_Card(unsigned char Posicion);
  74          extern void Card_Insercion(char Tipo);
  75          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  76          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);  
  77          extern void LoadVerify_EEprom(void);
  78          extern void Clave_Seguridad_S2(void);
  79          extern void Unique_Identifier_UID(void);
  80          extern void Power_off(void);
  81          
  82          /*funcion prototipo monitor*/
  83          
  84          extern void clear_placa();
  85          extern void Rx_Monitor();
  86          
  87          /*funcion prototipo pto paralelo*/
  88          
  89          void  send_port(unsigned char *buffer_port, unsigned char length_char);
  90          
  91          /*funcion prototipo programacion*/
  92          extern unsigned char *Addr_Horarios();
  93          
  94          extern int    atoi (const char *s1);
  95          /*io sensores */
  96          
  97          sbit DataIn = P1^1;         //  dato de las entradas    
  98          sbit sel_A = P3^5;          //Pulsador                        *
  99          sbit sel_B = P3^6;          //Entrada Sensor 2                    *
 100          sbit sel_C = P3^7;          //Entrada Sensor 1                    *
 101          
 102          sbit lock = P1^7;           //Relevo  
 103          sbit Rele_Atasco = P0^3;        //Rele de on/off del verificador o transporte
 104          sbit led_err_imp = P0^2;      //Error   
 105          
 106          /*pines de ip tibbo*/
 107          
 108          sbit rx_ip = P0^0;    
 109          /*variables externas*/
 110          
 111          extern unsigned char g_cEstadoComSoft;
 112          extern unsigned char ValTimeOutCom;
 113          extern unsigned char g_cContByteRx;
 114          extern unsigned char xdata Buffer_Rta_Lintech[];
 115          
 116          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 3   

 117          extern unsigned char Timer_wait;
 118          extern unsigned int  SIN_COBRO;
 119          extern unsigned char  Tarjeta_on;
 120          extern unsigned char cnt__ask_off;
 121          extern  unsigned char Tipo_Vehiculo;
 122          extern  unsigned char  Debug_Tibbo;                                                   /*variable q define expedicion de tarjetas 1=
             - automatico 0= a boton configurable en eeprom*/
 123          extern idata unsigned char placa[];
 124          
 125          /*externo bit*/
 126          
 127          extern bit aSk;
 128          extern bit buffer_ready;
 129          extern bit placa_ready;
 130          
 131          /*----------------------------------------------------------------------------
 132          Definiciones de sequencias de verificador y expedidor
 133          ------------------------------------------------------------------------------*/
 134          
 135          #define SEQ_INICIO                      0X00  
 136          #define SEQ_RESPUESTA_TRANSPORTE        0X01
 137          #define SEQ_CMD_ACEPTADO                0x02
 138          #define SEQ_MOVER_CARD_RF               0x03
 139          #define SEQ_CARD_INSERCION_ON           0x04
 140          #define SEQ_TIPO_CARD                   0X05
 141          #define SEQ_LOAD_PASSWORD               0X06
 142          #define SEQ_READ_SECTOR_BLOQUE          0X07
 143          #define SEQ_WRITE_SECTOR_BLOQUE         0X08
 144          #define SEQ_CAPTURE_CARD                0X09
 145          #define SEQ_CARD_INSERCION_OFF          0x0a
 146          #define SEQ_EXPULSAR_CARD               0x0b
 147          #define SEQ_LOAD_EEPROM                 0x0c
 148          #define SEQ_FRONT_CARD                  0x0d
 149          #define SEQ_ESPERA_VEHICULO_ENTRE       0x0e
 150          #define SEQ_DETAIL_CARD                 0x0f
 151          #define SEQ_PTO_PARALELO                0x10
 152          #define SEQ_WAIT_PLACA                  0x11
 153          #define SEQ_UID                         0X12
 154          #define SEQ_LPR                         0X13  
 155          #define SEQ_TIPO_TARJETAS               0X14
 156          #define SEQ_CAPTURE_CARD_LOOP           0X15
 157          #define SEQ_POWER_OFF                   0X16
 158          #define SEQ_POWER_ON                    0X17
 159          
 160          /*----------------------------------------------------------------------------
 161          Definiciones de sequencias de tareas del verificador y expedidor
 162          ------------------------------------------------------------------------------*/
 163          #define TAREA_PRESENCIA_VEHICULAR             0X00  
 164          #define TAREA_TIPO_TARJETA                    0X01
 165          #define TAREA_LECTURA_TARJETA_SECTOR_BLOQUE   0x02
 166          #define TAREA_WRITE_TARJETA_SECTOR_BLOQUE     0X03
 167          #define TAREA_OPEN_BARRERA                    0X04
 168          #define TAREA_WRITE_PLACA_CARD                0x05
 169          #define TAREA_TIPO_MENSUAL                    0x06
 170          #define TAREA_UID                             0X07
 171          
 172          /*----------------------------------------------------------------------------
 173           definiciones de lintech en la inicializacion de expedidor o verificador
 174          ------------------------------------------------------------------------------*/
 175          
 176          #define INICIA_LINTECH          0x30
 177          #define SEQ_CAPTURE_DATOS_INI   0x31
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 4   

 178          #define GRABA_EEPROM            0x32
 179          #define SEQ_CAPTURA_OK_EEPROM   0X33
 180          #define FIN_OK                  0x00
 181          
 182          
 183          #define True                    0x01
 184          #define False                   0x00
 185          /*----------------------------------------------------------------------------
 186           Definicion de datos asociados al buffer de resetcion del dato del trnasporte 
 187          
 188          ------------------------------------------------------------------------------*/
 189          
 190          
 191          #define ON    1
 192          #define OFF   0
 193          /*----------------------------------------------------------------------------
 194           ERRORES pto serie 
 195          
 196          ------------------------------------------------------------------------------*/
 197          #define REENVIA_TRAMA     0
 198          #define ESPERA_MAS_TIEMPO 1
 199          /*----------------------------------------------------------------------------
 200           definiciones de lintech en la inicializacion de expedidor o verificador
 201           funcion usada en lintech que me debuelve la respuesta de comunicacion del expedidor
 202           o verificador Trama_Validacion_P_N()
 203          RSPT_TRP_OK             (0) respuesta_transporte_oksignifica que la trama es valida y continua en el proceso
 204          NO_RSPD_TRP_PTO_COM     (1) no_responde_trasnporte_pto_com se cumple el tiempo de espera
 205          ESPR_RSPT_TRP_TRAMA     (2)Espera_respuesta_transporte_trama
 206          ERROR_TRP_TRAMA         (3) error_transpote_trama
 207          ------------------------------------------------------------------------------*/
 208          #define   RSPT_TRP_OK           0
 209          #define   NO_RSPD_TRP_PTO_COM   1
 210          #define   ESPR_RSPT_TRP_TRAMA   2
 211          #define   ERROR_TRP_TRAMA       3
 212          
 213          
 214          /*----------------------------------------------------------------------------
 215           definiciones de lintech en el comando Check_Status
 216          ------------------------------------------------------------------------------*/
 217          
 218          #define SENSOR_DETAIL       0x31
 219          #define SENSOR_NORMAL       0x30
 220          
 221          /*------------------------------------------------------------------------------
 222           definiciones de lintech en el comando Card_Insercion
 223          ------------------------------------------------------------------------------*/
 224          
 225          #define Habilita        0x30
 226          #define Inhabilita      0x31
 227          
 228          /*------------------------------------------------------------------------------
 229          Definicion de Lintech en el comando Inicializa
 230          ------------------------------------------------------------------------------*/
 231          
 232          #define TO_FRONT        '0'
 233          #define CAPTURE_BOX     '1'
 234          #define SIN_MOVIMIENTO  '3'
 235          
 236          /*------------------------------------------------------------------------------
 237          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 238          MovPos_Front        '0'   -> mueve  tarjeta al frente pero no la suelta
 239          MovPos_IC           '1'   ->mueve la tarjeta en posicion de read/write IC
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 5   

 240          MovPos_RF           '2'   ->mueve tarjeta a RF card read/write
 241          MovPos_Capture      '3'   ->captura la tarjeta
 242          MovPos_EjectFront   '9'   ->lanza la tarjeta del mecanismo
 243          
 244          ------------------------------------------------------------------------------*/
 245          
 246          #define   MovPos_Front        '0'   
 247          #define   MovPos_IC           '1'
 248          #define   MovPos_RF           '2'
 249          #define   MovPos_Capture      '3'
 250          #define   MovPos_EjectFront   '9'
 251          
 252          /*------------------------------------------------------------------------------
 253          Definicion de la trama Lintech de las respuestas de los cmd
 254          ------------------------------------------------------------------------------*/
 255          
 256          #define Pos_Length          3
 257          #define Pos_TipoResp        4
 258          #define Pos_St0             7
 259          #define Pos_St1             8
 260          #define Pos_St2             9
 261          #define Pos_IniDatMF        0x0a
 262          #define Card_type_H         0x0a
 263          #define Card_type_L         0x0b
 264          #define Rtype               0x0A
 265          /*------------------------------------------------------------------------------
 266          Definicion del estado de st0,st1,st2 de la trama Lintech 
 267          NO_CARDS_IN_MCNSM -> No tiene tarjetas en el mecanismo      sto=0
 268          CARD_IN_MOUTH     -> hay una tarjeta dentro del bessel      st0=1
 269          CARD_OK_READ_RF   -> Tarjeta en posicion para leer/escribir dentro del mecanismo st0=2
 270          NO_HAVE_CARDS     -> no tiene tarjetas en el deposito st1=0
 271          LOW_NIVEL_CARDS   -> nivel bajo de tarjetas en el deposito  st1=1
 272          FULL_CARD         -> Deposito de tarjetas esta lleno        st1=2
 273          ------------------------------------------------------------------------------*/
 274          
 275          
 276          #define NO_CARDS_IN_MCNSM   '0'
 277          #define CARD_IN_MOUTH       '1'
 278          #define CARD_OK_READ_RF     '2'
 279          #define NO_HAVE_CARDS       '0'
 280          #define LOW_NIVEL_CARDS     '1'
 281          #define FULL_CARD           '2'
 282          /*----------------------------------------------------------------------------
 283          Comprobacion automatica del tipo de tarjeta 
 284          checking RF card type
 285          Card_type_H   Card_type_L  explicacion
 286              0             0           tarjeta desconocida
 287              1             0           MF50
 288              1             1           MF70
 289              1             2           MF_UL
 290              2             0           TYPE_A_CPU
 291          ------------------------------------------------------------------------------*/
 292          #define MF50_HIGH             '1'
 293          #define MF50_LOW              '0'
 294          #define OPERATE_FAIL          0X6F
 295          
 296          /*----------------------------------------------------------------------------
 297          definicion de recepcion serial 
 298          ------------------------------------------------------------------------------*/
 299          
 300          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 301          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 6   

 302          /*----------------------------------------------------------------------------
 303          tiempo de delay entre funciones
 304          ------------------------------------------------------------------------------*/
 305          
 306          #define   TIME_CARD         100   //50
 307          #define   TIME_WAIT         18
 308          /*----------------------------------------------------------------------------
 309          definicion de datos de trama lintech
 310          ------------------------------------------------------------------------------*/
 311          
 312          //#define   ETX               03
 313          #define   STX_LINTECH       0xf2
 314          
 315          /*----------------------------------------------------------------------------
 316          msj de lcd tarjeta y lcd serie
 317          ------------------------------------------------------------------------------*/
 318          /*Los cmd PRMR son enviados por el primario*/
 319          #define PRMR_ERROR_LOOP         0XE0
 320          #define ERROR_LOOP              170
 321          #define PRMR_ERROR_COD_PARK     0XE5
 322          #define ERROR_COD_PARK          171
 323          #define PRMR_TARJETA_INVALIDA   0XE1
 324          #define PULSE_BOTON             172
 325          #define PRMR_TARJETA_SIN_FORMATO  0xDF
 326          #define TARJETA_SIN_FORMATO       173
 327          
 328          #define PRMR_NO_CARD_MENSUAL          0XFC
 329          #define NO_CARD_MENSUAL         176
 330          #define TARJETA_INVALIDA        177
 331          
 332          #define PRMR_NO_ROTACION              0XFD
 333          
 334          #define PRMR_SIN_SALIDA             0XE9
 335          #define SIN_SALIDA              178
 336          #define REGISTRA_INGRESO        179
 337          
 338          #define PRMR_TARJETA_VENCIDA          0XEC
 339          #define TARJETA_VENCIDA         180
 340          #define PRMR_ERROR_TIPO_VEHICULO      0XF8
 341          #define PRMR_MENSUAL_FUERA_HORARIO    0Xb5
 342          #define MENSUAL_FUERA_HORARIO   181
 343          #define ERROR_MF1               0XE2
 344          #define HORARIO_NO_PROG         182
 345          
 346          
 347          
 348          #define BIENVENIDO              0XFE
 349          #define NO_CARD                 0xFA  
 350          
 351          #define RETIRE_TARJETA          0XA1
 352          
 353          #define LOW_CARD                0x01
 354          
 355          #define AUDIO_ENTRADA     0XA0
 356          #define AUDIO_CAJA        0XA1
 357          #define AUDIO_GRACIAS     0XA2
 358          /*----------------------------------------------------------------------------
 359          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 360          ------------------------------------------------------------------------------*/
 361          
 362          #define   ENVIADOS          0X0
 363          #define   RESPUESTA         0X01
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 7   

 364          /*
 365          definicion  de daos del reloj
 366                    */
 367          
 368          #define RDIA            0x87
 369          #define RMES            0x89
 370          #define RANO            0x8D
 371          #define RDIA_SEMANA     0x8B
 372          #define RHORA           0x85
 373          #define RMIN            0x83
 374          #define Sabado          7
 375          #define Domingo         1
 376          /*----------------------------------------------------------------------------
 377          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 378          (0) si el dato es cero esta inactiva
 379          (1) activa o ROTACION
 380          (2) mensualidad
 381          ------------------------------------------------------------------------------*/
 382          enum Tipos_MF_TIPO_TARJETA{
 383            INACTIVA,         
 384            ROTACION,           
 385            MENSUALIDAD,
 386            PREPAGO,
 387            CORTESIA,
 388            LOCATARIO,
 389            TARJETA_PERDIDA = 0X10,
 390            INHABILITADA = 0X11
 391          };
 392          /*----------------------------------------------------------------------------
 393          posicion de  MF  bloque 1 sector 1
 394          (0) tipo de tarjeta 
 395          (01) el id del cliente
 396          (03)codigo del parqueadero  
 397          ------------------------------------------------------------------------------*/
 398          #define   MF_TIPO_TARJETA   0X00
 399          #define   MF_COD_PARK       0x01      //MF_ID_CLIENTE
 400          #define   MF_ID_CLIENTE     0x03      //MF_COD_PARK
 401          
 402          /*----------------------------------------------------------------------------
 403          posicion de  MF bloque 2 sector 1
 404          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 405          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 406          ------------------------------------------------------------------------------*/
 407          
 408          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 409          
 410          
 411          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 412                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
 413          #define   MF_LSB            0x06
 414          
 415          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 416          
 417          #define   MF_IN_PAGO        0x09
 418          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 419          
 420          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 421          
 422          #define   MF_MENSUAL_ANO      0X05
 423          #define   MF_MENSUAL_MES      0X06
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 8   

 424          #define   MF_MENSUAL_DIA      0X07
 425          
 426          #define   MF_UID_0      0X04
 427          #define   MF_UID_1      0X05
 428          #define   MF_UID_2      0X06
 429          #define   MF_UID_3      0X07
 430          
 431          #define   MF_EXPIRA_ANO     0X08
 432          #define   MF_EXPIRA_MES     0X09
 433          #define   MF_EXPIRA_DIA     0X0A
 434          
 435          #define   HABILITA_ADDR     15
 436          #define   Segundo_Tiempo    16
 437          
 438          enum Hora_Minutos_addr{
 439            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 440            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 441          };
 442          
 443          enum Estados_Expedidor{
 444           EstadoActual,
 445           EstadoPasado,
 446           EstadoFuturo,
 447           TareadelCmd  
 448          };
 449          enum expedidor {
 450           Sector,        
 451           Bloque,        
 452           Tipo_Tarjeta,
 453           Apb,
 454           Horario,
 455           Pico_Placa,
 456           Type_Vehiculo,
 457           Uid_0,
 458           Uid_1,
 459           Uid_2,
 460           Uid_3,
 461           Expira_ano,
 462           Expira_mes,
 463           Expira_dia
 464           
 465          };
 466          /*tipos de APB antipassback*/
 467          enum Tipos_MF_APB{
 468            
 469            APB_INICIADO,       
 470            APB_INT,              
 471            APB_OUT,              
 472            APB_NO              
 473          };
 474          /*tipo de vehiculo*/
 475          /*Sectores y bloques de Mf*/
 476          enum MF_Sector_Bloque{
 477            Sector_0,
 478            Sector_1,
 479            Sector_2,
 480            Bloque_0 = 0,
 481            Bloque_1 = 1,
 482            Bloque_2 = 2
 483          };
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 9   

 484          /*comandos pto paralelo*/
 485          enum CMD_Trama_Pto_Paralelo{
 486            STX=02,
 487            CMD_PTO_PARALELO_EXPEDIDOR='a',
 488            ETX= 03,
 489            NULL=0,
 490            CMD_MONITOR_EXPEDIDOR='E',
 491            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 492          };
 493          enum EE_AntiPassBack{
 494            APB_INHABILITADO_SOFT,
 495            APB_HABILITADO_SOFT
 496          };  
 497          enum Tipos_Vehiculos{
 498              AUTOMOVIL,          
 499              MOTO,
 500              BICICLETA
 501          };  
 502          
 503          /*DATOS DE CONFIGURACION EEPROM*/
 504          #define EE_ID_CLIENTE           0x0000
 505          #define EE_ID_PARK              0x0002
 506          #define EE_DEBUG                0x0008
 507          #define EE_USE_LPR              0x000A
 508          #define EE_CARD_AUTOMATIC_BOTON 0x000f
 509          #define EE_HABILITA_APB         0x0010
 510          #define EE_PLACA                0X0011
 511          #define EE_VALIDA_TIPO_VEHICULO_MENSUAL 0X0014
 512          #define EE_HABILITA_APB_MENSUAL 0X0015
 513          
 514          /*----------------------------------------------------------------------------
 515          Definicion de varaibles globales del objeto
 516          ------------------------------------------------------------------------------*/
 517          
 518          static unsigned char Estado=INICIA_LINTECH;
 519          bit MenSual = False;
 520          /*------------------------------------------------------------------------------
 521          
 522          ------------------------------------------------------------------------------*/
 523          unsigned char Captura_Expulsa()
 524          {
 525   1        unsigned char Estado_expedidor;
 526   1        
 527   1        
 528   1        if(MenSual !=  True)
 529   1        {
 530   2          Estado_expedidor=SEQ_CAPTURE_CARD_LOOP; //SEQ_CAPTURE_CARD;                                       
 531   2        }
 532   1        else
 533   1        {
 534   2        
 535   2        Estado_expedidor = SEQ_EXPULSAR_CARD;//SEQ_CARD_INSERCION_OFF;  
 536   2        } 
 537   1      
 538   1      
 539   1      return  Estado_expedidor;
 540   1      }
 541          /*------------------------------------------------------------------------------
 542          funcion que valida la trama del verificador o transporte lintech
 543          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 544          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 545          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 10  

 546          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 547          
 548          
 549          ------------------------------------------------------------------------------*/
 550          
 551          char Trama_Validacion_P_N()
 552          {
 553   1        char Trama_Validacion_P_N=ESPR_RSPT_TRP_TRAMA;                                /*espera respuesta del transporte*/
 554   1            
 555   1            if ((ValTimeOutCom==1)||(buffer_ready==1) )
 556   1            {
 557   2              if (buffer_ready==1)
 558   2              {
 559   3                buffer_ready=0;
 560   3                  
 561   3              
 562   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 563   3                {
 564   4                          
 565   4                  Trama_Validacion_P_N=RSPT_TRP_OK;                                       /*trama ok*/
 566   4                    
 567   4                }
 568   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 569   3                {
 570   4                  
 571   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;                                 /*error de trama*/
 572   4                  
 573   4                }
 574   3                else
 575   3                {
 576   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
 577   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;   
 578   4                  
 579   4                }
 580   3              }
 581   2              else
 582   2              {
 583   3                          
 584   3                Trama_Validacion_P_N=NO_RSPD_TRP_PTO_COM;                                 /*pto serie no responde */
 585   3                                                  
 586   3              }
 587   2      
 588   2            }
 589   1            
 590   1        return Trama_Validacion_P_N;
 591   1      }
 592          /*------------------------------------------------------------------------------
 593          funcion de error de respuesta pto serie
 594          
 595          variable en uart. cnt__ask_off=cuenta los numeros de error pto serie y reset de transporte 
 596          se limpia cuando llega la respuesta del transporte. 
 597          Rele_Atasco = es un I/O del Mc que activa / inhabilita el rele
 598          ON    (1) esta activo 
 599          OFF   (0) inhactivo 
 600          REENVIA_TRAMA   1
 601          ESPERA_MAS_TIEMPO 0
 602          cnt_espera_ask_on= cuenta el tiempo de ASK que esta activo,sin que le llegue
 603                             la trama completa, al  5 tiempos borra el ask y retrasmite el cmd
 604          
 605          error_rx_pto= (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 606                      = (1)= REENVIA_TRAMA reenvia la trama al transporte
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 11  

 607          
 608          cnt__ask_off= varible global esta definida en pto serie y es un contador , que 
 609          se limpia cada vez que la trama a llegado completa y validada
 610          
 611          aSk= significa que llego al pto serie el 06 = ask donde el transporte dice que a recibido el cmd
 612          esta ejecutando y nos enviara la respuesta,necesita tiempo esta bit esta definino en el modulo uart es glo
             -bal
 613          
 614          ------------------------------------------------------------------------------*/
 615          unsigned char error_rx_pto(void)
 616          {
 617   1      
 618   1      static unsigned cnt_espera_ask_on=0;
 619   1      unsigned char error_rx_pto=ESPERA_MAS_TIEMPO;
 620   1      
 621   1          
 622   1                
 623   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 624   1            Debug_chr_Tibbo (cnt__ask_off); 
 625   1            Debug_chr_Tibbo (cnt_espera_ask_on);
 626   1            Debug_chr_Tibbo (error_rx_pto);
 627   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 628   1            if (aSk==OFF)
 629   1            
 630   1            { 
 631   2                cnt__ask_off++;                                                                   /*cuento el error*/                                                               
 632   2              if(cnt__ask_off>=10)
 633   2              { 
 634   3                Debug_txt_Tibbo((unsigned char *) "ATASCADO RESET\r\n\r\n");                                                                      /*no c
             -ontesta debe reset el transporte*/
 635   3                Rele_Atasco=ON;                                                                   /*off el rele de reset del verificador*/    
 636   3                Delay_10ms(110);
 637   3                cnt__ask_off=0;                                                                   /*limpio ls errores*/
 638   3                cnt_espera_ask_on=0;
 639   3                error_rx_pto=ESPERA_MAS_TIEMPO;                                                   /**/
 640   3                Rele_Atasco=OFF;  
 641   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 642   3                ValTimeOutCom=TIME_CARD;
 643   3              }
 644   2              else;
 645   2              {
 646   3                error_rx_pto=REENVIA_TRAMA;                                                       /*1 reenvia trama*/
 647   3                ValTimeOutCom=TIME_CARD;
 648   3              }
 649   2            }                                                                                     /*aSk esta activo */
 650   1            else
 651   1            {
 652   2                cnt_espera_ask_on++;                                                              /*cuento n tiempos de ask para recibir el total de
             - la trama*/
 653   2              if(cnt_espera_ask_on>=3)
 654   2              {
 655   3                cnt__ask_off=0;                                                                   /*paso tiempo de espera y no se completo la trama 
 656   3                                                                                                  limpio los reg y reenvio la trama y ask=off*/
 657   3                cnt_espera_ask_on=0;
 658   3                error_rx_pto=REENVIA_TRAMA;
 659   3                aSk=OFF;
 660   3                ValTimeOutCom=TIME_CARD;
 661   3              }
 662   2              else
 663   2              {
 664   3                cnt__ask_off=0;                                                                   /*damos tiempo de espera de la trama del transporte*
             -/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 12  

 665   3                error_rx_pto=ESPERA_MAS_TIEMPO;;
 666   3                ValTimeOutCom=TIME_CARD;
 667   3              }
 668   2            }
 669   1              return (error_rx_pto);
 670   1      }
 671          /*------------------------------------------------------------------------------
 672          Funcion de respuesta a los cmd del transporte
 673          Retorna rta_cmd_transporte el estado en que queda
 674          Recibe tres datos unos es el 
 675          Estado_futuro= significa que la respuesta fue ok
 676          Estado_Error= en caso de que aya un error a que estado envia el codigo
 677          Estado_Actua= No ha llegado la respuesta y sigue en el mismo estado
 678          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 679          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 680          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 681          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 682          
 683          (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 684          (1)= REENVIA_TRAMA reenvia la trama al transporte
 685          ------------------------------------------------------------------------------*/
 686          unsigned char   rta_cmd_transporte(unsigned char *secuencia_Expedidor )
 687          {
 688   1        unsigned char temp;
 689   1        unsigned char EstadoComSeqMF;
 690   1        
 691   1            
 692   1      if((temp=Trama_Validacion_P_N())!=RSPT_TRP_OK )
 693   1          {
 694   2            if(temp==ESPR_RSPT_TRP_TRAMA)                                                         /*no he recibido respuesta espero*/
 695   2            {
 696   3            EstadoComSeqMF= *(secuencia_Expedidor + EstadoActual);                    //                                  /*SEQ_RTA_CARD_POSno
             - ha respondido*/
 697   3            } 
 698   2            else if (temp==ERROR_TRP_TRAMA)
 699   2            {
 700   3            Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR\r\n\r\n");                     /* trama no valida respuesta inco
             -rrecta falla en la escritura */
 701   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 702   3            EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                         /*SEQ_INICIO (3) Tram
             -a invalida cmd (N)reenvio cmd*/ 
 703   3            }     
 704   2            else
 705   2            {
 706   3            /*Dispensador No Responde PTO SERIE ...*/
 707   3          
 708   3              if(temp=error_rx_pto()==ESPERA_MAS_TIEMPO)
 709   3              {
 710   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoActual); 
 711   4              }                                                                                     /*SEQ_RTA_CARD_POS;*/
 712   3              else                                                                                  //(temp=error_rx_pto()==REENVIA_TRAMA)
 713   3              {
 714   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                     /*SEQ_INICIO*/
 715   4              }                                                 
 716   3            }       
 717   2          }
 718   1          else
 719   1          {
 720   2            
 721   2            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);
 722   2            EstadoComSeqMF=*(secuencia_Expedidor + EstadoFuturo); 
 723   2          }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 13  

 724   1        return EstadoComSeqMF;
 725   1      }
 726          
 727          /*------------------------------------------------------------------------------
 728          ------------------------------------------------------------------------------*/
 729          unsigned char Analiza_Presencia_Mensual()
 730          {
 731   1        unsigned char Estado_expedidor;
 732   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 733   1          {
 734   2            MenSual = True;
 735   2            Estado_expedidor = SEQ_TIPO_CARD;                 //SEQ_UID
 736   2          }
 737   1        else
 738   1          { 
 739   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 740   2              send_portERR(PRMR_ERROR_LOOP);
 741   2              PantallaLCD(ERROR_LOOP);
 742   2              Estado_expedidor = SEQ_EXPULSAR_CARD;
 743   2                    
 744   2          }
 745   1        return Estado_expedidor;
 746   1      }
 747          unsigned char Analiza_Presencia_rotacion()
 748          {
 749   1        unsigned char Estado_expedidor;
 750   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 751   1          {
 752   2            
 753   2            Estado_expedidor = SEQ_MOVER_CARD_RF;                 //SEQ_UID
 754   2          }
 755   1        else
 756   1          { 
 757   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 758   2              send_portERR(PRMR_ERROR_LOOP);
 759   2              PantallaLCD(ERROR_LOOP);
 760   2              Estado_expedidor = SEQ_INICIO;  //SEQ_EXPULSAR_CARD;
 761   2                    
 762   2          }
 763   1        return Estado_expedidor;
 764   1      }
 765          /*------------------------------------------------------------------------------
 766          Funcion numero unico de identificacion
 767          ------------------------------------------------------------------------------*/
 768          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor )
 769          {
 770   1        unsigned char Estado_expedidor;
 771   1        unsigned char temp;
 772   1        unsigned char buffer_UID[17];
 773   1          if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
 774   1            {
 775   2              
 776   2                for (temp=0; temp<16; ++temp)
 777   2                {
 778   3                  buffer_UID [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de M
             -F en un arreglo*/
 779   3                 
 780   3                }
 781   2                
 782   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
 783   2                DebugBufferMF(buffer_UID,16,RESPUESTA);
 784   2                
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 14  

 785   2        
 786   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
 787   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_0]));  
 788   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_1]));  
 789   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_2]));  
 790   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_3]));
 791   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
 792   2                
 793   2              *(Atributos_Expedidor + Uid_0) = buffer_UID [MF_UID_0];   
 794   2              *(Atributos_Expedidor + Uid_1) = buffer_UID [MF_UID_1];     
 795   2              *(Atributos_Expedidor + Uid_2) = buffer_UID [MF_UID_2];     
 796   2              *(Atributos_Expedidor + Uid_3) = buffer_UID [MF_UID_3]; 
 797   2              Estado_expedidor=SEQ_LOAD_PASSWORD;                                                       //SEQ_TIPO_CARD;
 798   2            }   
 799   1            else
 800   1            {
 801   2              Estado_expedidor=SEQ_POWER_OFF;
 802   2            } 
 803   1            return Estado_expedidor;
 804   1      }
 805          /*------------------------------------------------------------------------------
 806          Se analiza si expulsa la tarjeta por boton o automatica
 807          ------------------------------------------------------------------------------*/
 808          unsigned char Ingreso_Vehiculo(void)
 809            {
 810   1          unsigned char CardAutomatic;  
 811   1          static unsigned char pulseboton=0;
 812   1        
 813   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 814   1          {
 815   2            CardAutomatic=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);  
 816   2            
 817   2            if (CardAutomatic==True)                                                    //se pregunta si expide la tarjeta automatica o por p
             -resionar el boton
 818   2              {
 819   3                Debug_txt_Tibbo((unsigned char *) "Tarjeta: Automatico\r\n");           //expide tarjetas automatico con p
             -resencia
 820   3                                                                                        // muevo la tarjeta hasta el lector de rf
 821   3                Estado=SEQ_MOVER_CARD_RF;                                               // valido el cmd enviado al verificador
 822   3               }
 823   2            else
 824   2              {     
 825   3                  if(pulseboton==False)
 826   3                  { PantallaLCD(PULSE_BOTON); 
 827   4                  }
 828   3                  else
 829   3                   {
 830   4                     pulseboton++;
 831   4                    
 832   4                   
 833   4                   }
 834   3                    sel_Pulsa();                                                        //se valida el pulsador en hardware
 835   3                    if (DataIn!=True)       
 836   3                      {
 837   4                        Debug_txt_Tibbo((unsigned char *) "Pulsador Activo\r\n");       //el pulsador fue presionado
 838   4                        pulseboton=0;                                                               //muevo tarjeta hasta el lector de RF
 839   4                        Estado=SEQ_MOVER_CARD_RF;                                       //valido el cmd enviado al verificador
 840   4                      }
 841   3                    else
 842   3                        {
 843   4                          Estado=SEQ_INICIO;  
 844   4                        }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 15  

 845   3                  
 846   3              } 
 847   2          }
 848   1          else
 849   1              { 
 850   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 851   2                Estado=SEQ_INICIO;  
 852   2              }
 853   1        return Estado;
 854   1      }
 855           
 856          /*------------------------------------------------------------------------------
 857          Se pregunta por el estado del expedidor si hay tarjetas y presencia para expulsar tarjeta
 858          o si hay tarjeta en la boca o rf para entrar en mensuales
 859          ------------------------------------------------------------------------------*/
 860          
 861          unsigned char Responde_Estado_Sensores_Transporte()
 862          {
 863   1        unsigned char Estado_expedidor;
 864   1          
 865   1            Debug_txt_Tibbo((unsigned char *) "TAREA_PRESENCIA_VEHICULAR\r\n");                                 // trama valida Hab
             -ilitado 
 866   1          
 867   1            if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                                 // CANAL LIBRE    no tiene 
             -tarjetas en el mecanismo
 868   1            {
 869   2                
 870   2              if  ((Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS)||(Buffer_Rta_Lintech[Pos_St1]==FULL_CARD  ))  //  se
             - detecta la tarjeta en la boca TARJETA EN BEZZEL
 871   2              {
 872   3                if (Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS  )                                             // nivel de tarjetas
 873   3                  {
 874   4                    Debug_txt_Tibbo((unsigned char *) "Nivel bajo de tarjetas\r\n");                            // nivel bajo de tarj
             -etas 
 875   4                    send_portERR(LOW_CARD);                                                                     //envio msj al primario
 876   4                  //  PantallaLCD(LOW_CARD);                                                                            //envio msj por la raspberry nivel ba
             -jo de tarjetas
 877   4                    Estado_expedidor=Ingreso_Vehiculo();        
 878   4                   }
 879   3                   else
 880   3                      {
 881   4                        /*respuesta ok*/
 882   4                       Estado_expedidor=Ingreso_Vehiculo();
 883   4                      
 884   4                      }
 885   3              } 
 886   2              else 
 887   2                  {
 888   3                    /*dispensador no posee tarjetas*/
 889   3                    Debug_txt_Tibbo((unsigned char *) "Dispensador SIN TARJETAS...\r\n"); 
 890   3                    
 891   3                    send_portERR(NO_CARD);  
 892   3                                                                          // se envia msj al uC principal, visualiza en el lcd que no hay tarjetas
 893   3                  //  PantallaLCD(NO_CARD);   
 894   3                    Estado_expedidor=SEQ_INICIO;                                                                //inicio el loop
 895   3                   }
 896   2            }
 897   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
 898   1              {
 899   2                    /*hay una tarjeta en la boca del verificador */
 900   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                                //se envia msj al debug
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 16  

             -er q hay tarjeta en la boca
 901   2                                                                                                                //se habilita recepcion de tarjetas por boca
 902   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;                                                     //se trabaja mensual        
 903   2              }
 904   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
 905   1                  
 906   1              {
 907   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en RF\r\n");
 908   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;
 909   2              }
 910   1            else
 911   1              {
 912   2                Estado_expedidor=SEQ_INICIO;  
 913   2              }
 914   1        return Estado_expedidor;  
 915   1      }
 916          
 917          /*------------------------------------------------------------------------------
 918          Funcion que nos dice el tipo de tarjeta que tiene en el mecanismo
 919          Comprobacion automatica del tipo de tarjeta 
 920          checking RF card type
 921          Card_type_H   Card_type_L  explicacion
 922              0             0           tarjeta desconocida
 923              1             0           MF50
 924              1             1           MF70
 925              1             2           MF_UL
 926              2             0           TYPE_A_CPU
 927          
 928          #define MF50_HIGH             '1'
 929          #define MF50_LOW              '0'
 930          ------------------------------------------------------------------------------*/
 931          unsigned char Responde_Tipo_Tarjeta()
 932            {
 933   1          unsigned char Estado_expedidor;
 934   1          
 935   1            Debug_txt_Tibbo((unsigned char *) "TAREA_TIPO DE TARJETA\r\n");                         // trama valida Habilitado 
 936   1            
 937   1        if (Buffer_Rta_Lintech[Card_type_H]==MF50_HIGH)                                             /* pregunto si la tarjeta en el tra
             -nsporte es MF 50 */
 938   1          {
 939   2          if (Buffer_Rta_Lintech[Card_type_L]==MF50_LOW)  
 940   2            {
 941   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n");                         /* trama valida son MF50*/
 942   3              if(MenSual ==  True)
 943   3              {
 944   4              Estado_expedidor = SEQ_UID;                                                             //SEQ_LOAD_PASSWORD;                        
 945   4              }
 946   3              else  
 947   3              {
 948   4                Estado_expedidor = SEQ_LOAD_PASSWORD;
 949   4              }         
 950   3            }
 951   2            else
 952   2              {
 953   3                 if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
 954   3                {
 955   4                Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida1 no es MF50\r\n");            /* trama no valida */
 956   4                send_portERR(PRMR_TARJETA_INVALIDA);                                                              /*envio msj principal tarjeta inva
             -lidad*/
 957   4                PantallaLCD(TARJETA_INVALIDA);
 958   4                        
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 17  

 959   4                  Estado_expedidor = Captura_Expulsa(); 
 960   4                
 961   4                } 
 962   3                else  
 963   3                {
 964   4                  MenSual = False;
 965   4                  Estado_expedidor = SEQ_INICIO;    
 966   4                }           
 967   3              }
 968   2          }
 969   1          else 
 970   1            {
 971   2               if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta 
             -en la boca TARJETA EN BEZZEL
 972   2                {
 973   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");           /* trama no valida */
 974   3              //send_portERR(AUDIO_GRACIAS);                                                              /*error audio*/ 
 975   3              send_portERR(PRMR_TARJETA_INVALIDA);                                                              //la tarjeta no es valida 
 976   3              PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la raspber
             -ry*/
 977   3                        
 978   3                  Estado_expedidor = Captura_Expulsa(); 
 979   3                          
 980   3                  
 981   3                }
 982   2                else  
 983   2                {
 984   3                  MenSual = False;
 985   3                  Estado_expedidor = SEQ_INICIO;    
 986   3                }                     
 987   2            }
 988   1                    
 989   1          return Estado_expedidor;                                                                                                  
 990   1        } 
 991          /*------------------------------------------------------------------------------
 992            Funcion que lee los datos en el Sector 1 Bloque 1
 993            se lee
 994            ID_CLIENTE
 995            COD_PARK
 996            TIPO DE TARJETA
 997            EXPIRA_ANO
 998            EXPIRA_MES
 999            EXPIRA_DIA
1000          ------------------------------------------------------------------------------*/
1001          
1002          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
1003          {
1004   1        unsigned char temp;
1005   1        unsigned char Estado_expedidor;
1006   1        unsigned char buffer_S1_B1[17];
1007   1        unsigned char ID_CLIENTE;
1008   1        unsigned char COD_PARK;   
1009   1        static unsigned char falla=0;
1010   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE1\r\n");   
1011   1                                        
1012   1                                      
1013   1            
1014   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1015   1            {
1016   2              
1017   2                for (temp=0; temp<16; ++temp)
1018   2                {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 18  

1019   3                  buffer_S1_B1 [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de
             - MF en un arreglo*/
1020   3                 
1021   3                }
1022   2                
1023   2                
1024   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b1\r\n");
1025   2                DebugBufferMF(buffer_S1_B1,16,RESPUESTA);
1026   2                ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1027   2                COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
1028   2                /*Compara  MF_ID_CLIENTE y MF_COD_PARK con el codigo del parqueadero ID_CLIENTE  COD_PARK*/
1029   2                
1030   2                if (((buffer_S1_B1 [ MF_ID_CLIENTE])==ID_CLIENTE) && ((buffer_S1_B1 [ MF_COD_PARK] ) == COD_PARK)||((
             -ID_CLIENTE==0)&&(COD_PARK==0)))   
1031   2                {
1032   3                    
1033   3                  Debug_txt_Tibbo((unsigned char *) "CARD ID_CLIENTE: ");               
1034   3                  Debug_HexDec((buffer_S1_B1 [ MF_ID_CLIENTE]));
1035   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1036   3                  
1037   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");                
1038   3                  Debug_HexDec(ID_CLIENTE);
1039   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1040   3                  
1041   3                  Debug_txt_Tibbo((unsigned char *) "CARD COD_PARK:");                    
1042   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1043   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1044   3                  
1045   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");                   
1046   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1047   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1048   3      
1049   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
1050   3                  Debug_chr_Tibbo(buffer_S1_B1 [MF_TIPO_TARJETA]);
1051   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1052   3                  
1053   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S1_B1 [MF_TIPO_TARJETA];
1054   3                  /*fecha de vencimiento de mensual o prepago*/
1055   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S1_B1 [MF_EXPIRA_ANO];
1056   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S1_B1 [MF_EXPIRA_MES];
1057   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S1_B1 [MF_EXPIRA_DIA];
1058   3                  
1059   3                  *(Atributos_Expedidor + Sector) = Sector_1;
1060   3                  *(Atributos_Expedidor + Bloque) = Bloque_2;
1061   3                  falla=0;
1062   3                  Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1063   3              
1064   3                }
1065   2                else
1066   2                {
1067   3                  falla=0;
1068   3                  Debug_txt_Tibbo((unsigned char *) "ERROR COD PARK\r\n");
1069   3                  send_portERR(PRMR_ERROR_COD_PARK);
1070   3                  PantallaLCD(ERROR_COD_PARK);                                                        //envio el msj por la pantalla lcd o la rasp
             -berry
1071   3                  Estado_expedidor = Captura_Expulsa();                                                 //   codigo de parqueo erro expulso la 
             -tarjeta     
1072   3                }
1073   2            }
1074   1            else
1075   1            {
1076   2                
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 19  

1077   2              if ((Buffer_Rta_Lintech[Rtype]) == OPERATE_FAIL)
1078   2              {
1079   3                falla++;
1080   3              }
1081   2               if (falla <= 2)
1082   2                
1083   2              {
1084   3                Debug_txt_Tibbo((unsigned char *) "ERROR OPERATE FAIL\r\n");
1085   3                Estado_expedidor = SEQ_POWER_ON;
1086   3                                    
1087   3              }
1088   2              else
1089   2              {
1090   3                falla=0;
1091   3                Debug_txt_Tibbo((unsigned char *) "TARJETA SIN FORMATO\r\n");
1092   3                send_portERR(PRMR_TARJETA_SIN_FORMATO);
1093   3                PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la 
             -raspberry*/
1094   3               Estado_expedidor =Captura_Expulsa();   
1095   3              }
1096   2            }
1097   1            
1098   1        return Estado_expedidor;
1099   1      } 
1100          /*------------------------------------------------------------------------------
1101          
1102          ------------------------------------------------------------------------------*/
1103          
1104          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
1105          {
1106   1        unsigned char temp;
1107   1        unsigned char Estado_expedidor;
1108   1        unsigned char buffer_S1_B2[17]; 
1109   1      
1110   1            
1111   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");   
1112   1            
1113   1                              
1114   1            
1115   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1116   1            {
1117   2              
1118   2                for (temp=0; temp<16; ++temp)
1119   2                {
1120   3                  buffer_S1_B2 [temp] =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion d
             -e MF en un arreglo*/
1121   3                }
1122   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b2\r\n");
1123   2                DebugBufferMF(buffer_S1_B2,16,RESPUESTA);
1124   2                
1125   2                      
1126   2                
1127   2                Debug_txt_Tibbo((unsigned char *) "HORARIO:");
1128   2                Debug_chr_Tibbo((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1129   2                *(Atributos_Expedidor + Horario)= ((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1130   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1131   2                
1132   2                Debug_txt_Tibbo((unsigned char *) "PICO Y PLACA:");
1133   2                
1134   2                *(Atributos_Expedidor + Pico_Placa)= ((buffer_S1_B2 [MF_IN_PAGO] & 0XF0) >> 4);
1135   2                Debug_chr_Tibbo(*(Atributos_Expedidor + Pico_Placa));
1136   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 20  

1137   2                
1138   2            
1139   2                Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK:");
1140   2                Debug_chr_Tibbo(buffer_S1_B2 [MF_APB] );
1141   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1142   2              
1143   2                /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
1144   2                
1145   2                *(Atributos_Expedidor + Apb)=   buffer_S1_B2 [MF_APB] ;
1146   2                
1147   2                
1148   2                  *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S1_B2 [MF_TIPO_VEHICULO]& 0x0f;
1149   2                  Estado_expedidor =SEQ_TIPO_TARJETAS;    // Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);
1150   2            
1151   2        
1152   2            }
1153   1            else
1154   1            {
1155   2              Estado_expedidor = Captura_Expulsa(); //momentario
1156   2            }
1157   1          return Estado_expedidor;  
1158   1      }
1159          
1160          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque0 (unsigned char *Nombre_Mensual)
1161          {
1162   1        unsigned char temp;
1163   1        unsigned char Estado_expedidor;
1164   1          
1165   1      
1166   1            
1167   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE0\r\n");   
1168   1            
1169   1                              
1170   1            
1171   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1172   1            {
1173   2              
1174   2                for (temp=0; temp<16; ++temp)
1175   2                {
1176   3                  *(Nombre_Mensual + temp ) =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informa
             -cion de MF en un arreglo*/
1177   3                }
1178   2                *(Nombre_Mensual + temp )=NULL;
1179   2                Debug_txt_Tibbo((unsigned char *) "Nombre Mensual:");
1180   2                Debug_txt_Tibbo(Nombre_Mensual );
1181   2                Debug_txt_Tibbo((unsigned char *) "\r\n");      
1182   2                Estado_expedidor = SEQ_LPR;           //SEQ_TIPO_TARJETAS;                                                // Valida_Tipo_Tarjeta(A
             -tributos_Expedidor,Buffer_Write_MF);
1183   2            
1184   2        
1185   2            }
1186   1            else
1187   1            {
1188   2              Estado_expedidor = Captura_Expulsa(); //momentario
1189   2            }
1190   1          return Estado_expedidor;  
1191   1      }
1192          unsigned char Responde_Write_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buf
             -fer_Write_MF)
1193          {
1194   1        unsigned char Estado_expedidor;
1195   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE2\r\n"); 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 21  

1196   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b2\r\n");
1197   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1198   1        if(MenSual !=  True)
1199   1        {
1200   2        *(Atributos_Expedidor + Sector) = Sector_1;
1201   2        *(Atributos_Expedidor + Bloque) = Bloque_0;
1202   2        Armar_Trama_Tarjeta_Sector1_Bloque0(Buffer_Write_MF);
1203   2          Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1204   2        }
1205   1        else
1206   1        {
1207   2          *(Atributos_Expedidor + Sector) = Sector_1;
1208   2          *(Atributos_Expedidor + Bloque) = Bloque_0;
1209   2          Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1210   2          
1211   2        }
1212   1        return Estado_expedidor;
1213   1      }
1214          /*----------------------------------------------------------------------------
1215          ----------------------------------------------------------------------------*/
1216          unsigned char Responde_Write_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1217          {
1218   1      
1219   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE0\r\n"); 
1220   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b0\r\n");
1221   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1222   1        
1223   1        return SEQ_LPR;
1224   1      }
1225          /*----------------------------------------------------------------------------
1226          ----------------------------------------------------------------------------*/
1227          unsigned char Pregunta_Lpr(unsigned char *Atributos_Expedidor)
1228          {
1229   1        unsigned char Estado_expedidor;
1230   1          if(rd_eeprom(0xa8,EE_USE_LPR)== True)
1231   1             {
1232   2               /*monitor trama*/
1233   2               Debug_txt_Tibbo(Armar_Trama_Monitor(Atributos_Expedidor));
1234   2                if (rd_eeprom(0xa8,EE_DEBUG) == False)
1235   2                 {
1236   3                   Debug_Tibbo=False;
1237   3                 }
1238   2             }
1239   1        
1240   1          if (rd_eeprom(0xa8,EE_PLACA)!= False)
1241   1          {
1242   2            /*espero placa*/
1243   2            Estado_expedidor=SEQ_WAIT_PLACA;
1244   2            ValTimeOutCom=TIME_WAIT ;
1245   2            Timer_wait=False;
1246   2          }
1247   1          else 
1248   1          {
1249   2          Estado_expedidor=SEQ_FRONT_CARD;
1250   2          }
1251   1        return Estado_expedidor;
1252   1      }
1253          /*----------------------------------------------------------------------------
1254          ----------------------------------------------------------------------------*/
1255          unsigned char Responde_Write_Tarjeta_Sector2_Bloque0(unsigned char *Buffer_Write_MF)
1256          {
1257   1        
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 22  

1258   1        Debug_txt_Tibbo((unsigned char *) "PLACA:");  
1259   1        Debug_txt_Tibbo((unsigned char *) placa);
1260   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1261   1        Debug_txt_Tibbo((unsigned char *) "Write_s2_b0\r\n");
1262   1        DebugBufferMF(Buffer_Write_MF,16,ENVIADOS);
1263   1        return SEQ_FRONT_CARD;
1264   1      }
1265          unsigned char  Respuesta_Segunda_clave(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1266          {
1267   1        Debug_txt_Tibbo((unsigned char *) "TAREA_SEGUNDA CLAVE\r\n"); 
1268   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1269   1        *(Atributos_Expedidor + Sector) = Sector_2;
1270   1        *(Atributos_Expedidor + Bloque) = Bloque_0;
1271   1        Armar_Trama_Placa(Buffer_Write_MF);
1272   1        return SEQ_WRITE_SECTOR_BLOQUE;
1273   1      }
1274          /*------------------------------------------------------------------------------
1275          ------------------------------------------------------------------------------*/
1276          //void  Armar_Trama_Tarjeta_Sector1_Bloque1(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write
             -_MF)
1277          //{
1278          //  *(Buffer_Write_MF +0) = *(Atributos_Expedidor + Tipo_Tarjeta);
1279          //  *(Buffer_Write_MF +0) = *(Atributos_Expedidor + Tipo_Tarjeta);
1280          //} 
1281          
1282          /*------------------------------------------------------------------------------
1283          ------------------------------------------------------------------------------*/
1284          
1285          void  Armar_Trama_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_M
             -F)
1286          {
1287   1        
1288   1        /*fecha de ingreso se lee año,mes,dia,hora y minutos*/
1289   1        
1290   1        Block_read_Clock_Hex(Buffer_Write_MF);
1291   1        
1292   1        /*descuentos los borro*/
1293   1        
1294   1        *(Buffer_Write_MF + 5)=0;
1295   1        *(Buffer_Write_MF + 6)=0;
1296   1        *(Buffer_Write_MF + 7)=0;
1297   1        
1298   1        if (*(Atributos_Expedidor + Tipo_Tarjeta) == ROTACION)
1299   1        {
1300   2          *(Buffer_Write_MF + 8)  = Tipo_Vehiculo;
1301   2          *(Buffer_Write_MF + 9)  = (Dir_board())- 0x30;
1302   2          *(Buffer_Write_MF +10) = APB_INT;
1303   2        }
1304   1        
1305   1        /*mensual*/
1306   1        else
1307   1        {
1308   2          
1309   2          *(Buffer_Write_MF + 8)  = (*(Atributos_Expedidor + Horario) << 4) | (*(Atributos_Expedidor + Type_Vehicu
             -lo));
1310   2          *(Buffer_Write_MF + 9)  =  (*(Atributos_Expedidor + Pico_Placa) << 4)| (Dir_board())- 0x30;
1311   2          
1312   2          if (*(Atributos_Expedidor + Apb)== APB_NO)
1313   2           {
1314   3              *(Buffer_Write_MF +10) =APB_NO;
1315   3            }
1316   2          else 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 23  

1317   2          {
1318   3            *(Buffer_Write_MF +10) =APB_INT;
1319   3          }
1320   2        }
1321   1        /*fecha de salida maxima*/
1322   1        *(Buffer_Write_MF +11)=0;
1323   1        *(Buffer_Write_MF +12)=0;
1324   1        *(Buffer_Write_MF +13)=0;
1325   1        *(Buffer_Write_MF +14)=0;
1326   1        *(Buffer_Write_MF +15)=0;
1327   1      }
1328          void Armar_Trama_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1329          {
1330   1        /*graba serie de Ticket*/
1331   1        strcpy(Buffer_Write_MF, Lee_No_Ticket());
1332   1      }
1333          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor(unsigned char *h)
1334          {
1335   1        static unsigned char buffer[28];
1336   1        unsigned char ticket[11];
1337   1        unsigned char j;
1338   1        /*la trama esta compuesta de
1339   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1340   1      
1341   1        buffer[0]=STX;
1342   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR;
1343   1        buffer[2]=NULL;
1344   1        strcpy(ticket, Lee_No_Ticket());
1345   1        strcat(buffer , ticket);
1346   1        j=strlen(buffer);
1347   1        
1348   1        buffer[j++]= '-';
1349   1        
1350   1        Block_read_Clock_Hex(buffer+j);         //leo la fecha de entrada
1351   1        buffer[j]=buffer[j]+0x030;              /*año de entrada*/
1352   1        buffer[j+1]=buffer[j+1]+0x030;          /*mes de entrada*/
1353   1        buffer[j+2]=buffer[j+2]+0x030;          /*dia de entrada*/
1354   1        buffer[j+3]=buffer[j+3]+0x030;          /*hora de entrada*/
1355   1        buffer[j+4]=buffer[j+4]+0x030;          /*minutos de entrada*/
1356   1        buffer[j+5]= '-';
1357   1        /*placa*/
1358   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1359   1        {   
1360   2          if (placa_ready != False)
1361   2          {
1362   3            buffer[j+6]= placa[0];
1363   3            buffer[j+7]= placa[1];
1364   3            buffer[j+8]= placa[2];
1365   3            buffer[j+9]= placa[3];
1366   3            buffer[j+10]= placa[4];
1367   3            buffer[j+11]= placa[5];
1368   3            buffer[j+12]= NULL;
1369   3          }
1370   2          else
1371   2          {
1372   3            buffer[j+6]= ' ';
1373   3            buffer[j+7]= NULL;
1374   3          }
1375   2        }
1376   1        else 
1377   1        {
1378   2          buffer[j+6]= ' ';
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 24  

1379   2          buffer[j+7]=NULL;
1380   2        }
1381   1        j=strlen(buffer);
1382   1        buffer[j]= ETX;
1383   1        *h=j+1;
1384   1        
1385   1        return buffer;
1386   1      }
1387          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor,unsigned char
             - *j)
1388          {
1389   1        static unsigned char buffer[28];
1390   1      
1391   1        /*la trama esta compuesta de
1392   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1393   1      
1394   1        buffer[0]=STX;
1395   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
1396   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
1397   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
1398   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
1399   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
1400   1        
1401   1        
1402   1        Block_read_Clock_Hex(buffer+6);         //leo la fecha de entrada
1403   1        buffer[6]=buffer[6]+0x030;              /*año de entrada*/
1404   1        buffer[7]=buffer[7]+0x030;          /*mes de entrada*/
1405   1        buffer[8]=buffer[8]+0x030;          /*dia de entrada*/
1406   1        buffer[9]=buffer[9]+0x030;          /*hora de entrada*/
1407   1        buffer[10]=buffer[10]+0x030;          /*minutos de entrada*/
1408   1      
1409   1        /*placa*/
1410   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1411   1        {   
1412   2          
1413   2            buffer[11]= placa[0];
1414   2            buffer[12]= placa[1];
1415   2            buffer[13]= placa[2];
1416   2            buffer[14]= placa[3];
1417   2            buffer[15]= placa[4];
1418   2            buffer[16]= placa[5];
1419   2      
1420   2        }
1421   1      
1422   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1423   1        {
1424   2          buffer[17]= 'C';
1425   2        }
1426   1        else
1427   1        {
1428   2          buffer[17]= 'M';
1429   2        }
1430   1        
1431   1        buffer[18]= ETX;
1432   1        buffer[19]= NULL;
1433   1        *j=19;
1434   1        return buffer;
1435   1      }
1436          unsigned char *Armar_Trama_Monitor(unsigned char *Atributos_Expedidor)
1437          {
1438   1        static unsigned char buffer[24];
1439   1        unsigned char ticket[11];
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 25  

1440   1        unsigned char j;
1441   1        /*la trama esta compuesta de
1442   1        STX,address_board,CMD,Tipo_Vehiculo,NoTICKET,:,fecha int añomesdishoraminuto,:,ETX*/
1443   1        Debug_Tibbo=False;
1444   1        buffer[0]=STX;
1445   1        buffer[1]=Dir_Board_Monitor();
1446   1        buffer[2]=CMD_MONITOR_EXPEDIDOR;
1447   1        if(Tipo_Vehiculo == AUTOMOVIL)
1448   1          {
1449   2            buffer[3]= 'C';
1450   2          }
1451   1        else
1452   1          {
1453   2            buffer[3]= 'M';
1454   2          }
1455   1          
1456   1          /*ticket*/
1457   1          if(MenSual !=  True)
1458   1          {
1459   2          buffer[4]=NULL;
1460   2          strcpy(ticket, Lee_No_Ticket());
1461   2          strcat(buffer , ticket);
1462   2          }
1463   1          else
1464   1          {
1465   2            ByteHex_Decimal(buffer+4,*(Atributos_Expedidor + Uid_2));
1466   2            j=strlen(buffer);
1467   2            buffer[j]= ' ';
1468   2            buffer[j+1]= NULL;
1469   2            j=strlen(buffer);
1470   2            Two_ByteHex_Decimal(buffer+j,*(Atributos_Expedidor + Uid_1),*(Atributos_Expedidor + Uid_0));
1471   2            
1472   2          }
1473   1          j=strlen(buffer);
1474   1          buffer[j]=':';
1475   1          /*fecha de entrada*/
1476   1          
1477   1          Block_read_clock_ascii(buffer+j+1);     //leo la fecha de entrada
1478   1          j=strlen(buffer);
1479   1        
1480   1          buffer[j]= ':';
1481   1          buffer[j+1]=ETX;
1482   1          buffer[j+2]=NULL;
1483   1          Debug_Tibbo=True;
1484   1        return buffer;
1485   1      }
1486          void Armar_Trama_Placa(unsigned char *Buffer_Write_MF)
1487          {
1488   1        unsigned char j;
1489   1        
1490   1          for(j=0; j<8;j++)
1491   1          {
1492   2          *(Buffer_Write_MF +j)=placa[j];
1493   2          }
1494   1            for (j=8; j<16; j++)            
1495   1          {
1496   2            *(Buffer_Write_MF +j)=0x00;
1497   2          }
1498   1      }
1499          unsigned char Load_Secuencia_Expedidor(unsigned char *Secuencia_Expedidor,unsigned const  estadoactivo,uns
             -igned const estadoactual,unsigned const estadofuturo)
1500          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 26  

1501   1        *(Secuencia_Expedidor + EstadoPasado ) = estadoactivo ;
1502   1        *(Secuencia_Expedidor + EstadoActual ) = estadoactual;
1503   1        *(Secuencia_Expedidor + EstadoFuturo ) = estadofuturo;
1504   1        return estadoactual;
1505   1      }
1506          unsigned char Disparo_Lock_Entrada_Vehiculo(unsigned char *Nombre_Mensual)
1507          {
1508   1        unsigned char Estado_expedidor;
1509   1        Debug_txt_Tibbo((unsigned char *) "TAKE CARD\r\n");
1510   1        
1511   1        PantallaLCD(RETIRE_TARJETA);
1512   1        
1513   1        if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                   // CANAL LIBRE    no tiene tarjetas 
             -en el mecanismo
1514   1          {
1515   2            Debug_txt_Tibbo((unsigned char *) "TAREA_OPEN_BARRERA\r\n");  
1516   2            lock=ON;
1517   2            send_portERR(BIENVENIDO);
1518   2            PantallaLCD_LINEA_2(BIENVENIDO,Nombre_Mensual);
1519   2            Estado_expedidor=SEQ_PTO_PARALELO;
1520   2            
1521   2            
1522   2          }
1523   1        else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                      //  se detecta la tarjeta en la b
             -oca TARJETA EN BEZZEL
1524   1        {
1525   2          if(Valida_Sensor1_Auto()!= False)
1526   2          {
1527   3            Estado_expedidor=SEQ_DETAIL_CARD;
1528   3          }
1529   2          else
1530   2          {
1531   3            Estado_expedidor=SEQ_CAPTURE_CARD;
1532   3          }
1533   2        
1534   2        }
1535   1        return Estado_expedidor;
1536   1      }
1537          unsigned char Send_Pto_Paralelo(unsigned char *Atributos_Expedidor)
1538          {
1539   1        unsigned char *Trama_Expedidor ;
1540   1        unsigned char leng_trama_pto;
1541   1        if(MenSual == True)
1542   1        {
1543   2        Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor,&leng_trama_pto );
1544   2        }
1545   1        else 
1546   1        {
1547   2          Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor(&leng_trama_pto);
1548   2          Incremente_Ticket();
1549   2        }
1550   1        //send_port(Trama_Expedidor,strlen(Trama_Expedidor)); 
1551   1        send_port(Trama_Expedidor,leng_trama_pto);  
1552   1        Debug_txt_Tibbo((unsigned char *) "Trama_pto_paralelo\r\n");
1553   1        DebugBufferMF(Trama_Expedidor,leng_trama_pto,ENVIADOS);
1554   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1555   1        
1556   1        
1557   1        clear_placa();
1558   1        ValTimeOutCom=TIME_WAIT ;
1559   1        Timer_wait=0;
1560   1        return SEQ_ESPERA_VEHICULO_ENTRE;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 27  

1561   1      }
1562          
1563          /*------------------------------------------------------------------------------
1564          ------------------------------------------------------------------------------*/
1565          unsigned char Entrega_Card_Captura()
1566          {
1567   1        unsigned char Estado_expedidor;
1568   1        
1569   1          
1570   1        Debug_txt_Tibbo((unsigned char *) "ESPERA VEHICULO ENTRE\r\n"); 
1571   1        sel_Sensor2();                                //garantiso q la barrera se encuentre en posicion baja  
1572   1        if ((DataIn==0))        
1573   1        {  
1574   2          if (ValidaSensor()==0)
1575   2          {
1576   3            lock=OFF;
1577   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo Entrando");
1578   3            Estado_expedidor=SEQ_INICIO;
1579   3          }
1580   2          
1581   2        }
1582   1        else
1583   1        {
1584   2            if(Valida_Sensor1_Auto()!= False)
1585   2            {
1586   3            /*presencia vehicular*/
1587   3              Estado_expedidor=SEQ_ESPERA_VEHICULO_ENTRE;//SEQ_INICIO;//
1588   3              
1589   3              if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1590   3              {
1591   4                  if (Timer_wait >= 5)
1592   4               {
1593   5                 lock=OFF;
1594   5                 Estado_expedidor=SEQ_INICIO;;
1595   5               }
1596   4              else if (Timer_wait <= 4)
1597   4               {
1598   5                ValTimeOutCom=TIME_WAIT ;
1599   5               }
1600   4             }
1601   3              
1602   3            }
1603   2            else
1604   2            {
1605   3            lock=OFF;
1606   3            Estado_expedidor=SEQ_INICIO;
1607   3            }
1608   2        } 
1609   1       
1610   1        return Estado_expedidor;
1611   1      }
1612          unsigned char Wait_Placa(unsigned char *secuencia_expedidor, unsigned char estadoactivo)
1613          {
1614   1        unsigned char Estado_expedidor;
1615   1        
1616   1        
1617   1      while ((ValTimeOutCom != 1) && (ValTimeOutCom <= TIME_WAIT) && (placa_ready == False))
1618   1        {
1619   2          if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
1620   2              {
1621   3                
1622   3                Rx_Monitor();
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 28  

1623   3              }
1624   2        }
1625   1        
1626   1          if(placa_ready!=False)
1627   1            {
1628   2              Clave_Seguridad_S2();
1629   2              Estado_expedidor=Load_Secuencia_Expedidor(secuencia_expedidor,estadoactivo,SEQ_CMD_ACEPTADO,SEQ_RESPUE
             -STA_TRANSPORTE);    
1630   2              *(secuencia_expedidor +TareadelCmd ) = TAREA_WRITE_PLACA_CARD;
1631   2            }
1632   1            else
1633   1            {
1634   2                Estado_expedidor=SEQ_WAIT_PLACA;
1635   2             if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1636   2             {  
1637   3              if (Timer_wait >= 5)
1638   3               {
1639   4                 Estado_expedidor=SEQ_FRONT_CARD;
1640   4               }
1641   3              else if (Timer_wait <= 4)
1642   3               {
1643   4                ValTimeOutCom=TIME_WAIT ;
1644   4               }
1645   3             }
1646   2            }
1647   1        return Estado_expedidor;
1648   1      }
1649          unsigned char Valida_Vehiculo_Card_Mensual(unsigned char *Atributos_Expedidor)
1650          {
1651   1        unsigned char Estado_expedidor;
1652   1        
1653   1          Debug_txt_Tibbo((unsigned char *) "VEHICULO MENSUAL TARJETA: ");
1654   1          if(*(Atributos_Expedidor + Type_Vehiculo  ) == False)
1655   1           {
1656   2            Debug_txt_Tibbo((unsigned char *) "(0) CARRO");
1657   2           }
1658   1          else
1659   1           {
1660   2            Debug_txt_Tibbo((unsigned char *) "(1) MOTO");
1661   2           }
1662   1                            
1663   1          Debug_txt_Tibbo((unsigned char *) "\r\n");
1664   1        if ((rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL)) != True) 
1665   1        {
1666   2          if  (*(Atributos_Expedidor + Type_Vehiculo  ) == Tipo_Vehiculo )          
1667   2          {
1668   3           Debug_txt_Tibbo((unsigned char *) "COINCIDE CARD CON LOOK\r\n ");
1669   3            Estado_expedidor = True ;
1670   3          }
1671   2          
1672   2          else
1673   2          {
1674   3            send_portERR(PRMR_ERROR_TIPO_VEHICULO); 
1675   3            Debug_txt_Tibbo((unsigned char *) "TIPO DE VEHICULO NO CORRESPONDE\r\n ");
1676   3            Estado_expedidor = False; 
1677   3          }
1678   2        } 
1679   1        else 
1680   1        {
1681   2            Debug_txt_Tibbo((unsigned char *) "NO INTERESA COINCIDENCIA CARD CON LOOK\r\n ");
1682   2            Estado_expedidor = True ;
1683   2        }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 29  

1684   1          return Estado_expedidor;
1685   1      }
1686          unsigned char Tarjeta_Mensual(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1687          {
1688   1        unsigned char Estado_expedidor;
1689   1      //  unsigned char fecha_asii[7];
1690   1        
1691   1        /*cheque la fecha de expiracion del mensual*/
1692   1        if (Horarios(Atributos_Expedidor) == True)
1693   1        {
1694   2         if ( check_fechaOut(Atributos_Expedidor+Expira_ano) == True )
1695   2            {
1696   3              /*valida el vehiculo en el loop y en la card*/
1697   3              if( Valida_Vehiculo_Card_Mensual(Atributos_Expedidor) == False)
1698   3              {
1699   4              Estado_expedidor = Captura_Expulsa();   
1700   4              }
1701   3              else
1702   3              {
1703   4                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1704   4                *(Atributos_Expedidor + Sector) = Sector_1;
1705   4                *(Atributos_Expedidor + Bloque) = Bloque_2;
1706   4                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1707   4                Estado_expedidor=SEQ_WRITE_SECTOR_BLOQUE;
1708   4              }
1709   3            }
1710   2            else 
1711   2            {
1712   3              send_portERR(PRMR_TARJETA_VENCIDA); 
1713   3                  
1714   3              PantallaLCD(TARJETA_VENCIDA);
1715   3              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
1716   3              Estado_expedidor = SEQ_EXPULSAR_CARD;
1717   3            }
1718   2        }
1719   1        else
1720   1        {
1721   2          
1722   2          Estado_expedidor = SEQ_EXPULSAR_CARD;
1723   2        }
1724   1        return Estado_expedidor;
1725   1      }
1726          unsigned char Tarjeta_Rotacion(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1727          {
1728   1              *(Atributos_Expedidor + Sector) = Sector_1;
1729   1                *(Atributos_Expedidor + Bloque) = Bloque_2;
1730   1                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1731   1                return  SEQ_WRITE_SECTOR_BLOQUE;
1732   1        
1733   1        
1734   1      }
1735          unsigned char Valida_Tipo_Tarjeta(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1736          {
1737   1        unsigned char Estado_expedidor;
1738   1        if(*(Atributos_Expedidor + Tipo_Tarjeta) ==  MENSUALIDAD)
1739   1        {
1740   2          Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
1741   2          if(MenSual ==  True)
1742   2          {
1743   3          //Estado_expedidor=SEQ_CAPTURE_CARD;                                        
1744   3      
1745   3          /*APB Habilitado por software*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 30  

1746   3          
1747   3            if( (rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL) == APB_HABILITADO_SOFT) )
1748   3            {
1749   4              /*APB por Card*/
1750   4           
1751   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO))       
1752   4              {
1753   5                Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1754   5      
1755   5              }
1756   4              else
1757   4              {
1758   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK MENSUAL \r\n");
1759   5                send_portERR(PRMR_SIN_SALIDA);
1760   5                //PantallaLCD(REGISTRA_INGRESO);
1761   5                Estado_expedidor = Captura_Expulsa(); 
1762   5              } 
1763   4            }
1764   3          
1765   3          else
1766   3          {
1767   4            Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO MENSUAL \r\n");
1768   4          
1769   4           Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1770   4          }
1771   3        }
1772   2        else
1773   2         {
1774   3          send_portERR(PRMR_NO_CARD_MENSUAL);
1775   3          PantallaLCD(NO_CARD_MENSUAL);     
1776   3          Estado_expedidor = Captura_Expulsa(); 
1777   3         } 
1778   2       }
1779   1        else if (*(Atributos_Expedidor + Tipo_Tarjeta) ==  ROTACION)
1780   1        {
1781   2          
1782   2            Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n ");
1783   2          if(MenSual != True)
1784   2          {
1785   3            if ( (rd_eeprom(0xa8,EE_HABILITA_APB))!= APB_INHABILITADO_SOFT)
1786   3            {
1787   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO) )
1788   4                                    
1789   4              {
1790   5                Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
1791   5              }
1792   4              else
1793   4              {
1794   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK ROTACION \r\n");
1795   5                send_portERR(PRMR_SIN_SALIDA);
1796   5                PantallaLCD(SIN_SALIDA);
1797   5                Estado_expedidor = Captura_Expulsa();
1798   5              }
1799   4            }
1800   3            else
1801   3            {
1802   4              Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO ROTACION \r\n");
1803   4              Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
1804   4            } 
1805   3          }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 31  

1806   2          else
1807   2          {
1808   3            send_portERR(PRMR_NO_CARD_MENSUAL);
1809   3            PantallaLCD(NO_CARD_MENSUAL);     
1810   3            Estado_expedidor = Captura_Expulsa();   
1811   3          }
1812   2        }
1813   1        else
1814   1        {
1815   2          Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n ");
1816   2          send_portERR(PRMR_NO_ROTACION);
1817   2          
1818   2          Estado_expedidor = Captura_Expulsa();   
1819   2        }
1820   1        
1821   1        return Estado_expedidor;
1822   1      }
1823          /*
1824          unsigned char Festivos()
1825          {
1826            
1827            unsigned char dia_semana,day, month, year,DiaFestivo=0;
1828          
1829            
1830            dia_semana=bcd_hex(lee_clk(RDIA_SEMANA));
1831            day = bcd_hex(lee_clk(RDIA));
1832            month = bcd_hex(lee_clk(RMES));
1833            year = bcd_hex(lee_clk(RANO));
1834            
1835            if (year==20)
1836            {
1837              if (((month==1)&&(day==1))||((month==1)&&(day==6))||((month==3)&&(day==23))||((month==4)&&(day==9))||((m
             -onth==4)&&(day==10))||((month==5)&&(day==1))||((month==5)&&(day==25))||((month==6)&&(day==3)))  
1838              {
1839                DiaFestivo = True;
1840                }
1841              else if (((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==17))||((month==10)&&(day==1
             -2))||((month==11)&&(day==2))||((month==11)&&(day==16))||((month==12)&&(day==8))||((month==12)&&(day==25)))
1842              {
1843                DiaFestivo = True;
1844              }
1845          
1846            }
1847            else if (year==21)
1848            {
1849              if (((month==1)&&(day==1))||((month==1)&&(day==11))||((month==3)&&(day==22))||((month==4)&&(day==1))||((
             -month==4)&&(day==2))||((month==5)&&(day==1))||((month==5)&&(day==17))||((month==6)&&(day==7))||((month==6)&&(day==14))) 
1850              {
1851                DiaFestivo = True;
1852                }
1853              else if (((month==7)&&(day==5))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==16)
             -)||((month==10)&&(day==18))||((month==11)&&(day==1))||((month==11)&&(day==15))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
1854              {
1855                DiaFestivo = True;
1856              }
1857          
1858            }
1859            else if (year==22)
1860            {
1861              if (((month==1)&&(day==1))||((month==1)&&(day==10))||((month==3)&&(day==21))||((month==4)&&(day==14))||(
             -(month==4)&&(day==15))||((month==5)&&(day==1))||((month==5)&&(day==30))||((month==6)&&(day==20))||((month==6)&&(day==27)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 32  

             -))  
1862              {
1863                DiaFestivo = True;
1864                }
1865              else if (((month==7)&&(day==4))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==15)
             -)||((month==10)&&(day==17))||((month==11)&&(day==7))||((month==11)&&(day==14))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
1866              {
1867                DiaFestivo = True;
1868              }
1869          
1870            
1871            
1872            }
1873            if ((dia_semana == Sabado)||(dia_semana == Domingo)||(DiaFestivo == True))
1874            {
1875              DiaFestivo = True;
1876            }
1877            else
1878            {
1879              DiaFestivo = False;
1880            }
1881            return DiaFestivo;
1882          }
1883          */
1884          /*
1885          unsigned char Dia_Pico_Placa(unsigned char * Atributos_Expedidor)
1886          {
1887            unsigned char Par_Impar;
1888            unsigned char dato;
1889            
1890            if( Festivos() == False)
1891            {
1892            dato=lee_clk(RDIA);
1893          
1894              if((dato % 2 == False) && (*(Atributos_Expedidor + Pico_Placa)  == True))
1895              {
1896              
1897              /*es par*/
1898          /*
1899              Par_Impar = True;
1900              
1901              }
1902              else
1903              {
1904              /*es impar */
1905              /*
1906              Par_Impar = False;
1907              }
1908            }
1909            else
1910            {
1911              Par_Impar = True;
1912            }
1913            return Par_Impar;
1914          }
1915          */
1916          unsigned char Horarios(unsigned char * Atributos_Expedidor)
1917          {
1918   1        unsigned char Estado_Horario;
1919   1        
1920   1        unsigned char Addr_horarios [11];
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 33  

1921   1        unsigned char dia_semana,EE_dia_semana;
1922   1        unsigned int addr;
1923   1        if (*(Atributos_Expedidor + Horario) != False )
1924   1        {
1925   2          /*se Lee la direccion del horario*/
1926   2          strcpy (Addr_horarios,(Addr_Horarios()));
1927   2          
1928   2          addr= Addr_horarios[(*(Atributos_Expedidor + Horario)) -1] ;
1929   2          
1930   2           /*leemos si esta habilitado*/
1931   2          
1932   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
1933   2          {
1934   3            /*miramos si el dia de la semana esta habilitado*/
1935   3            dia_semana = lee_clk(RDIA_SEMANA);
1936   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
1937   3            Debug_chr_Tibbo(dia_semana);
1938   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
1939   3            
1940   3          
1941   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
1942   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
1943   3            Debug_chr_Tibbo(EE_dia_semana);
1944   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
1945   3          
1946   3            if ( EE_dia_semana == dia_semana)
1947   3            {
1948   4              /*miramos si esta en el rango del horario*/
1949   4              Estado_Horario = Bloque_Horario(addr);
1950   4            }
1951   3            else
1952   3            {
1953   4      
1954   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
1955   4              Estado_Horario= False;
1956   4            }
1957   3          }
1958   2          else 
1959   2          {
1960   3            
1961   3            Estado_Horario= False;
1962   3            PantallaLCD(HORARIO_NO_PROG);
1963   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
1964   3            
1965   3          }
1966   2          
1967   2        }
1968   1        else
1969   1        {
1970   2          Estado_Horario = True;
1971   2        
1972   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
1973   2        }
1974   1        return Estado_Horario;
1975   1      }
1976          unsigned int Hora_Maxima(unsigned int addr)
1977          {
1978   1        unsigned char Hora_High,  Minuto_High;
1979   1        unsigned char HoraIni , MinutoIni; 
1980   1        unsigned int  Hora_Prog;
1981   1        
1982   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 34  

1983   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
1984   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
1985   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
1986   1         Debug_chr_Tibbo(HoraIni);
1987   1         Debug_chr_Tibbo(MinutoIni);
1988   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
1989   1        
1990   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
1991   1      }
1992          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
1993          {
1994   1        unsigned char Estado_Horario; 
1995   1        
1996   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
1997   1        {
1998   2          
1999   2          /*hasta la hora que puede ingresar el vehiculo */
2000   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
2001   2          Hora_Prog = Hora_Maxima(addr+4);
2002   2      
2003   2        
2004   2          if( HoraNow <= Hora_Prog)
2005   2          {
2006   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2007   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
2008   3            Estado_Horario = True;
2009   3          }
2010   2          else
2011   2          {
2012   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2013   3            //PantallaLCD(MENSUAL_FUERA_HORARIO);
2014   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
2015   3            Estado_Horario = False;
2016   3          }
2017   2          
2018   2        }
2019   1        else
2020   1        {
2021   2              //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2022   2              //PantallaLCD(MENSUAL_FUERA_HORARIO);
2023   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
2024   2              Estado_Horario = False;
2025   2            
2026   2        }
2027   1        return Estado_Horario;
2028   1      }
2029          
2030          unsigned Bloque_Horario(unsigned int addr)
2031          {
2032   1        unsigned char Estado_Horario; 
2033   1        unsigned int HoraNow, Hora_Prog;
2034   1        
2035   1        /*la hora del momento de entrada del vehiculo*/
2036   1        
2037   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
2038   1        Debug_chr_Tibbo(lee_clk(RHORA));
2039   1        Debug_chr_Tibbo(lee_clk(RMIN));
2040   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
2041   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
2042   1        
2043   1        /* desde la hora en que puede ingresar vehiculo */
2044   1        
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 35  

2045   1        
2046   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
2047   1        Hora_Prog = Hora_Maxima(addr);
2048   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
2049   1        if(Estado_Horario == False )
2050   1        {
2051   2          
2052   2            
2053   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
2054   2            {
2055   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
2056   3              Hora_Prog = Hora_Maxima(addr+10);
2057   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
2058   3            }
2059   2            else
2060   2            {
2061   3              send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2062   3              PantallaLCD(MENSUAL_FUERA_HORARIO);
2063   3              Estado_Horario = False;
2064   3            }
2065   2        }
2066   1      
2067   1      return Estado_Horario;
2068   1      }
2069          /*------------------------------------------------------------------------------
2070          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
2071          
2072          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
2073          ------------------------------------------------------------------------------*/
2074          
2075          
2076          unsigned char  Secuencia_inicio_expedidor(void)
2077          {
2078   1        char temp;
2079   1        switch (Estado)
2080   1        {
2081   2          case INICIA_LINTECH:
2082   2      
2083   2                
2084   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
2085   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
2086   2              
2087   2            
2088   2            return (Estado);
2089   2          break;
2090   2      
2091   2      
2092   2      /*------------------------------------------------------------------------------
2093   2      Envia la primera trama de inicializacion del transporte sin movimiento
2094   2            (0) LA RESPUESTA ES OK
2095   2            (1) NO RESPONDE EL PTO SERIE
2096   2            (2) NO RECIBIDO LA TRAMA 
2097   2            (3) ERROR DE TRAMA CMD (N)
2098   2      ------------------------------------------------------------------------------*/
2099   2            
2100   2          case SEQ_CAPTURE_DATOS_INI:
2101   2      
2102   2            if((temp=Trama_Validacion_P_N())!=0)
2103   2          {
2104   3            if(temp==2)
2105   3            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 36  

2106   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
2107   4            } 
2108   3            else if (temp==3)
2109   3            {
2110   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
2111   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2112   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2113   4            }
2114   3            else
2115   3            {
2116   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2117   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
2118   4            }
2119   3          }
2120   2          else
2121   2          {
2122   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
2123   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2124   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
2125   3          }     
2126   2          return (Estado);
2127   2          break;
2128   2            
2129   2      /*------------------------------------------------------------------------------
2130   2      Envia el cmd de grabar claves a la eeprom del transporte 
2131   2      ------------------------------------------------------------------------------*/
2132   2            
2133   2            case GRABA_EEPROM:
2134   2              
2135   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
2136   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
2137   2            
2138   2            
2139   2      
2140   2            return (Estado);
2141   2              break;
2142   2        
2143   2      /*------------------------------------------------------------------------------
2144   2      se analiza la respuesta 
2145   2            (0) LA RESPUESTA ES OK
2146   2            (1) NO RESPONDE EL PTO SERIE
2147   2            (2) NO RECIBIDO LA TRAMA 
2148   2            (3) ERROR DE TRAMA CMD (N)
2149   2      ------------------------------------------------------------------------------*/
2150   2            
2151   2          case SEQ_CAPTURA_OK_EEPROM:
2152   2          
2153   2          if((temp=Trama_Validacion_P_N())!=0)
2154   2          {
2155   3            if(temp==2)
2156   3            {
2157   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
2158   4            }
2159   3            else if (temp==3)
2160   3            {
2161   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
2162   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2163   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2164   4            }     
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 37  

2165   3            else
2166   3            {
2167   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2168   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
2169   4            }       
2170   3          }
2171   2          else
2172   2          {
2173   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
2174   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2175   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
2176   3          }     
2177   2      
2178   2          return (Estado);
2179   2          break;
2180   2      
2181   2      /*------------------------------------------------------------------------------
2182   2      Fin de la secuencia de comandos con exito 
2183   2      ------------------------------------------------------------------------------*/    
2184   2            
2185   2              case FIN_OK:
2186   2      
2187   2              return (Estado);
2188   2          break;
2189   2            
2190   2                
2191   2              default:
2192   2              return Estado=INICIA_LINTECH; 
2193   2              break;
2194   2        }
2195   1      }
2196          
2197          /*------------------------------------------------------------------------------
2198          Prosedimiento  q hace paso a paso la secuencia de la MF
2199          atributos
2200          ValTimeOutCom = tiempo que  espera para recibir datos pto serie
2201          Tarjeta_on = detecto vehiculo en loop y tiene tarjeta en boca
2202          g_cEstadoComSeqMF = nos dice en el estado que nos encontramos dentro del seguimiento
2203          ------------------------------------------------------------------------------*/
2204          
2205          unsigned char SecuenciaExpedidorMF(unsigned char EstadoActivo)
2206          {
2207   1        static unsigned char Buffer_Write_MF[17];
2208   1        static unsigned char Atributos_Expedidor[15];
2209   1        static unsigned char Secuencia_Expedidor[4];
2210   1        static unsigned char Nombre_Mensual[17];
2211   1        
2212   1        switch (EstadoActivo)
2213   1        {
2214   2      //***********************************************************************************************
2215   2          
2216   2          case SEQ_INICIO:
2217   2      
2218   2            if ((ValTimeOutCom==True)|| (ValTimeOutCom > TIME_CARD))
2219   2            {
2220   3              lock=OFF;                                                                                   /*rele de disparo a la barrera*/
2221   3              Rele_Atasco=OFF;                                                                           /*activo el rele de reset del verificador logica
             - negativa*/    
2222   3              Check_Status(SENSOR_NORMAL);                                                              /* se pregunta al transporte en q estado es
             -tan las TI*/
2223   3              EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_
             -TRANSPORTE);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 38  

2224   3              Secuencia_Expedidor [ TareadelCmd  ] = TAREA_PRESENCIA_VEHICULAR;
2225   3            
2226   3            }
2227   2       
2228   2          break;
2229   2          
2230   2          case  SEQ_CMD_ACEPTADO:
2231   2          /*cmd comun para todos*/
2232   2            EstadoActivo=rta_cmd_transporte(Secuencia_Expedidor);
2233   2            
2234   2          break;
2235   2      
2236   2      /*------------------------------------------------------------------------------
2237   2          Tareas especificas de cada paso
2238   2      ------------------------------------------------------------------------------*/      
2239   2          
2240   2            
2241   2          case SEQ_RESPUESTA_TRANSPORTE:
2242   2              ValTimeOutCom=TIME_WAIT;
2243   2            if (Secuencia_Expedidor [TareadelCmd]==TAREA_PRESENCIA_VEHICULAR)
2244   2            {
2245   3            EstadoActivo=Responde_Estado_Sensores_Transporte(); 
2246   3            
2247   3            }
2248   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_TIPO_TARJETA)
2249   2                {
2250   3                  
2251   3                  EstadoActivo=Responde_Tipo_Tarjeta();
2252   3                }
2253   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_LECTURA_TARJETA_SECTOR_BLOQUE)
2254   2                {
2255   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2256   3                  {
2257   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque1 (Atributos_Expedidor);
2258   4                  }
2259   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2260   3                  {
2261   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque0 (Nombre_Mensual);
2262   4                  }
2263   3                  else
2264   3                  {
2265   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque2(Atributos_Expedidor);
2266   4                  }
2267   3                }
2268   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_WRITE_TARJETA_SECTOR_BLOQUE)
2269   2                { 
2270   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_2))
2271   3                  { 
2272   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor,Buffer_Write_MF);
2273   4                  }
2274   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_2)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2275   3                  {
2276   4                    EstadoActivo=Responde_Write_Tarjeta_Sector2_Bloque0(Buffer_Write_MF);
2277   4                  }
2278   3                  else
2279   3                  {
2280   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque0 (Buffer_Write_MF);
2281   4                  }
2282   3                }
2283   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_OPEN_BARRERA)
2284   2                {   
2285   3                  EstadoActivo = Disparo_Lock_Entrada_Vehiculo(Nombre_Mensual);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 39  

2286   3                }
2287   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_WRITE_PLACA_CARD)
2288   2                {   
2289   3                  EstadoActivo = Respuesta_Segunda_clave(Atributos_Expedidor,Buffer_Write_MF);
2290   3                }
2291   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_TIPO_MENSUAL) 
2292   2                {
2293   3                  EstadoActivo = Analiza_Presencia_Mensual();
2294   3                }
2295   2                
2296   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_UID ) 
2297   2                {
2298   3                  EstadoActivo = Analiza_Uid_Card(Atributos_Expedidor);
2299   3                }   
2300   2            else
2301   2                {
2302   3                  Debug_txt_Tibbo((unsigned char *) "TAREA_3\r\n");
2303   3                }
2304   2            break;
2305   2          case SEQ_MOVER_CARD_RF:
2306   2            Mov_Card(MovPos_RF);
2307   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_TIPO_CARD);
2308   2            break;
2309   2          case SEQ_CARD_INSERCION_ON:
2310   2            Card_Insercion(Habilita); 
2311   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2312   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_MENSUAL;
2313   2          break;
2314   2          case SEQ_TIPO_CARD:
2315   2            Aut_Card_check_Status();
2316   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2317   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_TARJETA;
2318   2          break;
2319   2          case SEQ_LOAD_PASSWORD:
2320   2            LoadVerify_EEprom();
2321   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECTOR
             -_BLOQUE);
2322   2            Atributos_Expedidor [ Sector ]    = Sector_1;
2323   2            Atributos_Expedidor [ Bloque ]    = Bloque_1;
2324   2            break;
2325   2          case SEQ_READ_SECTOR_BLOQUE:
2326   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
2327   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2328   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
2329   2          break;
2330   2          case SEQ_WRITE_SECTOR_BLOQUE:
2331   2            WR_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ],Buffer_Write_MF);
2332   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2333   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_WRITE_TARJETA_SECTOR_BLOQUE;
2334   2          break;
2335   2          case SEQ_CAPTURE_CARD:
2336   2            Mov_Card(MovPos_Capture);
2337   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);     
             -//SEQ_INICIOSEQ_MOVER_CARD_RF
2338   2            break;
2339   2          case SEQ_CARD_INSERCION_OFF:
2340   2            Card_Insercion(Inhabilita);
2341   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_EXPULSAR_CA
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 40  

             -RD);
2342   2          break;
2343   2          case SEQ_EXPULSAR_CARD:
2344   2            Mov_Card(MovPos_EjectFront);
2345   2            MenSual = False;
2346   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);    
2347   2            
2348   2          break;
2349   2          case SEQ_FRONT_CARD:
2350   2            Mov_Card(MovPos_Front);
2351   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_DETAIL_CAR
             -D);    
2352   2            
2353   2          break;
2354   2          case SEQ_DETAIL_CARD:
2355   2            Check_Status(SENSOR_DETAIL);
2356   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);    
2357   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_OPEN_BARRERA;
2358   2            break;
2359   2          case SEQ_LOAD_EEPROM:
2360   2            Dwload_EEprom();
2361   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECT
             -OR_BLOQUE);  
2362   2          break;
2363   2          case SEQ_ESPERA_VEHICULO_ENTRE:
2364   2            MenSual = False;
2365   2            EstadoActivo = Entrega_Card_Captura();
2366   2            break;
2367   2          case SEQ_PTO_PARALELO:
2368   2            EstadoActivo = Send_Pto_Paralelo(Atributos_Expedidor);
2369   2            
2370   2            break;
2371   2          case SEQ_WAIT_PLACA:
2372   2            EstadoActivo = Wait_Placa(Secuencia_Expedidor,EstadoActivo);
2373   2          break;
2374   2          case SEQ_UID: 
2375   2            Unique_Identifier_UID();
2376   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);    
2377   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_UID ;
2378   2          break;
2379   2          case SEQ_LPR:
2380   2            EstadoActivo = Pregunta_Lpr(Atributos_Expedidor);
2381   2            break;
2382   2          case SEQ_TIPO_TARJETAS:
2383   2            EstadoActivo = Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);;
2384   2            break;
2385   2          case SEQ_CAPTURE_CARD_LOOP:
2386   2            Mov_Card(MovPos_Capture);
2387   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);  
             -   //SEQ_INICIOSEQ_MOVER_CARD_RF
2388   2            EstadoActivo = Analiza_Presencia_rotacion();
2389   2            break;
2390   2          case SEQ_POWER_OFF:
2391   2            Power_off();
2392   2              EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_UID);
2393   2            break;
2394   2          case SEQ_POWER_ON:
2395   2            Power_off();
2396   2              EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_LOAD_PAS
             -SWORD);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       10/01/2020 09:24:09 PAGE 41  

2397   2            break;
2398   2          default:
2399   2          EstadoActivo = SEQ_INICIO;  
2400   2          break;  
2401   2            
2402   2        } 
2403   1        return EstadoActivo;
2404   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7482    ----
   CONSTANT SIZE    =   1836    ----
   XDATA SIZE       =    138     237
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
