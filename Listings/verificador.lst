C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          
  12          
  13          extern void send_portERR(unsigned char cod_err);
  14          
  15          
  16          
  17          
  18          extern void PantallaLCD(unsigned char cod_msg);
  19          extern void PantallaLCD_LINEA_2(unsigned char cod_msg, unsigned char *buffer);
  20          
  21          //extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          
  23          
  24          /*funciones prototipo de clock*/
  25          
  26          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  27          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  28          void Block_read_clock_ascii(unsigned char *datos_clock);
  29          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  30          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l);
  31          extern char check_fechaOut(char *buffer);
  32          extern char lee_clk (unsigned char dir_clk);
  33          extern unsigned char bcd_hex (unsigned char l_data);
  34          extern void hex_ascii(unsigned char * datos,unsigned char * fecha_asii);
  35          
  36          extern void Cmd_Lpr_Int();
  37          extern void Delay_10ms(unsigned int cnt);
  38          
  39          /*funciones prototipo string */
  40          
  41          extern char  *strcat  (char *s1, const char *s2);
  42          extern char  *strcpy  (char *s1, const char *s2);
  43          extern unsigned int strlen  (const char *);
  44          extern char   strcmp  (const char *s1, const char *s2);
  45          
  46          /*funciones prototipo de EEprom*/
  47          
  48          extern unsigned char *Lee_No_Ticket();
  49          void Incremente_Ticket();
  50          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  51          
  52          /*funciones prototipo del transporte MODULO io_sensores*/
  53          
  54          extern unsigned char  ValidaSensoresPaso(void);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 2   

  55          unsigned char Valida_Sensor1_Auto();
  56          extern unsigned char Dir_board();
  57          extern void sel_Pulsa(void);
  58          void sel_Sensor2(void);
  59          char ValidaSensor(void);
  60          unsigned char Dir_Board_Monitor();
  61          
  62          /*funciones prototipo del transporte MODULO TIBBO*/
  63          
  64          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  65          extern void Debug_txt_Tibbo(unsigned char * str);
  66          extern void Debug_chr_Tibbo(unsigned char Dat);
  67          extern void Debug_HexDec(unsigned char xfc);
  68          
  69          /*funciones prototipo del transporte MODULO LINTECH*/
  70          
  71          extern void Aut_Card_check_Status(void);
  72          extern void Check_Status(unsigned char Detalle);
  73          extern void Dwload_EEprom (void);
  74          extern void Mov_Card(unsigned char Posicion);
  75          extern void Card_Insercion(char Tipo);
  76          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  77          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);  
  78          extern void LoadVerify_EEprom(void);
  79          extern void Clave_Seguridad_S2(void);
  80          extern void Unique_Identifier_UID(void);
  81          extern void Power_off(void);
  82          
  83          /*funcion prototipo monitor*/
  84          
  85          extern void clear_placa();
  86          extern void Rx_Monitor();
  87          
  88          /*funcion prototipo pto paralelo*/
  89          
  90          void  send_port(unsigned char *buffer_port, unsigned char length_char);
  91          
  92          /*funcion prototipo programacion*/
  93          extern unsigned char *Addr_Horarios();
  94          
  95          extern int    atoi (const char *s1);
  96          /*io sensores */
  97          
  98          sbit DataIn = P1^1;         //  dato de las entradas    
  99          sbit sel_A = P3^5;          //Pulsador                        *
 100          sbit sel_B = P3^6;          //Entrada Sensor 2                    *
 101          sbit sel_C = P3^7;          //Entrada Sensor 1                    *
 102          
 103          sbit lock = P1^7;           //Relevo  
 104          sbit Rele_Atasco = P0^3;        //Rele de on/off del verificador o transporte
 105          sbit led_err_imp = P0^2;      //Error   
 106          
 107          /*pines de ip tibbo*/
 108          
 109          sbit rx_ip = P0^0;    
 110          /*variables externas*/
 111          
 112          extern unsigned char g_cEstadoComSoft;
 113          extern unsigned char ValTimeOutCom;
 114          extern unsigned char g_cContByteRx;
 115          extern unsigned char xdata Buffer_Rta_Lintech[];
 116          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 3   

 117          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
 118          extern unsigned char Timer_wait;
 119          extern unsigned int  SIN_COBRO;
 120          extern unsigned char  Tarjeta_on;
 121          extern unsigned char cnt__ask_off;
 122          extern  unsigned char Tipo_Vehiculo;
 123          extern  unsigned char  Debug_Tibbo;                                                   /*variable q define expedicion de tarjetas 1=
             - automatico 0= a boton configurable en eeprom*/
 124          extern idata unsigned char placa[];
 125          
 126          /*externo bit*/
 127          
 128          extern bit aSk;
 129          extern bit buffer_ready;
 130          extern bit placa_ready;
 131          
 132          /*----------------------------------------------------------------------------
 133          Definiciones de sequencias de verificador y expedidor
 134          ------------------------------------------------------------------------------*/
 135          
 136          #define SEQ_INICIO                      0X00  
 137          #define SEQ_RESPUESTA_TRANSPORTE        0X01
 138          #define SEQ_CMD_ACEPTADO                0x02
 139          #define SEQ_MOVER_CARD_RF               0x03
 140          #define SEQ_CARD_INSERCION_ON           0x04
 141          #define SEQ_TIPO_CARD                   0X05
 142          #define SEQ_LOAD_PASSWORD               0X06
 143          #define SEQ_READ_SECTOR_BLOQUE          0X07
 144          #define SEQ_WRITE_SECTOR_BLOQUE         0X08
 145          #define SEQ_CAPTURE_CARD                0X09
 146          #define SEQ_CARD_INSERCION_OFF          0x0a
 147          #define SEQ_EXPULSAR_CARD               0x0b
 148          #define SEQ_LOAD_EEPROM                 0x0c
 149          #define SEQ_FRONT_CARD                  0x0d
 150          #define SEQ_ESPERA_VEHICULO_ENTRE       0x0e
 151          #define SEQ_DETAIL_CARD                 0x0f
 152          #define SEQ_PTO_PARALELO                0x10
 153          #define SEQ_WAIT_PLACA                  0x11
 154          #define SEQ_UID                         0X12
 155          #define SEQ_LPR                         0X13  
 156          #define SEQ_TIPO_TARJETAS               0X14
 157          #define SEQ_CAPTURE_CARD_LOOP           0X15
 158          #define SEQ_POWER_OFF                   0X16
 159          #define SEQ_POWER_ON                    0X17
 160          #define SEQ_SECOND_PASSWORD             0X18
 161          
 162          /*----------------------------------------------------------------------------
 163          Definiciones de sequencias de tareas del verificador y expedidor
 164          ------------------------------------------------------------------------------*/
 165          #define TAREA_PRESENCIA_VEHICULAR             0X00  
 166          #define TAREA_TIPO_TARJETA                    0X01
 167          #define TAREA_LECTURA_TARJETA_SECTOR_BLOQUE   0x02
 168          #define TAREA_WRITE_TARJETA_SECTOR_BLOQUE     0X03
 169          #define TAREA_OPEN_BARRERA                    0X04
 170          #define TAREA_WRITE_PLACA_CARD                0x05
 171          #define TAREA_TIPO_MENSUAL                    0x06
 172          #define TAREA_UID                             0X07
 173          #define TAREA_PRESENCIA_ROTACION              0X08
 174          /*----------------------------------------------------------------------------
 175           definiciones de lintech en la inicializacion de expedidor o verificador
 176          ------------------------------------------------------------------------------*/
 177          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 4   

 178          #define INICIA_LINTECH          0x30
 179          #define SEQ_CAPTURE_DATOS_INI   0x31
 180          #define GRABA_EEPROM            0x32
 181          #define SEQ_CAPTURA_OK_EEPROM   0X33
 182          #define FIN_OK                  0x00
 183          
 184          
 185          #define True                    0x01
 186          #define False                   0x00
 187          /*----------------------------------------------------------------------------
 188           Definicion de datos asociados al buffer de resetcion del dato del trnasporte 
 189          
 190          ------------------------------------------------------------------------------*/
 191          
 192          
 193          #define ON    1
 194          #define OFF   0
 195          /*----------------------------------------------------------------------------
 196           ERRORES pto serie 
 197          
 198          ------------------------------------------------------------------------------*/
 199          #define REENVIA_TRAMA     0
 200          #define ESPERA_MAS_TIEMPO 1
 201          /*----------------------------------------------------------------------------
 202           definiciones de lintech en la inicializacion de expedidor o verificador
 203           funcion usada en lintech que me debuelve la respuesta de comunicacion del expedidor
 204           o verificador Trama_Validacion_P_N()
 205          RSPT_TRP_OK             (0) respuesta_transporte_oksignifica que la trama es valida y continua en el proceso
 206          NO_RSPD_TRP_PTO_COM     (1) no_responde_trasnporte_pto_com se cumple el tiempo de espera
 207          ESPR_RSPT_TRP_TRAMA     (2)Espera_respuesta_transporte_trama
 208          ERROR_TRP_TRAMA         (3) error_transpote_trama
 209          ------------------------------------------------------------------------------*/
 210          #define   RSPT_TRP_OK           0
 211          #define   NO_RSPD_TRP_PTO_COM   1
 212          #define   ESPR_RSPT_TRP_TRAMA   2
 213          #define   ERROR_TRP_TRAMA       3
 214          
 215          
 216          /*----------------------------------------------------------------------------
 217           definiciones de lintech en el comando Check_Status
 218          ------------------------------------------------------------------------------*/
 219          
 220          #define SENSOR_DETAIL       0x31
 221          #define SENSOR_NORMAL       0x30
 222          
 223          /*------------------------------------------------------------------------------
 224           definiciones de lintech en el comando Card_Insercion
 225          ------------------------------------------------------------------------------*/
 226          
 227          #define Habilita        0x30
 228          #define Inhabilita      0x31
 229          
 230          /*------------------------------------------------------------------------------
 231          Definicion de Lintech en el comando Inicializa
 232          ------------------------------------------------------------------------------*/
 233          
 234          #define TO_FRONT        '0'
 235          #define CAPTURE_BOX     '1'
 236          #define SIN_MOVIMIENTO  '3'
 237          
 238          /*------------------------------------------------------------------------------
 239          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 5   

 240          MovPos_Front        '0'   -> mueve  tarjeta al frente pero no la suelta
 241          MovPos_IC           '1'   ->mueve la tarjeta en posicion de read/write IC
 242          MovPos_RF           '2'   ->mueve tarjeta a RF card read/write
 243          MovPos_Capture      '3'   ->captura la tarjeta
 244          MovPos_EjectFront   '9'   ->lanza la tarjeta del mecanismo
 245          
 246          ------------------------------------------------------------------------------*/
 247          
 248          #define   MovPos_Front        '0'   
 249          #define   MovPos_IC           '1'
 250          #define   MovPos_RF           '2'
 251          #define   MovPos_Capture      '3'
 252          #define   MovPos_EjectFront   '9'
 253          
 254          /*------------------------------------------------------------------------------
 255          Definicion de la trama Lintech de las respuestas de los cmd
 256          ------------------------------------------------------------------------------*/
 257          
 258          #define Pos_Length          3
 259          #define Pos_TipoResp        4
 260          #define Pos_St0             7
 261          #define Pos_St1             8
 262          #define Pos_St2             9
 263          #define Pos_IniDatMF        0x0a
 264          #define Card_type_H         0x0a
 265          #define Card_type_L         0x0b
 266          #define Rtype               0x0A
 267          /*------------------------------------------------------------------------------
 268          Definicion del estado de st0,st1,st2 de la trama Lintech 
 269          NO_CARDS_IN_MCNSM -> No tiene tarjetas en el mecanismo      sto=0
 270          CARD_IN_MOUTH     -> hay una tarjeta dentro del bessel      st0=1
 271          CARD_OK_READ_RF   -> Tarjeta en posicion para leer/escribir dentro del mecanismo st0=2
 272          NO_HAVE_CARDS     -> no tiene tarjetas en el deposito st1=0
 273          LOW_NIVEL_CARDS   -> nivel bajo de tarjetas en el deposito  st1=1
 274          FULL_CARD         -> Deposito de tarjetas esta lleno        st1=2
 275          ------------------------------------------------------------------------------*/
 276          
 277          
 278          #define NO_CARDS_IN_MCNSM   '0'
 279          #define CARD_IN_MOUTH       '1'
 280          #define CARD_OK_READ_RF     '2'
 281          #define NO_HAVE_CARDS       '0'
 282          #define LOW_NIVEL_CARDS     '1'
 283          #define FULL_CARD           '2'
 284          /*----------------------------------------------------------------------------
 285          Comprobacion automatica del tipo de tarjeta 
 286          checking RF card type
 287          Card_type_H   Card_type_L  explicacion
 288              0             0           tarjeta desconocida
 289              1             0           MF50
 290              1             1           MF70
 291              1             2           MF_UL
 292              2             0           TYPE_A_CPU
 293          ------------------------------------------------------------------------------*/
 294          #define MF50_HIGH             '1'
 295          #define MF50_LOW              '0'
 296          #define MF70                  '1'
 297          #define OPERATE_FAIL          0X6F
 298          
 299          /*----------------------------------------------------------------------------
 300          definicion de recepcion serial 
 301          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 6   

 302          
 303          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 304          
 305          /*----------------------------------------------------------------------------
 306          tiempo de delay entre funciones
 307          ------------------------------------------------------------------------------*/
 308          
 309          #define   TIME_CARD         100   //50
 310          #define   TIME_WAIT         18
 311          /*----------------------------------------------------------------------------
 312          definicion de datos de trama lintech
 313          ------------------------------------------------------------------------------*/
 314          
 315          //#define   ETX               03
 316          #define   STX_LINTECH       0xf2
 317          
 318          /*----------------------------------------------------------------------------
 319          msj de lcd tarjeta y lcd serie
 320          ------------------------------------------------------------------------------*/
 321          /*Los cmd PRMR son enviados por el primario*/
 322          #define PRMR_ERROR_LOOP         0XE0
 323          #define ERROR_LOOP              170
 324          #define PRMR_ERROR_COD_PARK     0XE5
 325          #define ERROR_COD_PARK          171
 326          #define PRMR_TARJETA_INVALIDA   0XE1
 327          #define PULSE_BOTON             172
 328          #define PRMR_TARJETA_SIN_FORMATO  0xDF
 329          #define TARJETA_SIN_FORMATO       173
 330          
 331          #define PRMR_NO_CARD_MENSUAL          0XFC
 332          #define NO_CARD_MENSUAL         176
 333          #define TARJETA_INVALIDA        177
 334          
 335          #define PRMR_NO_ROTACION              0XFD
 336          
 337          #define PRMR_SIN_SALIDA             0XE9
 338          #define SIN_SALIDA              178
 339          #define REGISTRA_INGRESO        179
 340          
 341          #define PRMR_TARJETA_VENCIDA          0XEC
 342          #define TARJETA_VENCIDA         180
 343          #define PRMR_ERROR_TIPO_VEHICULO      0XF8
 344          #define PRMR_MENSUAL_FUERA_HORARIO    0Xb5
 345          #define MENSUAL_FUERA_HORARIO   181
 346          #define ERROR_MF1               0XE2
 347          #define HORARIO_NO_PROG         182
 348          
 349          
 350          
 351          #define BIENVENIDO              0XFE
 352          #define NO_CARD                 0xFA  
 353          
 354          #define RETIRE_TARJETA          0XA1
 355          
 356          #define LOW_CARD                0x01
 357          
 358          #define AUDIO_ENTRADA     0XA0
 359          #define AUDIO_CAJA        0XA1
 360          #define AUDIO_GRACIAS     0XA2
 361          /*----------------------------------------------------------------------------
 362          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 363          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 7   

 364          
 365          #define   ENVIADOS          0X0
 366          #define   RESPUESTA         0X01
 367          /*
 368          definicion  de daos del reloj
 369                    */
 370          
 371          #define RDIA            0x87
 372          #define RMES            0x89
 373          #define RANO            0x8D
 374          #define RDIA_SEMANA     0x8B
 375          #define RHORA           0x85
 376          #define RMIN            0x83
 377          #define Sabado          7
 378          #define Domingo         1
 379          /*----------------------------------------------------------------------------
 380          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 381          (0) si el dato es cero esta inactiva
 382          (1) activa o ROTACION
 383          (2) mensualidad
 384          ------------------------------------------------------------------------------*/
 385          enum Tipos_MF_TIPO_TARJETA{
 386            INACTIVA,         
 387            ROTACION,           
 388            MENSUALIDAD,
 389            PREPAGO,
 390            CORTESIA,
 391            LOCATARIO,
 392            TARJETA_PERDIDA = 0X10,
 393            INHABILITADA = 0X11
 394          };
 395          /*----------------------------------------------------------------------------
 396          posicion de  MF  bloque 1 sector 1
 397          (0) tipo de tarjeta 
 398          (01) el id del cliente
 399          (03)codigo del parqueadero  
 400          ------------------------------------------------------------------------------*/
 401          #define   MF_TIPO_TARJETA   0X00
 402          #define   MF_COD_PARK       0x01      //MF_ID_CLIENTE
 403          #define   MF_ID_CLIENTE     0x03      //MF_COD_PARK
 404          
 405          /*----------------------------------------------------------------------------
 406          posicion de  MF bloque 2 sector 1
 407          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 408          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 409          ------------------------------------------------------------------------------*/
 410          
 411          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 412          
 413          
 414          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 415                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
 416          #define   MF_LSB            0x06
 417          
 418          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 419          
 420          #define   MF_IN_PAGO        0x09
 421          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 422          
 423          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 8   

 424          
 425          #define   MF_MENSUAL_ANO      0X05
 426          #define   MF_MENSUAL_MES      0X06
 427          #define   MF_MENSUAL_DIA      0X07
 428          
 429          #define   MF_UID_0      0X04
 430          #define   MF_UID_1      0X05
 431          #define   MF_UID_2      0X06
 432          #define   MF_UID_3      0X07
 433          
 434          #define   MF_EXPIRA_ANO     0X08
 435          #define   MF_EXPIRA_MES     0X09
 436          #define   MF_EXPIRA_DIA     0X0A
 437          
 438          #define   HABILITA_ADDR     15
 439          #define   Segundo_Tiempo    16
 440          
 441          enum Hora_Minutos_addr{
 442            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 443            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 444          };
 445          
 446          enum Estados_Expedidor{
 447           EstadoActual,
 448           EstadoPasado,
 449           EstadoFuturo,
 450           TareadelCmd  
 451          };
 452          enum expedidor {
 453           Sector,        
 454           Bloque,        
 455           Tipo_Tarjeta,
 456           Apb,
 457           Horario,
 458           Pico_Placa,
 459           Type_Vehiculo,
 460           Uid_0,
 461           Uid_1,
 462           Uid_2,
 463           Uid_3,
 464           Expira_ano,
 465           Expira_mes,
 466           Expira_dia
 467           
 468          };
 469          /*tipos de APB antipassback*/
 470          enum Tipos_MF_APB{
 471            
 472            APB_INICIADO,       
 473            APB_INT,              
 474            APB_OUT,              
 475            APB_NO              
 476          };
 477          /*tipo de vehiculo*/
 478          /*Sectores y bloques de Mf*/
 479          enum MF_Sector_Bloque{
 480            Sector_0,
 481            Sector_1,
 482            Sector_2,
 483            Bloque_0 = 0,
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 9   

 484            Bloque_1 = 1,
 485            Bloque_2 = 2
 486          };
 487          /*comandos pto paralelo*/
 488          enum CMD_Trama_Pto_Paralelo{
 489            STX=02,
 490            CMD_PTO_PARALELO_EXPEDIDOR='a',
 491            ETX= 03,
 492            NULL=0,
 493            CMD_MONITOR_EXPEDIDOR='E',
 494            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 495          };
 496          enum EE_AntiPassBack{
 497            APB_INHABILITADO_SOFT,
 498            APB_HABILITADO_SOFT
 499          };  
 500          enum Tipos_Vehiculos{
 501              AUTOMOVIL,          
 502              MOTO,
 503              BICICLETA
 504          };  
 505          
 506          /*DATOS DE CONFIGURACION EEPROM*/
 507          #define EE_ID_CLIENTE           0x0000
 508          #define EE_ID_PARK              0x0002
 509          #define EE_DEBUG                0x0008
 510          #define EE_USE_LPR              0x000A
 511          #define EE_CARD_AUTOMATIC_BOTON 0x000f
 512          #define EE_HABILITA_APB         0x0010
 513          #define EE_PLACA                0X0011
 514          #define EE_VALIDA_TIPO_VEHICULO_MENSUAL 0X0014
 515          #define EE_HABILITA_APB_MENSUAL 0X0015
 516          
 517          /*----------------------------------------------------------------------------
 518          Definicion de varaibles globales del objeto
 519          ------------------------------------------------------------------------------*/
 520          
 521          static unsigned char Estado=INICIA_LINTECH;
 522          bit MenSual = False;
 523          /*------------------------------------------------------------------------------
 524          
 525          ------------------------------------------------------------------------------*/
 526          unsigned char Captura_Expulsa()
 527          {
 528   1        unsigned char Estado_expedidor;
 529   1        
 530   1        
 531   1        if(MenSual !=  True)
 532   1        {
 533   2          Estado_expedidor=SEQ_CAPTURE_CARD_LOOP; //SEQ_CAPTURE_CARD;                                       
 534   2        }
 535   1        else
 536   1        {
 537   2        
 538   2        Estado_expedidor = SEQ_EXPULSAR_CARD;//SEQ_CARD_INSERCION_OFF;  
 539   2        } 
 540   1      
 541   1      
 542   1      return  Estado_expedidor;
 543   1      }
 544          /*------------------------------------------------------------------------------
 545          funcion que valida la trama del verificador o transporte lintech
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 10  

 546          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 547          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 548          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 549          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 550          
 551          
 552          ------------------------------------------------------------------------------*/
 553          
 554          char Trama_Validacion_P_N()
 555          {
 556   1        char Trama_Validacion_P_N=ESPR_RSPT_TRP_TRAMA;                                /*espera respuesta del transporte*/
 557   1            
 558   1            if ((ValTimeOutCom==1)||(buffer_ready==1) )
 559   1            {
 560   2              if (buffer_ready==1)
 561   2              {
 562   3                buffer_ready=0;
 563   3                  
 564   3              
 565   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 566   3                {
 567   4                          
 568   4                  Trama_Validacion_P_N=RSPT_TRP_OK;                                       /*trama ok*/
 569   4                    
 570   4                }
 571   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 572   3                {
 573   4                  
 574   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;                                 /*error de trama*/
 575   4                  
 576   4                }
 577   3                else
 578   3                {
 579   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
 580   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;   
 581   4                  
 582   4                }
 583   3              }
 584   2              else
 585   2              {
 586   3                          
 587   3                Trama_Validacion_P_N=NO_RSPD_TRP_PTO_COM;                                 /*pto serie no responde */
 588   3                                                  
 589   3              }
 590   2      
 591   2            }
 592   1            
 593   1        return Trama_Validacion_P_N;
 594   1      }
 595          /*------------------------------------------------------------------------------
 596          funcion de error de respuesta pto serie
 597          
 598          variable en uart. cnt__ask_off=cuenta los numeros de error pto serie y reset de transporte 
 599          se limpia cuando llega la respuesta del transporte. 
 600          Rele_Atasco = es un I/O del Mc que activa / inhabilita el rele
 601          ON    (1) esta activo 
 602          OFF   (0) inhactivo 
 603          REENVIA_TRAMA   1
 604          ESPERA_MAS_TIEMPO 0
 605          cnt_espera_ask_on= cuenta el tiempo de ASK que esta activo,sin que le llegue
 606                             la trama completa, al  5 tiempos borra el ask y retrasmite el cmd
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 11  

 607          
 608          error_rx_pto= (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 609                      = (1)= REENVIA_TRAMA reenvia la trama al transporte
 610          
 611          cnt__ask_off= varible global esta definida en pto serie y es un contador , que 
 612          se limpia cada vez que la trama a llegado completa y validada
 613          
 614          aSk= significa que llego al pto serie el 06 = ask donde el transporte dice que a recibido el cmd
 615          esta ejecutando y nos enviara la respuesta,necesita tiempo esta bit esta definino en el modulo uart es glo
             -bal
 616          
 617          ------------------------------------------------------------------------------*/
 618          unsigned char error_rx_pto(void)
 619          {
 620   1      
 621   1      static unsigned cnt_espera_ask_on=0;
 622   1      unsigned char error_rx_pto=ESPERA_MAS_TIEMPO;
 623   1      
 624   1          
 625   1                
 626   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 627   1            Debug_chr_Tibbo (cnt__ask_off); 
 628   1            Debug_chr_Tibbo (cnt_espera_ask_on);
 629   1            Debug_chr_Tibbo (error_rx_pto);
 630   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 631   1            if (aSk==OFF)
 632   1            
 633   1            { 
 634   2                cnt__ask_off++;                                                                   /*cuento el error*/                                                               
 635   2              if(cnt__ask_off>=10)
 636   2              { 
 637   3                Debug_txt_Tibbo((unsigned char *) "ATASCADO RESET\r\n\r\n");                                                                      /*no c
             -ontesta debe reset el transporte*/
 638   3                Rele_Atasco=ON;                                                                   /*off el rele de reset del verificador*/    
 639   3                Delay_10ms(110);
 640   3                cnt__ask_off=0;                                                                   /*limpio ls errores*/
 641   3                cnt_espera_ask_on=0;
 642   3                error_rx_pto=ESPERA_MAS_TIEMPO;                                                   /**/
 643   3                Rele_Atasco=OFF;  
 644   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 645   3                ValTimeOutCom=TIME_CARD;
 646   3              }
 647   2              else;
 648   2              {
 649   3                error_rx_pto=REENVIA_TRAMA;                                                       /*1 reenvia trama*/
 650   3                ValTimeOutCom=TIME_CARD;
 651   3              }
 652   2            }                                                                                     /*aSk esta activo */
 653   1            else
 654   1            {
 655   2                cnt_espera_ask_on++;                                                              /*cuento n tiempos de ask para recibir el total de
             - la trama*/
 656   2              if(cnt_espera_ask_on>=3)
 657   2              {
 658   3                cnt__ask_off=0;                                                                   /*paso tiempo de espera y no se completo la trama 
 659   3                                                                                                  limpio los reg y reenvio la trama y ask=off*/
 660   3                cnt_espera_ask_on=0;
 661   3                error_rx_pto=REENVIA_TRAMA;
 662   3                aSk=OFF;
 663   3                ValTimeOutCom=TIME_CARD;
 664   3              }
 665   2              else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 12  

 666   2              {
 667   3                cnt__ask_off=0;                                                                   /*damos tiempo de espera de la trama del transporte*
             -/
 668   3                error_rx_pto=ESPERA_MAS_TIEMPO;;
 669   3                ValTimeOutCom=TIME_CARD;
 670   3              }
 671   2            }
 672   1              return (error_rx_pto);
 673   1      }
 674          /*------------------------------------------------------------------------------
 675          Funcion de respuesta a los cmd del transporte
 676          Retorna rta_cmd_transporte el estado en que queda
 677          Recibe tres datos unos es el 
 678          Estado_futuro= significa que la respuesta fue ok
 679          Estado_Error= en caso de que aya un error a que estado envia el codigo
 680          Estado_Actua= No ha llegado la respuesta y sigue en el mismo estado
 681          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 682          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 683          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 684          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 685          
 686          (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 687          (1)= REENVIA_TRAMA reenvia la trama al transporte
 688          ------------------------------------------------------------------------------*/
 689          unsigned char   rta_cmd_transporte(unsigned char *secuencia_Expedidor )
 690          {
 691   1        unsigned char temp;
 692   1        unsigned char EstadoComSeqMF;
 693   1        
 694   1        
 695   1            
 696   1      if((temp=Trama_Validacion_P_N())!=RSPT_TRP_OK )
 697   1          {
 698   2            if(temp==ESPR_RSPT_TRP_TRAMA)                                                         /*no he recibido respuesta espero*/
 699   2            {
 700   3            EstadoComSeqMF= *(secuencia_Expedidor + EstadoActual);                              /*SEQ_RTA_CARD_POSno ha respon
             -dido*/
 701   3            } 
 702   2            else if (temp==ERROR_TRP_TRAMA)
 703   2            {
 704   3            Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR\r\n");                     /* trama no valida respuesta incorrec
             -ta falla en la escritura */
 705   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 706   3            EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado); 
 707   3            //EstadoComSeqMF=SEQ_INICIO ;                                                           /// (3) Trama invalida cmd (N)reenvio cmd*/ 
 708   3            }     
 709   2            else
 710   2            {
 711   3            /*Dispensador No Responde PTO SERIE ...*/
 712   3          
 713   3              if(temp=error_rx_pto()==ESPERA_MAS_TIEMPO)
 714   3              {
 715   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoActual); 
 716   4              }                                                                                     /*SEQ_RTA_CARD_POS;*/
 717   3              else                                                                                  //(temp=error_rx_pto()==REENVIA_TRAMA)
 718   3              {
 719   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                     /*SEQ_INICIO*/
 720   4              }                                                 
 721   3            }       
 722   2          }
 723   1          else
 724   1          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 13  

 725   2            
 726   2            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);
 727   2            EstadoComSeqMF=*(secuencia_Expedidor + EstadoFuturo); 
 728   2          }
 729   1        return EstadoComSeqMF;
 730   1      }
 731          
 732          /*------------------------------------------------------------------------------
 733          ------------------------------------------------------------------------------*/
 734          unsigned char Analiza_Presencia_Mensual()
 735          {
 736   1        unsigned char Estado_expedidor;
 737   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 738   1          {
 739   2            MenSual = True;
 740   2            Estado_expedidor = SEQ_TIPO_CARD;                 //SEQ_UID
 741   2          }
 742   1        else
 743   1          { 
 744   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 745   2              send_portERR(PRMR_ERROR_LOOP);
 746   2              PantallaLCD(ERROR_LOOP);
 747   2              Estado_expedidor = SEQ_EXPULSAR_CARD;
 748   2                    
 749   2          }
 750   1        return Estado_expedidor;
 751   1      }
 752          unsigned char Analiza_Presencia_rotacion()
 753          {
 754   1        unsigned char Estado_expedidor;
 755   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 756   1          {
 757   2            
 758   2            Estado_expedidor = SEQ_MOVER_CARD_RF;                 //SEQ_UID
 759   2          }
 760   1        else
 761   1          { 
 762   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 763   2              send_portERR(PRMR_ERROR_LOOP);
 764   2              PantallaLCD(ERROR_LOOP);
 765   2              Estado_expedidor = SEQ_INICIO;  //SEQ_EXPULSAR_CARD;
 766   2                    
 767   2          }
 768   1        return Estado_expedidor;
 769   1      }
 770          /*------------------------------------------------------------------------------
 771          Funcion numero unico de identificacion
 772          ------------------------------------------------------------------------------*/
 773          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor )
 774          {
 775   1        unsigned char Estado_expedidor;
 776   1        unsigned char temp;
 777   1        unsigned char buffer_UID[17];
 778   1          if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
 779   1            {
 780   2              
 781   2                for (temp=0; temp<16; ++temp)
 782   2                {
 783   3                  buffer_UID [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de M
             -F en un arreglo*/
 784   3                 
 785   3                }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 14  

 786   2                
 787   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
 788   2                DebugBufferMF(buffer_UID,16,RESPUESTA);
 789   2                
 790   2        
 791   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
 792   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_0]));  
 793   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_1]));  
 794   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_2]));  
 795   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_3]));
 796   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
 797   2                
 798   2              *(Atributos_Expedidor + Uid_0) = buffer_UID [MF_UID_0];   
 799   2              *(Atributos_Expedidor + Uid_1) = buffer_UID [MF_UID_1];     
 800   2              *(Atributos_Expedidor + Uid_2) = buffer_UID [MF_UID_2];     
 801   2              *(Atributos_Expedidor + Uid_3) = buffer_UID [MF_UID_3]; 
 802   2              Estado_expedidor=SEQ_LOAD_PASSWORD;                                                       //SEQ_TIPO_CARD;
 803   2            }   
 804   1            else
 805   1            {
 806   2              Estado_expedidor=SEQ_POWER_OFF;
 807   2            } 
 808   1            return Estado_expedidor;
 809   1      }
 810          /*------------------------------------------------------------------------------
 811          Se analiza si expulsa la tarjeta por boton o automatica
 812          ------------------------------------------------------------------------------*/
 813          unsigned char Ingreso_Vehiculo(void)
 814            {
 815   1          unsigned char CardAutomatic;  
 816   1          static unsigned char pulseboton=0;
 817   1        
 818   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 819   1          {
 820   2            CardAutomatic=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);  
 821   2            
 822   2            if (CardAutomatic==True)                                                    //se pregunta si expide la tarjeta automatica o por p
             -resionar el boton
 823   2              {
 824   3                Debug_txt_Tibbo((unsigned char *) "Tarjeta: Automatico\r\n");           //expide tarjetas automatico con p
             -resencia
 825   3                                                                                        // muevo la tarjeta hasta el lector de rf
 826   3                Estado=SEQ_MOVER_CARD_RF;                                               // valido el cmd enviado al verificador
 827   3               }
 828   2            else
 829   2              {     
 830   3                  if(pulseboton==False)
 831   3                  { PantallaLCD(PULSE_BOTON); 
 832   4                  }
 833   3                  else
 834   3                   {
 835   4                     pulseboton++;
 836   4                    
 837   4                   
 838   4                   }
 839   3                    sel_Pulsa();                                                        //se valida el pulsador en hardware
 840   3                    if (DataIn!=True)       
 841   3                      {
 842   4                        Debug_txt_Tibbo((unsigned char *) "Pulsador Activo\r\n");       //el pulsador fue presionado
 843   4                        pulseboton=0;                                                               //muevo tarjeta hasta el lector de RF
 844   4                        Estado=SEQ_MOVER_CARD_RF;                                       //valido el cmd enviado al verificador
 845   4                      }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 15  

 846   3                    else
 847   3                        {
 848   4                          Estado=SEQ_INICIO;  
 849   4                        }
 850   3                  
 851   3              } 
 852   2          }
 853   1          else
 854   1              { 
 855   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 856   2                Estado=SEQ_INICIO;  
 857   2              }
 858   1        return Estado;
 859   1      }
 860           
 861          /*------------------------------------------------------------------------------
 862          Se pregunta por el estado del expedidor si hay tarjetas y presencia para expulsar tarjeta
 863          o si hay tarjeta en la boca o rf para entrar en mensuales
 864          ------------------------------------------------------------------------------*/
 865          
 866          unsigned char Responde_Estado_Sensores_Transporte()
 867          {
 868   1        unsigned char Estado_expedidor;
 869   1          
 870   1            Debug_txt_Tibbo((unsigned char *) "TAREA_PRESENCIA_VEHICULAR\r\n");                                 // trama valida Hab
             -ilitado 
 871   1          
 872   1            if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                                 // CANAL LIBRE    no tiene 
             -tarjetas en el mecanismo
 873   1            {
 874   2                
 875   2              if  ((Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS)||(Buffer_Rta_Lintech[Pos_St1]==FULL_CARD  ))  //  se
             - detecta la tarjeta en la boca TARJETA EN BEZZEL
 876   2              {
 877   3                if (Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS  )                                             // nivel de tarjetas
 878   3                  {
 879   4                    Debug_txt_Tibbo((unsigned char *) "Nivel bajo de tarjetas\r\n");                            // nivel bajo de tarj
             -etas 
 880   4                    send_portERR(LOW_CARD);                                                                     //envio msj al primario
 881   4                  //  PantallaLCD(LOW_CARD);                                                                            //envio msj por la raspberry nivel ba
             -jo de tarjetas
 882   4                    Estado_expedidor=Ingreso_Vehiculo();        
 883   4                   }
 884   3                   else
 885   3                      {
 886   4                        /*respuesta ok*/
 887   4                       Estado_expedidor=Ingreso_Vehiculo();
 888   4                      
 889   4                      }
 890   3              } 
 891   2              else 
 892   2                  {
 893   3                    /*dispensador no posee tarjetas*/
 894   3                    Debug_txt_Tibbo((unsigned char *) "Dispensador SIN TARJETAS...\r\n"); 
 895   3                    
 896   3                    send_portERR(NO_CARD);  
 897   3                                                                          // se envia msj al uC principal, visualiza en el lcd que no hay tarjetas
 898   3                  //  PantallaLCD(NO_CARD);   
 899   3                    Estado_expedidor=SEQ_INICIO;                                                                //inicio el loop
 900   3                   }
 901   2            }
 902   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 16  

             - en la boca TARJETA EN BEZZEL
 903   1              {
 904   2                    /*hay una tarjeta en la boca del verificador */
 905   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                                //se envia msj al debug
             -er q hay tarjeta en la boca
 906   2                                                                                                                //se habilita recepcion de tarjetas por boca
 907   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;                                                     //se trabaja mensual        
 908   2              }
 909   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
 910   1                  
 911   1              {
 912   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en RF\r\n");
 913   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;
 914   2              }
 915   1            else
 916   1              {
 917   2                Estado_expedidor=SEQ_INICIO;  
 918   2              }
 919   1        return Estado_expedidor;  
 920   1      }
 921          
 922          /*------------------------------------------------------------------------------
 923          Funcion que nos dice el tipo de tarjeta que tiene en el mecanismo
 924          Comprobacion automatica del tipo de tarjeta 
 925          checking RF card type
 926          Card_type_H   Card_type_L  explicacion
 927              0             0           tarjeta desconocida
 928              1             0           MF50
 929              1             1           MF70
 930              1             2           MF_UL
 931              2             0           TYPE_A_CPU
 932          
 933          #define MF50_HIGH             '1'
 934          #define MF50_LOW              '0'
 935          ------------------------------------------------------------------------------*/
 936          unsigned char Responde_Tipo_Tarjeta()
 937            {
 938   1          unsigned char Estado_expedidor;
 939   1          
 940   1            Debug_txt_Tibbo((unsigned char *) "TAREA_TIPO DE TARJETA\r\n");                         // trama valida Habilitado 
 941   1            
 942   1        if (Buffer_Rta_Lintech[Card_type_H]==MF50_HIGH)                                             /* pregunto si la tarjeta en el tra
             -nsporte es MF 50 */
 943   1          {
 944   2          if ((Buffer_Rta_Lintech[Card_type_L] == MF50_LOW) || (Buffer_Rta_Lintech[Card_type_L] == MF70)) 
 945   2            {
 946   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n");                         /* trama valida son MF50*/
 947   3              if(MenSual ==  True)
 948   3              {
 949   4              Estado_expedidor = SEQ_UID;                                                             //SEQ_LOAD_PASSWORD;                        
 950   4              }
 951   3              else  
 952   3              {
 953   4                Estado_expedidor = SEQ_LOAD_PASSWORD;
 954   4              }         
 955   3            }
 956   2            else
 957   2              {
 958   3                 if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
 959   3                {
 960   4                
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 17  

 961   4                Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida_1 no es MF50\r\n");           /* trama no valida */
 962   4                      
 963   4                send_portERR(PRMR_TARJETA_INVALIDA);                                                              /*envio msj principal tarjeta inva
             -lidad*/
 964   4                PantallaLCD(TARJETA_INVALIDA);
 965   4                    
 966   4                  Estado_expedidor = Captura_Expulsa(); 
 967   4                
 968   4                } 
 969   3                else  
 970   3                {
 971   4                  MenSual = False;
 972   4                  Estado_expedidor = SEQ_INICIO;    
 973   4                }           
 974   3              }
 975   2          }
 976   1          else 
 977   1            {
 978   2               if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta 
             -en la boca TARJETA EN BEZZEL
 979   2                {
 980   3                  /*patina el transporte */
 981   3                
 982   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");           /* trama no valida */
 983   3                      
 984   3              send_portERR(PRMR_TARJETA_INVALIDA);                                                              //la tarjeta no es valida 
 985   3              PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la raspber
             -ry*/
 986   3                        
 987   3              Estado_expedidor = Captura_Expulsa(); 
 988   3                          
 989   3                  
 990   3                }
 991   2                else  
 992   2                {
 993   3                  MenSual = False;
 994   3                  Estado_expedidor = SEQ_INICIO;    
 995   3                }                     
 996   2            }
 997   1                    
 998   1          return Estado_expedidor;                                                                                                  
 999   1        } 
1000          /*------------------------------------------------------------------------------
1001            Funcion que lee los datos en el Sector 1 Bloque 1
1002            se lee
1003            ID_CLIENTE
1004            COD_PARK
1005            TIPO DE TARJETA
1006            EXPIRA_ANO
1007            EXPIRA_MES
1008            EXPIRA_DIA
1009          ------------------------------------------------------------------------------*/
1010          
1011          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
1012          {
1013   1        unsigned char temp;
1014   1        unsigned char Estado_expedidor;
1015   1        unsigned char buffer_S1_B1[17];
1016   1        unsigned char ID_CLIENTE;
1017   1        unsigned char COD_PARK;   
1018   1        static unsigned char falla=0;
1019   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE1\r\n");   
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 18  

1020   1                                        
1021   1                                      
1022   1            
1023   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1024   1            {
1025   2              
1026   2                for (temp=0; temp<16; ++temp)
1027   2                {
1028   3                  buffer_S1_B1 [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de
             - MF en un arreglo*/
1029   3                 
1030   3                }
1031   2                
1032   2                
1033   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b1\r\n");
1034   2                DebugBufferMF(buffer_S1_B1,16,RESPUESTA);
1035   2                ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1036   2                COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
1037   2                /*Compara  MF_ID_CLIENTE y MF_COD_PARK con el codigo del parqueadero ID_CLIENTE  COD_PARK*/
1038   2                
1039   2                if (((buffer_S1_B1 [ MF_ID_CLIENTE])==ID_CLIENTE) && ((buffer_S1_B1 [ MF_COD_PARK] ) == COD_PARK)||((
             -ID_CLIENTE==0)&&(COD_PARK==0)))   
1040   2                {
1041   3                    
1042   3                  Debug_txt_Tibbo((unsigned char *) "CARD ID_CLIENTE: ");               
1043   3                  Debug_HexDec((buffer_S1_B1 [ MF_ID_CLIENTE]));
1044   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1045   3                  
1046   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");                
1047   3                  Debug_HexDec(ID_CLIENTE);
1048   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1049   3                  
1050   3                  Debug_txt_Tibbo((unsigned char *) "CARD COD_PARK:");                    
1051   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1052   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1053   3                  
1054   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");                   
1055   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1056   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1057   3      
1058   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
1059   3                  Debug_chr_Tibbo(buffer_S1_B1 [MF_TIPO_TARJETA]);
1060   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1061   3                  
1062   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S1_B1 [MF_TIPO_TARJETA];
1063   3                  /*fecha de vencimiento de mensual o prepago*/
1064   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S1_B1 [MF_EXPIRA_ANO];
1065   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S1_B1 [MF_EXPIRA_MES];
1066   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S1_B1 [MF_EXPIRA_DIA];
1067   3                  
1068   3                  *(Atributos_Expedidor + Sector) = Sector_1;
1069   3                  *(Atributos_Expedidor + Bloque) = Bloque_2;
1070   3                  falla=0;
1071   3                  Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1072   3              
1073   3                }
1074   2                else
1075   2                {
1076   3                  falla=0;
1077   3                  Debug_txt_Tibbo((unsigned char *) "ERROR COD PARK\r\n");
1078   3                  send_portERR(PRMR_ERROR_COD_PARK);
1079   3                  PantallaLCD(ERROR_COD_PARK);                                                        //envio el msj por la pantalla lcd o la rasp
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 19  

             -berry
1080   3                  Estado_expedidor = Captura_Expulsa();                                                 //   codigo de parqueo erro expulso la 
             -tarjeta     
1081   3                }
1082   2            }
1083   1            else
1084   1            {
1085   2                
1086   2              if ((Buffer_Rta_Lintech[Rtype]) == OPERATE_FAIL)
1087   2              {
1088   3                falla++;
1089   3              }
1090   2               if (falla <= 2)
1091   2                
1092   2              {
1093   3                Debug_txt_Tibbo((unsigned char *) "ERROR OPERATE FAIL\r\n");
1094   3                Estado_expedidor = SEQ_POWER_ON;
1095   3                                    
1096   3              }
1097   2              else
1098   2              {
1099   3                falla=0;
1100   3                Debug_txt_Tibbo((unsigned char *) "TARJETA SIN FORMATO\r\n");
1101   3                send_portERR(PRMR_TARJETA_SIN_FORMATO);
1102   3                PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la 
             -raspberry*/
1103   3               Estado_expedidor =Captura_Expulsa();   
1104   3              }
1105   2            }
1106   1            
1107   1        return Estado_expedidor;
1108   1      } 
1109          /*------------------------------------------------------------------------------
1110          
1111          ------------------------------------------------------------------------------*/
1112          
1113          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
1114          {
1115   1        unsigned char temp;
1116   1        unsigned char Estado_expedidor;
1117   1        unsigned char buffer_S1_B2[17]; 
1118   1      
1119   1            
1120   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");   
1121   1            
1122   1                              
1123   1            
1124   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1125   1            {
1126   2              
1127   2                for (temp=0; temp<16; ++temp)
1128   2                {
1129   3                  buffer_S1_B2 [temp] =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion d
             -e MF en un arreglo*/
1130   3                }
1131   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b2\r\n");
1132   2                DebugBufferMF(buffer_S1_B2,16,RESPUESTA);
1133   2                
1134   2                      
1135   2                
1136   2                Debug_txt_Tibbo((unsigned char *) "HORARIO:");
1137   2                Debug_chr_Tibbo((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 20  

1138   2                *(Atributos_Expedidor + Horario)= ((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1139   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1140   2                
1141   2                Debug_txt_Tibbo((unsigned char *) "PICO Y PLACA:");
1142   2                
1143   2                *(Atributos_Expedidor + Pico_Placa)= ((buffer_S1_B2 [MF_IN_PAGO] & 0XF0) >> 4);
1144   2                Debug_chr_Tibbo(*(Atributos_Expedidor + Pico_Placa));
1145   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1146   2                
1147   2            
1148   2                Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK:");
1149   2                Debug_chr_Tibbo(buffer_S1_B2 [MF_APB] );
1150   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1151   2              
1152   2                /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
1153   2                
1154   2                *(Atributos_Expedidor + Apb)=   buffer_S1_B2 [MF_APB] ;
1155   2                
1156   2                
1157   2                  *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S1_B2 [MF_TIPO_VEHICULO]& 0x0f;
1158   2                  Estado_expedidor =SEQ_TIPO_TARJETAS;    // Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);
1159   2            
1160   2        
1161   2            }
1162   1            else
1163   1            {
1164   2              Estado_expedidor = Captura_Expulsa(); //momentario
1165   2            }
1166   1          return Estado_expedidor;  
1167   1      }
1168          
1169          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque0 (unsigned char *Nombre_Mensual)
1170          {
1171   1        unsigned char temp;
1172   1        unsigned char Estado_expedidor;
1173   1          
1174   1      
1175   1            
1176   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE0\r\n");   
1177   1            
1178   1                              
1179   1            
1180   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1181   1            {
1182   2              
1183   2                for (temp=0; temp<16; ++temp)
1184   2                {
1185   3                  *(Nombre_Mensual + temp ) =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informa
             -cion de MF en un arreglo*/
1186   3                }
1187   2                *(Nombre_Mensual + temp )=NULL;
1188   2                Debug_txt_Tibbo((unsigned char *) "Nombre Mensual:");
1189   2                Debug_txt_Tibbo(Nombre_Mensual );
1190   2                Debug_txt_Tibbo((unsigned char *) "\r\n");      
1191   2                Estado_expedidor = SEQ_LPR;           //SEQ_TIPO_TARJETAS;                                                // Valida_Tipo_Tarjeta(A
             -tributos_Expedidor,Buffer_Write_MF);
1192   2            
1193   2        
1194   2            }
1195   1            else
1196   1            {
1197   2              Estado_expedidor = Captura_Expulsa(); //momentario
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 21  

1198   2            }
1199   1          return Estado_expedidor;  
1200   1      }
1201          unsigned char Responde_Write_Tarjeta_Sector1_Bloque1(unsigned char *Buffer_Write_MF)
1202          {
1203   1        unsigned char Estado_expedidor;
1204   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE1\r\n"); 
1205   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b1\r\n");
1206   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1207   1        Estado_expedidor = SEQ_TIPO_CARD;
1208   1        return Estado_expedidor;
1209   1      }
1210          unsigned char Responde_Write_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buf
             -fer_Write_MF)
1211          {
1212   1        unsigned char Estado_expedidor;
1213   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE2\r\n"); 
1214   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b2\r\n");
1215   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1216   1        if(MenSual !=  True)
1217   1        {
1218   2        *(Atributos_Expedidor + Sector) = Sector_1;
1219   2        *(Atributos_Expedidor + Bloque) = Bloque_0;
1220   2        Armar_Trama_Tarjeta_Sector1_Bloque0(Buffer_Write_MF);
1221   2          Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1222   2        }
1223   1        else
1224   1        {
1225   2          *(Atributos_Expedidor + Sector) = Sector_1;
1226   2          *(Atributos_Expedidor + Bloque) = Bloque_0;
1227   2          Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1228   2          
1229   2        }
1230   1        return Estado_expedidor;
1231   1      }
1232          /*----------------------------------------------------------------------------
1233          ----------------------------------------------------------------------------*/
1234          unsigned char Responde_Write_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1235          {
1236   1      
1237   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE0\r\n"); 
1238   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b0\r\n");
1239   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1240   1        
1241   1        return SEQ_LPR;
1242   1      }
1243          /*----------------------------------------------------------------------------
1244          ----------------------------------------------------------------------------*/
1245          unsigned char Pregunta_Lpr(unsigned char *Atributos_Expedidor)
1246          {
1247   1        unsigned char Estado_expedidor;
1248   1          if(rd_eeprom(0xa8,EE_USE_LPR)== True)
1249   1             {
1250   2               /*monitor trama*/
1251   2               Debug_txt_Tibbo(Armar_Trama_Monitor(Atributos_Expedidor));
1252   2                if (rd_eeprom(0xa8,EE_DEBUG) == False)
1253   2                 {
1254   3                   Debug_Tibbo=False;
1255   3                 }
1256   2             }
1257   1        
1258   1          if (rd_eeprom(0xa8,EE_PLACA)!= False)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 22  

1259   1          {
1260   2            /*espero placa*/
1261   2            Estado_expedidor=SEQ_WAIT_PLACA;
1262   2            ValTimeOutCom=TIME_WAIT ;
1263   2            Timer_wait=False;
1264   2          }
1265   1          else 
1266   1          {
1267   2          Estado_expedidor=SEQ_FRONT_CARD;
1268   2          }
1269   1        return Estado_expedidor;
1270   1      }
1271          /*----------------------------------------------------------------------------
1272          ----------------------------------------------------------------------------*/
1273          unsigned char Responde_Write_Tarjeta_Sector2_Bloque0(unsigned char *Buffer_Write_MF)
1274          {
1275   1        
1276   1        Debug_txt_Tibbo((unsigned char *) "PLACA:");  
1277   1        Debug_txt_Tibbo((unsigned char *) placa);
1278   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1279   1        Debug_txt_Tibbo((unsigned char *) "Write_s2_b0\r\n");
1280   1        DebugBufferMF(Buffer_Write_MF,16,ENVIADOS);
1281   1        return SEQ_FRONT_CARD;
1282   1      }
1283          unsigned char  Respuesta_Segunda_clave(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1284          {
1285   1        
1286   1        Debug_txt_Tibbo((unsigned char *) "TAREA_SEGUNDA CLAVE\r\n"); 
1287   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1288   1      
1289   1        
1290   1        *(Atributos_Expedidor + Sector) = Sector_2;
1291   1        *(Atributos_Expedidor + Bloque) = Bloque_0;
1292   1        Armar_Trama_Placa(Buffer_Write_MF);
1293   1          
1294   1        return SEQ_WRITE_SECTOR_BLOQUE;
1295   1      }
1296          unsigned char Respuesta_Placa_Cancel(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1297          {
1298   1        unsigned char Estado_expedidor;
1299   1        unsigned char *Cancel="CANCEL";
1300   1        Debug_txt_Tibbo((unsigned char *) "RESPUESTA PLACA O CANCEL = "); 
1301   1        Debug_txt_Tibbo((unsigned char *) placa);
1302   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1303   1        if(strcmp(placa,Cancel)== 0)
1304   1        {
1305   2        *(Atributos_Expedidor + Sector) = Sector_1;
1306   2        *(Atributos_Expedidor + Bloque) = Bloque_1;
1307   2          Armar_Trama_Tarjeta_Sector1_Bloque1_Camcel(Buffer_Write_MF);
1308   2          Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1309   2        }
1310   1        else
1311   1        {
1312   2          if(MenSual ==  True)
1313   2          {
1314   3            Estado_expedidor = SEQ_FRONT_CARD;  
1315   3          }
1316   2          else
1317   2          {
1318   3            Estado_expedidor = SEQ_SECOND_PASSWORD;
1319   3          }     
1320   2        } 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 23  

1321   1        return Estado_expedidor;
1322   1      }
1323          /*------------------------------------------------------------------------------
1324          ------------------------------------------------------------------------------*/
1325          void  Armar_Trama_Tarjeta_Sector1_Bloque1_Camcel(unsigned char *Buffer_Write_MF)
1326          {
1327   1        unsigned char ID_CLIENTE;
1328   1        unsigned char COD_PARK; 
1329   1          /*cuando se recibe el CAMCEL se bloquea la tarjeta*/
1330   1        clear_placa();
1331   1        ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1332   1        COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
1333   1      
1334   1        *(Buffer_Write_MF + MF_TIPO_TARJETA)  = MENSUALIDAD;
1335   1        *(Buffer_Write_MF + MF_COD_PARK)      = COD_PARK; 
1336   1        *(Buffer_Write_MF + MF_COD_PARK+1)    = NULL;
1337   1        *(Buffer_Write_MF + MF_ID_CLIENTE)    = ID_CLIENTE;
1338   1        *(Buffer_Write_MF + MF_ID_CLIENTE+1)  = NULL;
1339   1        *(Buffer_Write_MF + MF_MENSUAL_ANO)   = NULL;
1340   1        *(Buffer_Write_MF + MF_MENSUAL_MES)   = NULL;
1341   1        *(Buffer_Write_MF + MF_MENSUAL_DIA)   = NULL;
1342   1        *(Buffer_Write_MF + MF_EXPIRA_ANO)    = NULL;
1343   1        *(Buffer_Write_MF + MF_EXPIRA_MES)    = NULL;
1344   1        *(Buffer_Write_MF + MF_EXPIRA_DIA)    = NULL;
1345   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+1)  = NULL;
1346   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+2)  = NULL;
1347   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+3)  = NULL;
1348   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+4)  = NULL;
1349   1      }
1350          
1351          /*------------------------------------------------------------------------------
1352          ------------------------------------------------------------------------------*/
1353          
1354          void  Armar_Trama_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_M
             -F)
1355          {
1356   1        
1357   1        /*fecha de ingreso se lee año,mes,dia,hora y minutos*/
1358   1        
1359   1        Block_read_Clock_Hex(Buffer_Write_MF);
1360   1        
1361   1        /*descuentos los borro*/
1362   1        
1363   1        *(Buffer_Write_MF + 5)=0;
1364   1        *(Buffer_Write_MF + 6)=0;
1365   1        *(Buffer_Write_MF + 7)=0;
1366   1        
1367   1        if (*(Atributos_Expedidor + Tipo_Tarjeta) == ROTACION)
1368   1        {
1369   2          *(Buffer_Write_MF + 8)  = Tipo_Vehiculo;
1370   2          *(Buffer_Write_MF + 9)  = (Dir_board())- 0x30;
1371   2          *(Buffer_Write_MF +10) = APB_INT;
1372   2        }
1373   1        
1374   1        /*mensual*/
1375   1        else
1376   1        {
1377   2          
1378   2          *(Buffer_Write_MF + 8)  = (*(Atributos_Expedidor + Horario) << 4) | (*(Atributos_Expedidor + Type_Vehicu
             -lo));
1379   2          *(Buffer_Write_MF + 9)  =  (*(Atributos_Expedidor + Pico_Placa) << 4)| (Dir_board())- 0x30;
1380   2          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 24  

1381   2          if (*(Atributos_Expedidor + Apb)== APB_NO)
1382   2           {
1383   3              *(Buffer_Write_MF +10) =APB_NO;
1384   3            }
1385   2          else 
1386   2          {
1387   3            *(Buffer_Write_MF +10) =APB_INT;
1388   3          }
1389   2        }
1390   1        /*fecha de salida maxima*/
1391   1        *(Buffer_Write_MF +11)=0;
1392   1        *(Buffer_Write_MF +12)=0;
1393   1        *(Buffer_Write_MF +13)=0;
1394   1        *(Buffer_Write_MF +14)=0;
1395   1        *(Buffer_Write_MF +15)=0;
1396   1      }
1397          void Armar_Trama_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1398          {
1399   1        /*graba serie de Ticket*/
1400   1        strcpy(Buffer_Write_MF, Lee_No_Ticket());
1401   1      }
1402          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor(unsigned char *h)
1403          {
1404   1        static unsigned char buffer[28];
1405   1        unsigned char ticket[11];
1406   1        unsigned char j;
1407   1        /*la trama esta compuesta de
1408   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1409   1      
1410   1        buffer[0]=STX;
1411   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR;
1412   1        buffer[2]=NULL;
1413   1        strcpy(ticket, Lee_No_Ticket());
1414   1        strcat(buffer , ticket);
1415   1        j=strlen(buffer);
1416   1        
1417   1        buffer[j++]= '-';
1418   1        
1419   1        Block_read_Clock_Hex(buffer+j);         //leo la fecha de entrada
1420   1        buffer[j]=buffer[j]+0x030;              /*año de entrada*/
1421   1        buffer[j+1]=buffer[j+1]+0x030;          /*mes de entrada*/
1422   1        buffer[j+2]=buffer[j+2]+0x030;          /*dia de entrada*/
1423   1        buffer[j+3]=buffer[j+3]+0x030;          /*hora de entrada*/
1424   1        buffer[j+4]=buffer[j+4]+0x030;          /*minutos de entrada*/
1425   1        buffer[j+5]= '-';
1426   1        /*placa*/
1427   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1428   1        {   
1429   2          if (placa_ready != False)
1430   2          {
1431   3            buffer[j+6]= placa[0];
1432   3            buffer[j+7]= placa[1];
1433   3            buffer[j+8]= placa[2];
1434   3            buffer[j+9]= placa[3];
1435   3            buffer[j+10]= placa[4];
1436   3            buffer[j+11]= placa[5];
1437   3            buffer[j+12]= NULL;
1438   3          }
1439   2          else
1440   2          {
1441   3            buffer[j+6]= ' ';
1442   3            buffer[j+7]= NULL;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 25  

1443   3          }
1444   2        }
1445   1        else 
1446   1        {
1447   2          buffer[j+6]= ' ';
1448   2          buffer[j+7]=NULL;
1449   2        }
1450   1        j=strlen(buffer);
1451   1        buffer[j]= ETX;
1452   1        *h=j+1;
1453   1        
1454   1        return buffer;
1455   1      }
1456          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor,unsigned char
             - *j)
1457          {
1458   1        static unsigned char buffer[28];
1459   1      
1460   1        /*la trama esta compuesta de
1461   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1462   1      
1463   1        buffer[0]=STX;
1464   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
1465   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
1466   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
1467   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
1468   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
1469   1        
1470   1        
1471   1        Block_read_Clock_Hex(buffer+6);         //leo la fecha de entrada
1472   1        buffer[6]=buffer[6]+0x030;              /*año de entrada*/
1473   1        buffer[7]=buffer[7]+0x030;          /*mes de entrada*/
1474   1        buffer[8]=buffer[8]+0x030;          /*dia de entrada*/
1475   1        buffer[9]=buffer[9]+0x030;          /*hora de entrada*/
1476   1        buffer[10]=buffer[10]+0x030;          /*minutos de entrada*/
1477   1      
1478   1        /*placa*/
1479   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1480   1        {   
1481   2          
1482   2            buffer[11]= placa[0];
1483   2            buffer[12]= placa[1];
1484   2            buffer[13]= placa[2];
1485   2            buffer[14]= placa[3];
1486   2            buffer[15]= placa[4];
1487   2            buffer[16]= placa[5];
1488   2      
1489   2        }
1490   1      
1491   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1492   1        {
1493   2          buffer[17]= 'C';
1494   2        }
1495   1        else
1496   1        {
1497   2          buffer[17]= 'M';
1498   2        }
1499   1        
1500   1        buffer[18]= ETX;
1501   1        buffer[19]= NULL;
1502   1        *j=19;
1503   1        return buffer;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 26  

1504   1      }
1505          unsigned char *Armar_Trama_Monitor(unsigned char *Atributos_Expedidor)
1506          {
1507   1        static unsigned char buffer[24];
1508   1        unsigned char ticket[11];
1509   1        unsigned char j;
1510   1        /*la trama esta compuesta de
1511   1        STX,address_board,CMD,Tipo_Vehiculo,NoTICKET,:,fecha int añomesdishoraminuto,:,ETX*/
1512   1        Debug_Tibbo=False;
1513   1        buffer[0]=STX;
1514   1        buffer[1]=Dir_Board_Monitor();
1515   1        buffer[2]=CMD_MONITOR_EXPEDIDOR;
1516   1        if(Tipo_Vehiculo == AUTOMOVIL)
1517   1          {
1518   2            buffer[3]= 'C';
1519   2          }
1520   1        else
1521   1          {
1522   2            buffer[3]= 'M';
1523   2          }
1524   1          
1525   1          /*ticket*/
1526   1          if(MenSual !=  True)
1527   1          {
1528   2          buffer[4]=NULL;
1529   2          strcpy(ticket, Lee_No_Ticket());
1530   2          strcat(buffer , ticket);
1531   2          }
1532   1          else
1533   1          {
1534   2            ByteHex_Decimal(buffer+4,*(Atributos_Expedidor + Uid_2));
1535   2            j=strlen(buffer);
1536   2            buffer[j]= ' ';
1537   2            buffer[j+1]= NULL;
1538   2            j=strlen(buffer);
1539   2            Two_ByteHex_Decimal(buffer+j,*(Atributos_Expedidor + Uid_1),*(Atributos_Expedidor + Uid_0));
1540   2            
1541   2          }
1542   1          j=strlen(buffer);
1543   1          buffer[j]=':';
1544   1          /*fecha de entrada*/
1545   1          
1546   1          Block_read_clock_ascii(buffer+j+1);     //leo la fecha de entrada
1547   1          j=strlen(buffer);
1548   1        
1549   1          buffer[j]= ':';
1550   1          buffer[j+1]=ETX;
1551   1          buffer[j+2]=NULL;
1552   1          Debug_Tibbo=True;
1553   1        return buffer;
1554   1      }
1555          void Armar_Trama_Placa(unsigned char *Buffer_Write_MF)
1556          {
1557   1        unsigned char j;
1558   1        
1559   1          for(j=0; j<8;j++)
1560   1          {
1561   2          *(Buffer_Write_MF +j)=placa[j];
1562   2          }
1563   1            for (j=8; j<16; j++)            
1564   1          {
1565   2            *(Buffer_Write_MF +j)=0x00;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 27  

1566   2          }
1567   1      }
1568          unsigned char Load_Secuencia_Expedidor(unsigned char *Secuencia_Expedidor,unsigned const  estadoactivo,uns
             -igned const estadoactual,unsigned const estadofuturo)
1569          {
1570   1        *(Secuencia_Expedidor + EstadoPasado ) = estadoactivo ;
1571   1        *(Secuencia_Expedidor + EstadoActual ) = estadoactual;
1572   1        *(Secuencia_Expedidor + EstadoFuturo ) = estadofuturo;
1573   1        return estadoactual;
1574   1      }
1575          unsigned char Disparo_Lock_Entrada_Vehiculo(unsigned char *Nombre_Mensual)
1576          {
1577   1        unsigned char Estado_expedidor;
1578   1        Debug_txt_Tibbo((unsigned char *) "TAKE CARD\r\n");
1579   1        
1580   1        PantallaLCD(RETIRE_TARJETA);
1581   1        
1582   1        if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                   // CANAL LIBRE    no tiene tarjetas 
             -en el mecanismo
1583   1          {
1584   2            Debug_txt_Tibbo((unsigned char *) "TAREA_OPEN_BARRERA\r\n");  
1585   2            lock=ON;
1586   2            send_portERR(BIENVENIDO);
1587   2            PantallaLCD_LINEA_2(BIENVENIDO,Nombre_Mensual);
1588   2            Estado_expedidor=SEQ_PTO_PARALELO;
1589   2            
1590   2            
1591   2          }
1592   1        else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                      //  se detecta la tarjeta en la b
             -oca TARJETA EN BEZZEL
1593   1        {
1594   2          if(Valida_Sensor1_Auto()!= False)
1595   2          {
1596   3            Estado_expedidor=SEQ_DETAIL_CARD;
1597   3          }
1598   2          else
1599   2          {
1600   3            Estado_expedidor=SEQ_CAPTURE_CARD;
1601   3          }
1602   2        
1603   2        }
1604   1        return Estado_expedidor;
1605   1      }
1606          unsigned char Send_Pto_Paralelo(unsigned char *Atributos_Expedidor)
1607          {
1608   1        unsigned char *Trama_Expedidor ;
1609   1        unsigned char leng_trama_pto;
1610   1        if(MenSual == True)
1611   1        {
1612   2        Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor,&leng_trama_pto );
1613   2        }
1614   1        else 
1615   1        {
1616   2          Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor(&leng_trama_pto);
1617   2          Incremente_Ticket();
1618   2        }
1619   1        
1620   1        send_port(Trama_Expedidor,leng_trama_pto);  
1621   1        Debug_txt_Tibbo((unsigned char *) "Trama_pto_paralelo\r\n");
1622   1        DebugBufferMF(Trama_Expedidor,leng_trama_pto,ENVIADOS);
1623   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1624   1        
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 28  

1625   1        
1626   1        clear_placa();
1627   1        ValTimeOutCom=TIME_WAIT ;
1628   1        Timer_wait=0;
1629   1        return SEQ_ESPERA_VEHICULO_ENTRE;
1630   1      }
1631          
1632          /*------------------------------------------------------------------------------
1633          ------------------------------------------------------------------------------*/
1634          unsigned char Entrega_Card_Captura()
1635          {
1636   1        unsigned char Estado_expedidor;
1637   1        
1638   1          
1639   1        Debug_txt_Tibbo((unsigned char *) "ESPERA VEHICULO ENTRE\r\n"); 
1640   1        sel_Sensor2();                                //garantiso q la barrera se encuentre en posicion baja  
1641   1        if ((DataIn==0))        
1642   1        {  
1643   2          if (ValidaSensor()==0)
1644   2          {
1645   3            lock=OFF;
1646   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo Entrando");
1647   3            Estado_expedidor=SEQ_INICIO;
1648   3          }
1649   2          
1650   2        }
1651   1        else
1652   1        {
1653   2            if(Valida_Sensor1_Auto()!= False)
1654   2            {
1655   3            /*presencia vehicular*/
1656   3              Estado_expedidor=SEQ_ESPERA_VEHICULO_ENTRE;//SEQ_INICIO;//
1657   3              
1658   3              if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1659   3              {
1660   4                  if (Timer_wait >= 5)
1661   4               {
1662   5                 lock=OFF;
1663   5                 Estado_expedidor=SEQ_INICIO;;
1664   5               }
1665   4              else if (Timer_wait <= 4)
1666   4               {
1667   5                ValTimeOutCom=TIME_WAIT ;
1668   5               }
1669   4             }
1670   3              
1671   3            }
1672   2            else
1673   2            {
1674   3            lock=OFF;
1675   3            Estado_expedidor=SEQ_INICIO;
1676   3            }
1677   2        } 
1678   1       
1679   1        return Estado_expedidor;
1680   1      }
1681          unsigned char Wait_Placa(unsigned char *Atributos_Expedidor, unsigned char *Buffer_Write_MF)
1682          {
1683   1        unsigned char Estado_expedidor;
1684   1        
1685   1          Debug_txt_Tibbo((unsigned char *) "Wait_Placa");
1686   1        /*espera la llega de placa o cancel*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 29  

1687   1        while ((ValTimeOutCom != 1) && (ValTimeOutCom <= TIME_WAIT) && (placa_ready == False))
1688   1        {
1689   2          if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
1690   2              {
1691   3                
1692   3                Rx_Monitor();
1693   3              }
1694   2        }
1695   1          /*llego Cancel o placa*/
1696   1          if(placa_ready!=False)
1697   1            {
1698   2              Estado_expedidor = Respuesta_Placa_Cancel(Atributos_Expedidor,Buffer_Write_MF);
1699   2            }
1700   1            else
1701   1              /*no llego placa o cancel*/
1702   1            {
1703   2                Estado_expedidor=SEQ_WAIT_PLACA;
1704   2             if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1705   2             {  
1706   3              if (Timer_wait >= 5)
1707   3               {
1708   4                 Estado_expedidor=SEQ_FRONT_CARD;
1709   4               }
1710   3              else if (Timer_wait <= 4)
1711   3               {
1712   4                ValTimeOutCom=TIME_WAIT ;
1713   4               }
1714   3             }
1715   2            }
1716   1        return Estado_expedidor;
1717   1      }
1718          unsigned char Valida_Vehiculo_Card_Mensual(unsigned char *Atributos_Expedidor)
1719          {
1720   1        unsigned char Estado_expedidor;
1721   1        
1722   1          Debug_txt_Tibbo((unsigned char *) "VEHICULO MENSUAL TARJETA: ");
1723   1          if(*(Atributos_Expedidor + Type_Vehiculo  ) == False)
1724   1           {
1725   2            Debug_txt_Tibbo((unsigned char *) "(0) CARRO");
1726   2           }
1727   1          else
1728   1           {
1729   2            Debug_txt_Tibbo((unsigned char *) "(1) MOTO");
1730   2           }
1731   1                            
1732   1          Debug_txt_Tibbo((unsigned char *) "\r\n");
1733   1        if ((rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL)) != True) 
1734   1        {
1735   2          if  (*(Atributos_Expedidor + Type_Vehiculo  ) == Tipo_Vehiculo )          
1736   2          {
1737   3           Debug_txt_Tibbo((unsigned char *) "COINCIDE CARD CON LOOK\r\n ");
1738   3            Estado_expedidor = True ;
1739   3          }
1740   2          
1741   2          else
1742   2          {
1743   3            send_portERR(PRMR_ERROR_TIPO_VEHICULO); 
1744   3            Debug_txt_Tibbo((unsigned char *) "TIPO DE VEHICULO NO CORRESPONDE\r\n ");
1745   3            Estado_expedidor = False; 
1746   3          }
1747   2        } 
1748   1        else 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 30  

1749   1        {
1750   2            Debug_txt_Tibbo((unsigned char *) "NO INTERESA COINCIDENCIA CARD CON LOOK\r\n ");
1751   2            Estado_expedidor = True ;
1752   2        }
1753   1          return Estado_expedidor;
1754   1      }
1755          unsigned char Tarjeta_Mensual(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1756          {
1757   1        unsigned char Estado_expedidor;
1758   1      //  unsigned char fecha_asii[7];
1759   1        
1760   1        /*cheque la fecha de expiracion del mensual*/
1761   1        if (Horarios(Atributos_Expedidor) == True)
1762   1        {
1763   2         if ( check_fechaOut(Atributos_Expedidor+Expira_ano) == True )
1764   2            {
1765   3              /*valida el vehiculo en el loop y en la card*/
1766   3              if( Valida_Vehiculo_Card_Mensual(Atributos_Expedidor) == False)
1767   3              {
1768   4              Estado_expedidor = Captura_Expulsa();   
1769   4              }
1770   3              else
1771   3              {
1772   4                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1773   4                *(Atributos_Expedidor + Sector) = Sector_1;
1774   4                *(Atributos_Expedidor + Bloque) = Bloque_2;
1775   4                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1776   4                Estado_expedidor=SEQ_WRITE_SECTOR_BLOQUE;
1777   4              }
1778   3            }
1779   2            else 
1780   2            {
1781   3              send_portERR(PRMR_TARJETA_VENCIDA); 
1782   3                  
1783   3              PantallaLCD(TARJETA_VENCIDA);
1784   3              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
1785   3              Estado_expedidor = SEQ_EXPULSAR_CARD;
1786   3            }
1787   2        }
1788   1        else
1789   1        {
1790   2          
1791   2          Estado_expedidor = SEQ_EXPULSAR_CARD;
1792   2        }
1793   1        return Estado_expedidor;
1794   1      }
1795          unsigned char Tarjeta_Rotacion(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1796          {
1797   1              *(Atributos_Expedidor + Sector) = Sector_1;
1798   1                *(Atributos_Expedidor + Bloque) = Bloque_2;
1799   1                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1800   1                return  SEQ_WRITE_SECTOR_BLOQUE;
1801   1        
1802   1        
1803   1      }
1804          unsigned char Valida_Tipo_Tarjeta(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1805          {
1806   1        unsigned char Estado_expedidor;
1807   1        if(*(Atributos_Expedidor + Tipo_Tarjeta) ==  MENSUALIDAD)
1808   1        {
1809   2          Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
1810   2          if(MenSual ==  True)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 31  

1811   2          {
1812   3          
1813   3          /*APB Habilitado por software*/
1814   3          
1815   3            if( (rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL) == APB_HABILITADO_SOFT) )
1816   3            {
1817   4              /*APB por Card*/
1818   4           
1819   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO))       
1820   4              {
1821   5                Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1822   5      
1823   5              }
1824   4              else
1825   4              {
1826   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK MENSUAL \r\n");
1827   5                send_portERR(PRMR_SIN_SALIDA);
1828   5                Estado_expedidor = Captura_Expulsa(); 
1829   5              } 
1830   4            }
1831   3          
1832   3          else
1833   3          {
1834   4            Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO MENSUAL \r\n");
1835   4          
1836   4           Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1837   4          }
1838   3        }
1839   2        else
1840   2         {
1841   3          send_portERR(PRMR_NO_CARD_MENSUAL);
1842   3          PantallaLCD(NO_CARD_MENSUAL);     
1843   3          Estado_expedidor = Captura_Expulsa(); 
1844   3         } 
1845   2       }
1846   1        else if (*(Atributos_Expedidor + Tipo_Tarjeta) ==  ROTACION)
1847   1        {
1848   2          
1849   2            Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n ");
1850   2          if(MenSual != True)
1851   2          {
1852   3            if ( (rd_eeprom(0xa8,EE_HABILITA_APB))!= APB_INHABILITADO_SOFT)
1853   3            {
1854   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO) )
1855   4                                    
1856   4              {
1857   5                Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
1858   5              }
1859   4              else
1860   4              {
1861   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK ROTACION \r\n");
1862   5                send_portERR(PRMR_SIN_SALIDA);
1863   5                PantallaLCD(SIN_SALIDA);
1864   5                Estado_expedidor = Captura_Expulsa();
1865   5              }
1866   4            }
1867   3            else
1868   3            {
1869   4              Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO ROTACION \r\n");
1870   4              Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 32  

1871   4            } 
1872   3          }
1873   2          else
1874   2          {
1875   3            /*tarjeta por insercion por boca */ 
1876   3            send_portERR(PRMR_NO_CARD_MENSUAL);
1877   3            PantallaLCD(NO_CARD_MENSUAL);     
1878   3            Estado_expedidor = SEQ_EXPULSAR_CARD;       //Captura_Expulsa();    
1879   3          }
1880   2        }
1881   1        else
1882   1        {
1883   2          Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n ");
1884   2          send_portERR(PRMR_NO_ROTACION);
1885   2          
1886   2          Estado_expedidor = Captura_Expulsa();   
1887   2        }
1888   1        
1889   1        return Estado_expedidor;
1890   1      }
1891          /*
1892          unsigned char Festivos()
1893          {
1894            
1895            unsigned char dia_semana,day, month, year,DiaFestivo=0;
1896          
1897            
1898            dia_semana=bcd_hex(lee_clk(RDIA_SEMANA));
1899            day = bcd_hex(lee_clk(RDIA));
1900            month = bcd_hex(lee_clk(RMES));
1901            year = bcd_hex(lee_clk(RANO));
1902            
1903            if (year==20)
1904            {
1905              if (((month==1)&&(day==1))||((month==1)&&(day==6))||((month==3)&&(day==23))||((month==4)&&(day==9))||((m
             -onth==4)&&(day==10))||((month==5)&&(day==1))||((month==5)&&(day==25))||((month==6)&&(day==3)))  
1906              {
1907                DiaFestivo = True;
1908                }
1909              else if (((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==17))||((month==10)&&(day==1
             -2))||((month==11)&&(day==2))||((month==11)&&(day==16))||((month==12)&&(day==8))||((month==12)&&(day==25)))
1910              {
1911                DiaFestivo = True;
1912              }
1913          
1914            }
1915            else if (year==21)
1916            {
1917              if (((month==1)&&(day==1))||((month==1)&&(day==11))||((month==3)&&(day==22))||((month==4)&&(day==1))||((
             -month==4)&&(day==2))||((month==5)&&(day==1))||((month==5)&&(day==17))||((month==6)&&(day==7))||((month==6)&&(day==14))) 
1918              {
1919                DiaFestivo = True;
1920                }
1921              else if (((month==7)&&(day==5))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==16)
             -)||((month==10)&&(day==18))||((month==11)&&(day==1))||((month==11)&&(day==15))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
1922              {
1923                DiaFestivo = True;
1924              }
1925          
1926            }
1927            else if (year==22)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 33  

1928            {
1929              if (((month==1)&&(day==1))||((month==1)&&(day==10))||((month==3)&&(day==21))||((month==4)&&(day==14))||(
             -(month==4)&&(day==15))||((month==5)&&(day==1))||((month==5)&&(day==30))||((month==6)&&(day==20))||((month==6)&&(day==27)
             -))  
1930              {
1931                DiaFestivo = True;
1932                }
1933              else if (((month==7)&&(day==4))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==15)
             -)||((month==10)&&(day==17))||((month==11)&&(day==7))||((month==11)&&(day==14))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
1934              {
1935                DiaFestivo = True;
1936              }
1937          
1938            
1939            
1940            }
1941            if ((dia_semana == Sabado)||(dia_semana == Domingo)||(DiaFestivo == True))
1942            {
1943              DiaFestivo = True;
1944            }
1945            else
1946            {
1947              DiaFestivo = False;
1948            }
1949            return DiaFestivo;
1950          }
1951          */
1952          /*
1953          unsigned char Dia_Pico_Placa(unsigned char * Atributos_Expedidor)
1954          {
1955            unsigned char Par_Impar;
1956            unsigned char dato;
1957            
1958            if( Festivos() == False)
1959            {
1960            dato=lee_clk(RDIA);
1961          
1962              if((dato % 2 == False) && (*(Atributos_Expedidor + Pico_Placa)  == True))
1963              {
1964              
1965              /*es par*/
1966          /*
1967              Par_Impar = True;
1968              
1969              }
1970              else
1971              {
1972              /*es impar */
1973              /*
1974              Par_Impar = False;
1975              }
1976            }
1977            else
1978            {
1979              Par_Impar = True;
1980            }
1981            return Par_Impar;
1982          }
1983          */
1984          unsigned char Horarios(unsigned char * Atributos_Expedidor)
1985          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 34  

1986   1        unsigned char Estado_Horario;
1987   1        
1988   1        unsigned char Addr_horarios [11];
1989   1        unsigned char dia_semana,EE_dia_semana;
1990   1        unsigned int addr;
1991   1        if (*(Atributos_Expedidor + Horario) != False )
1992   1        {
1993   2          /*se Lee la direccion del horario*/
1994   2          strcpy (Addr_horarios,(Addr_Horarios()));
1995   2          
1996   2          addr= Addr_horarios[(*(Atributos_Expedidor + Horario)) -1] ;
1997   2          
1998   2           /*leemos si esta habilitado*/
1999   2          
2000   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
2001   2          {
2002   3            /*miramos si el dia de la semana esta habilitado*/
2003   3            dia_semana = lee_clk(RDIA_SEMANA);
2004   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
2005   3            Debug_chr_Tibbo(dia_semana);
2006   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
2007   3            
2008   3          
2009   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
2010   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
2011   3            Debug_chr_Tibbo(EE_dia_semana);
2012   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
2013   3          
2014   3            if ( EE_dia_semana == dia_semana)
2015   3            {
2016   4              /*miramos si esta en el rango del horario*/
2017   4              Estado_Horario = Bloque_Horario(addr);
2018   4            }
2019   3            else
2020   3            {
2021   4      
2022   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
2023   4              Estado_Horario= False;
2024   4            }
2025   3          }
2026   2          else 
2027   2          {
2028   3            
2029   3            Estado_Horario= False;
2030   3            PantallaLCD(HORARIO_NO_PROG);
2031   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
2032   3            
2033   3          }
2034   2          
2035   2        }
2036   1        else
2037   1        {
2038   2          Estado_Horario = True;
2039   2        
2040   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
2041   2        }
2042   1        return Estado_Horario;
2043   1      }
2044          unsigned int Hora_Maxima(unsigned int addr)
2045          {
2046   1        unsigned char Hora_High,  Minuto_High;
2047   1        unsigned char HoraIni , MinutoIni; 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 35  

2048   1        unsigned int  Hora_Prog;
2049   1        
2050   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
2051   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
2052   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
2053   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
2054   1         Debug_chr_Tibbo(HoraIni);
2055   1         Debug_chr_Tibbo(MinutoIni);
2056   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
2057   1        
2058   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
2059   1      }
2060          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
2061          {
2062   1        unsigned char Estado_Horario; 
2063   1        
2064   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
2065   1        {
2066   2          
2067   2          /*hasta la hora que puede ingresar el vehiculo */
2068   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
2069   2          Hora_Prog = Hora_Maxima(addr+4);
2070   2      
2071   2        
2072   2          if( HoraNow <= Hora_Prog)
2073   2          {
2074   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2075   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
2076   3            Estado_Horario = True;
2077   3          }
2078   2          else
2079   2          {
2080   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2081   3            //PantallaLCD(MENSUAL_FUERA_HORARIO);
2082   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
2083   3            Estado_Horario = False;
2084   3          }
2085   2          
2086   2        }
2087   1        else
2088   1        {
2089   2              //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2090   2              //PantallaLCD(MENSUAL_FUERA_HORARIO);
2091   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
2092   2              Estado_Horario = False;
2093   2            
2094   2        }
2095   1        return Estado_Horario;
2096   1      }
2097          
2098          unsigned Bloque_Horario(unsigned int addr)
2099          {
2100   1        unsigned char Estado_Horario; 
2101   1        unsigned int HoraNow, Hora_Prog;
2102   1        
2103   1        /*la hora del momento de entrada del vehiculo*/
2104   1        
2105   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
2106   1        Debug_chr_Tibbo(lee_clk(RHORA));
2107   1        Debug_chr_Tibbo(lee_clk(RMIN));
2108   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
2109   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 36  

2110   1        
2111   1        /* desde la hora en que puede ingresar vehiculo */
2112   1        
2113   1        
2114   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
2115   1        Hora_Prog = Hora_Maxima(addr);
2116   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
2117   1        if(Estado_Horario == False )
2118   1        {
2119   2          
2120   2            
2121   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
2122   2            {
2123   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
2124   3              Hora_Prog = Hora_Maxima(addr+10);
2125   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
2126   3            }
2127   2            else
2128   2            {
2129   3              send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2130   3              PantallaLCD(MENSUAL_FUERA_HORARIO);
2131   3              Estado_Horario = False;
2132   3            }
2133   2        }
2134   1      
2135   1      return Estado_Horario;
2136   1      }
2137          
2138          /*------------------------------------------------------------------------------
2139          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
2140          
2141          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
2142          ------------------------------------------------------------------------------*/
2143          
2144          
2145          unsigned char  Secuencia_inicio_expedidor(void)
2146          {
2147   1        char temp;
2148   1        switch (Estado)
2149   1        {
2150   2          case INICIA_LINTECH:
2151   2      
2152   2                
2153   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
2154   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
2155   2              
2156   2            
2157   2            return (Estado);
2158   2          break;
2159   2      
2160   2      
2161   2      /*------------------------------------------------------------------------------
2162   2      Envia la primera trama de inicializacion del transporte sin movimiento
2163   2            (0) LA RESPUESTA ES OK
2164   2            (1) NO RESPONDE EL PTO SERIE
2165   2            (2) NO RECIBIDO LA TRAMA 
2166   2            (3) ERROR DE TRAMA CMD (N)
2167   2      ------------------------------------------------------------------------------*/
2168   2            
2169   2          case SEQ_CAPTURE_DATOS_INI:
2170   2      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 37  

2171   2            if((temp=Trama_Validacion_P_N())!=0)
2172   2          {
2173   3            if(temp==2)
2174   3            {
2175   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
2176   4            } 
2177   3            else if (temp==3)
2178   3            {
2179   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
2180   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2181   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2182   4            }
2183   3            else
2184   3            {
2185   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2186   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
2187   4            }
2188   3          }
2189   2          else
2190   2          {
2191   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
2192   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2193   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
2194   3          }     
2195   2          return (Estado);
2196   2          break;
2197   2            
2198   2      /*------------------------------------------------------------------------------
2199   2      Envia el cmd de grabar claves a la eeprom del transporte 
2200   2      ------------------------------------------------------------------------------*/
2201   2            
2202   2            case GRABA_EEPROM:
2203   2              
2204   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
2205   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
2206   2            
2207   2            
2208   2      
2209   2            return (Estado);
2210   2              break;
2211   2        
2212   2      /*------------------------------------------------------------------------------
2213   2      se analiza la respuesta 
2214   2            (0) LA RESPUESTA ES OK
2215   2            (1) NO RESPONDE EL PTO SERIE
2216   2            (2) NO RECIBIDO LA TRAMA 
2217   2            (3) ERROR DE TRAMA CMD (N)
2218   2      ------------------------------------------------------------------------------*/
2219   2            
2220   2          case SEQ_CAPTURA_OK_EEPROM:
2221   2          
2222   2          if((temp=Trama_Validacion_P_N())!=0)
2223   2          {
2224   3            if(temp==2)
2225   3            {
2226   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
2227   4            }
2228   3            else if (temp==3)
2229   3            {
2230   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 38  

             -a incorrecta falla en la escritura de la clave*/
2231   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2232   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2233   4            }     
2234   3            else
2235   3            {
2236   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2237   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
2238   4            }       
2239   3          }
2240   2          else
2241   2          {
2242   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
2243   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2244   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
2245   3          }     
2246   2      
2247   2          return (Estado);
2248   2          break;
2249   2      
2250   2      /*------------------------------------------------------------------------------
2251   2      Fin de la secuencia de comandos con exito 
2252   2      ------------------------------------------------------------------------------*/    
2253   2            
2254   2              case FIN_OK:
2255   2      
2256   2              return (Estado);
2257   2          break;
2258   2            
2259   2                
2260   2              default:
2261   2              return Estado=INICIA_LINTECH; 
2262   2              break;
2263   2        }
2264   1      }
2265          
2266          /*------------------------------------------------------------------------------
2267          Prosedimiento  q hace paso a paso la secuencia de la MF
2268          atributos
2269          ValTimeOutCom = tiempo que  espera para recibir datos pto serie
2270          Tarjeta_on = detecto vehiculo en loop y tiene tarjeta en boca
2271          g_cEstadoComSeqMF = nos dice en el estado que nos encontramos dentro del seguimiento
2272          ------------------------------------------------------------------------------*/
2273          
2274          unsigned char SecuenciaExpedidorMF( unsigned char EstadoActivo)
2275          {
2276   1        static unsigned char Buffer_Write_MF[17];
2277   1        static unsigned char Atributos_Expedidor[15];
2278   1        static unsigned char Secuencia_Expedidor[4];
2279   1        static unsigned char Nombre_Mensual[17];
2280   1        
2281   1        switch (EstadoActivo)
2282   1        {
2283   2      //***********************************************************************************************
2284   2          
2285   2          case SEQ_INICIO:
2286   2      
2287   2            if ((ValTimeOutCom==True)|| (ValTimeOutCom > TIME_CARD))
2288   2            {
2289   3              lock=OFF;                                                                                   /*rele de disparo a la barrera*/
2290   3              Rele_Atasco=OFF;                                                                           /*activo el rele de reset del verificador logica
             - negativa*/    
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 39  

2291   3              Check_Status(SENSOR_NORMAL);                                                              /* se pregunta al transporte en q estado es
             -tan las TI*/
2292   3              EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_
             -TRANSPORTE);
2293   3              Secuencia_Expedidor [ TareadelCmd  ] = TAREA_PRESENCIA_VEHICULAR;
2294   3            }
2295   2            break;
2296   2          case  SEQ_CMD_ACEPTADO:
2297   2          /*cmd comun para todos*/
2298   2            EstadoActivo=rta_cmd_transporte(Secuencia_Expedidor);
2299   2            break;
2300   2          case SEQ_MOVER_CARD_RF:
2301   2            Mov_Card(MovPos_RF);
2302   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_TIPO_CARD);
2303   2            break;
2304   2          case SEQ_CARD_INSERCION_ON:
2305   2            Card_Insercion(Habilita); 
2306   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2307   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_MENSUAL;
2308   2            break;
2309   2          case SEQ_TIPO_CARD:
2310   2            Aut_Card_check_Status();
2311   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2312   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_TARJETA;
2313   2            break;
2314   2          case SEQ_LOAD_PASSWORD:
2315   2            LoadVerify_EEprom();
2316   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECTOR
             -_BLOQUE);
2317   2            Atributos_Expedidor [ Sector ]    = Sector_1;
2318   2            Atributos_Expedidor [ Bloque ]    = Bloque_1;
2319   2            break;
2320   2          case SEQ_READ_SECTOR_BLOQUE:
2321   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
2322   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2323   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
2324   2            break;
2325   2          case SEQ_WRITE_SECTOR_BLOQUE:
2326   2            WR_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ],Buffer_Write_MF);
2327   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2328   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_WRITE_TARJETA_SECTOR_BLOQUE;
2329   2            break;
2330   2          case SEQ_CAPTURE_CARD:
2331   2            Mov_Card(MovPos_Capture);
2332   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);     
             -//SEQ_INICIOSEQ_MOVER_CARD_RF
2333   2            break;
2334   2          case SEQ_CARD_INSERCION_OFF:
2335   2            Card_Insercion(Inhabilita);
2336   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_EXPULSAR_CA
             -RD);
2337   2            break;
2338   2          case SEQ_EXPULSAR_CARD:
2339   2            Mov_Card(MovPos_Front);//MovPos_EjectFront
2340   2            MenSual = False;
2341   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);    
2342   2            break;
2343   2          case SEQ_FRONT_CARD:
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 40  

2344   2            Mov_Card(MovPos_Front);
2345   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_DETAIL_CAR
             -D);    
2346   2            break;
2347   2          case SEQ_DETAIL_CARD:
2348   2            Check_Status(SENSOR_DETAIL);
2349   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);    
2350   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_OPEN_BARRERA;
2351   2            break;
2352   2          case SEQ_LOAD_EEPROM:
2353   2            Dwload_EEprom();
2354   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECT
             -OR_BLOQUE);  
2355   2            break;
2356   2          case SEQ_ESPERA_VEHICULO_ENTRE:
2357   2            MenSual = False;
2358   2            EstadoActivo = Entrega_Card_Captura();
2359   2            break;
2360   2          case SEQ_PTO_PARALELO:
2361   2            EstadoActivo = Send_Pto_Paralelo(Atributos_Expedidor);
2362   2            
2363   2            break;
2364   2          case SEQ_WAIT_PLACA:
2365   2            EstadoActivo = Wait_Placa(Atributos_Expedidor,Buffer_Write_MF); //Secuencia_Expedidor,EstadoActivo
2366   2            break;
2367   2          case SEQ_UID: 
2368   2            Unique_Identifier_UID();
2369   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);    
2370   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_UID ;
2371   2            break;
2372   2          case SEQ_LPR:
2373   2            EstadoActivo = Pregunta_Lpr(Atributos_Expedidor);
2374   2            break;
2375   2          case SEQ_TIPO_TARJETAS:
2376   2            EstadoActivo = Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);;
2377   2            break;
2378   2          case SEQ_CAPTURE_CARD_LOOP:
2379   2            Mov_Card(MovPos_Capture);
2380   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);     //SEQ_INICIOSEQ_MOVER_CARD_RF TAREA_PRESENCIA_ROTACION
2381   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_PRESENCIA_ROTACION;
2382   2            break;
2383   2          case SEQ_POWER_OFF:
2384   2            Power_off();
2385   2              EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_UID);
2386   2            break;
2387   2          case SEQ_POWER_ON:
2388   2            Power_off();
2389   2              EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_LOAD_PAS
             -SWORD);
2390   2            break;
2391   2          case SEQ_SECOND_PASSWORD:
2392   2            Clave_Seguridad_S2();
2393   2              EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUEST
             -A_TRANSPORTE);
2394   2              Secuencia_Expedidor [TareadelCmd]  = TAREA_WRITE_PLACA_CARD;
2395   2            break;
2396   2      /*------------------------------------------------------------------------------
2397   2          Tareas especificas de cada paso
2398   2      ------------------------------------------------------------------------------*/      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 41  

2399   2          case SEQ_RESPUESTA_TRANSPORTE:
2400   2            ValTimeOutCom=TIME_WAIT;
2401   2            if (Secuencia_Expedidor [TareadelCmd]==TAREA_PRESENCIA_VEHICULAR)
2402   2            {
2403   3            EstadoActivo=Responde_Estado_Sensores_Transporte(); 
2404   3              ValTimeOutCom=TIME_WAIT;
2405   3            
2406   3            }
2407   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_TIPO_TARJETA)
2408   2                {
2409   3                  
2410   3                  EstadoActivo=Responde_Tipo_Tarjeta();
2411   3                }
2412   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_LECTURA_TARJETA_SECTOR_BLOQUE)
2413   2                {
2414   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2415   3                  {
2416   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque1 (Atributos_Expedidor);
2417   4                  }
2418   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2419   3                  {
2420   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque0 (Nombre_Mensual);
2421   4                  }
2422   3                  else
2423   3                  {
2424   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque2(Atributos_Expedidor);
2425   4                  }
2426   3                }
2427   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_WRITE_TARJETA_SECTOR_BLOQUE)
2428   2                { 
2429   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_2))
2430   3                  { 
2431   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor,Buffer_Write_MF);
2432   4                  }
2433   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_2)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2434   3                  {
2435   4                    EstadoActivo=Responde_Write_Tarjeta_Sector2_Bloque0(Buffer_Write_MF);
2436   4                  }
2437   3                    else if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2438   3                  {
2439   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque1(Buffer_Write_MF);
2440   4                  }
2441   3                  else
2442   3                  {
2443   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque0 (Buffer_Write_MF);
2444   4                  }
2445   3                }
2446   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_OPEN_BARRERA)
2447   2                {   
2448   3                  EstadoActivo = Disparo_Lock_Entrada_Vehiculo(Nombre_Mensual);
2449   3                }
2450   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_WRITE_PLACA_CARD)
2451   2                {   
2452   3                  EstadoActivo = Respuesta_Segunda_clave(Atributos_Expedidor,Buffer_Write_MF);
2453   3                }
2454   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_TIPO_MENSUAL) 
2455   2                {
2456   3                  EstadoActivo = Analiza_Presencia_Mensual();
2457   3                }
2458   2                
2459   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_UID ) 
2460   2                {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/04/2020 15:18:02 PAGE 42  

2461   3                  EstadoActivo = Analiza_Uid_Card(Atributos_Expedidor);
2462   3                } 
2463   2      
2464   2      
2465   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_PRESENCIA_ROTACION  ) 
2466   2                {
2467   3                  EstadoActivo = Analiza_Presencia_rotacion();
2468   3                }   
2469   2            else
2470   2                {
2471   3                  Debug_txt_Tibbo((unsigned char *) "TAREA_3\r\n");
2472   3                }
2473   2            break;
2474   2          default:
2475   2          EstadoActivo = SEQ_INICIO;  
2476   2          break;  
2477   2            
2478   2        } 
2479   1        return EstadoActivo;
2480   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7924    ----
   CONSTANT SIZE    =   1933    ----
   XDATA SIZE       =    138     256
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
