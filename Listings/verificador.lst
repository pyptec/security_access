C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          
  12          
  13          extern void send_portERR(unsigned char cod_err);
  14          
  15          
  16          
  17          
  18          extern void PantallaLCD(unsigned char cod_msg);
  19          
  20          //extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  21          
  22          
  23          /*funciones prototipo de clock*/
  24          
  25          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  26          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  27          void Block_read_clock_ascii(unsigned char *datos_clock);
  28          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  29          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l);
  30          extern char check_fechaOut(char *buffer);
  31          extern char lee_clk (unsigned char dir_clk);
  32          extern unsigned char bcd_hex (unsigned char l_data);
  33          
  34          extern void Cmd_Lpr_Int();
  35          extern void Delay_10ms(unsigned int cnt);
  36          
  37          /*funciones prototipo string */
  38          
  39          extern char  *strcat  (char *s1, const char *s2);
  40          extern char  *strcpy  (char *s1, const char *s2);
  41          extern unsigned int strlen  (const char *);
  42          
  43          /*funciones prototipo de EEprom*/
  44          
  45          extern unsigned char *Lee_No_Ticket();
  46          void Incremente_Ticket();
  47          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  48          
  49          /*funciones prototipo del transporte MODULO io_sensores*/
  50          
  51          extern unsigned char  ValidaSensoresPaso(void);
  52          unsigned char Valida_Sensor1_Auto();
  53          extern unsigned char Dir_board();
  54          extern void sel_Pulsa(void);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 2   

  55          void sel_Sensor2(void);
  56          char ValidaSensor(void);
  57          
  58          /*funciones prototipo del transporte MODULO TIBBO*/
  59          
  60          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  61          extern void Debug_txt_Tibbo(unsigned char * str);
  62          extern void Debug_chr_Tibbo(unsigned char Dat);
  63          extern void Debug_HexDec(unsigned char xfc);
  64          
  65          /*funciones prototipo del transporte MODULO LINTECH*/
  66          
  67          extern void Aut_Card_check_Status(void);
  68          extern void Check_Status(unsigned char Detalle);
  69          extern void Dwload_EEprom (void);
  70          extern void Mov_Card(unsigned char Posicion);
  71          extern void Card_Insercion(char Tipo);
  72          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  73          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);  
  74          extern void LoadVerify_EEprom(void);
  75          extern void Clave_Seguridad_S2(void);
  76          extern void Unique_Identifier_UID(void);
  77          
  78          /*funcion prototipo monitor*/
  79          
  80          extern void clear_placa();
  81          extern void Rx_Monitor();
  82          
  83          /*funcion prototipo pto paralelo*/
  84          
  85          void  send_port(unsigned char *buffer_port, unsigned char length_char);
  86          
  87          /*funcion prototipo programacion*/
  88          extern unsigned char *Addr_Horarios();
  89          
  90          extern int    atoi (const char *s1);
  91          /*io sensores */
  92          
  93          sbit DataIn = P1^1;         //  dato de las entradas    
  94          sbit sel_A = P3^5;          //Pulsador                        *
  95          sbit sel_B = P3^6;          //Entrada Sensor 2                    *
  96          sbit sel_C = P3^7;          //Entrada Sensor 1                    *
  97          
  98          sbit lock = P1^7;           //Relevo  
  99          sbit Rele_Atasco = P0^3;        //Rele de on/off del verificador o transporte
 100          sbit led_err_imp = P0^2;      //Error   
 101          
 102          /*pines de ip tibbo*/
 103          
 104          sbit rx_ip = P0^0;    
 105          /*variables externas*/
 106          
 107          extern unsigned char g_cEstadoComSoft;
 108          extern unsigned char ValTimeOutCom;
 109          extern unsigned char g_cContByteRx;
 110          extern unsigned char xdata Buffer_Rta_Lintech[];
 111          
 112          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
 113          extern unsigned char Timer_wait;
 114          extern unsigned int  SIN_COBRO;
 115          extern unsigned char  Tarjeta_on;
 116          extern unsigned char cnt__ask_off;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 3   

 117          extern  unsigned char Tipo_Vehiculo;
 118          extern  unsigned char  Debug_Tibbo;                                                   /*variable q define expedicion de tarjetas 1=
             - automatico 0= a boton configurable en eeprom*/
 119          extern unsigned char placa[];
 120          /*externo bit*/
 121          
 122          extern bit aSk;
 123          extern bit buffer_ready;
 124          extern bit placa_ready;
 125          
 126          /*----------------------------------------------------------------------------
 127          Definiciones de sequencias de verificador y expedidor
 128          ------------------------------------------------------------------------------*/
 129          
 130          #define SEQ_INICIO                      0X00  
 131          #define SEQ_RESPUESTA_TRANSPORTE        0X01
 132          #define SEQ_CMD_ACEPTADO                0x02
 133          #define SEQ_MOVER_CARD_RF               0x03
 134          #define SEQ_CARD_INSERCION_ON           0x04
 135          #define SEQ_TIPO_CARD                   0X05
 136          #define SEQ_LOAD_PASSWORD               0X06
 137          #define SEQ_READ_SECTOR_BLOQUE          0X07
 138          #define SEQ_WRITE_SECTOR_BLOQUE         0X08
 139          #define SEQ_CAPTURE_CARD                0X09
 140          #define SEQ_CARD_INSERCION_OFF          0x0a
 141          #define SEQ_EXPULSAR_CARD               0x0b
 142          #define SEQ_LOAD_EEPROM                 0x0c
 143          #define SEQ_FRONT_CARD                  0x0d
 144          #define SEQ_ESPERA_VEHICULO_ENTRE       0x0e
 145          #define SEQ_DETAIL_CARD                 0x0f
 146          #define SEQ_PTO_PARALELO                0x10
 147          #define SEQ_WAIT_PLACA                  0x11
 148          #define SEQ_UID                         0X12
 149          #define SEQ_LPR                         0X13  
 150          #define SEQ_TIPO_TARJETAS               0X14    
 151          
 152          /*----------------------------------------------------------------------------
 153          Definiciones de sequencias de tareas del verificador y expedidor
 154          ------------------------------------------------------------------------------*/
 155          #define TAREA_PRESENCIA_VEHICULAR             0X00  
 156          #define TAREA_TIPO_TARJETA                    0X01
 157          #define TAREA_LECTURA_TARJETA_SECTOR_BLOQUE   0x02
 158          #define TAREA_WRITE_TARJETA_SECTOR_BLOQUE     0X03
 159          #define TAREA_OPEN_BARRERA                    0X04
 160          #define TAREA_WRITE_PLACA_CARD                0x05
 161          #define TAREA_TIPO_MENSUAL                    0x06
 162          #define TAREA_UID                             0X07
 163          
 164          /*----------------------------------------------------------------------------
 165           definiciones de lintech en la inicializacion de expedidor o verificador
 166          ------------------------------------------------------------------------------*/
 167          
 168          #define INICIA_LINTECH          0x30
 169          #define SEQ_CAPTURE_DATOS_INI   0x31
 170          #define GRABA_EEPROM            0x32
 171          #define SEQ_CAPTURA_OK_EEPROM   0X33
 172          #define FIN_OK                  0x00
 173          
 174          
 175          #define True                    0x01
 176          #define False                   0x00
 177          /*----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 4   

 178           Definicion de datos asociados al buffer de resetcion del dato del trnasporte 
 179          
 180          ------------------------------------------------------------------------------*/
 181          
 182          
 183          #define ON    1
 184          #define OFF   0
 185          /*----------------------------------------------------------------------------
 186           ERRORES pto serie 
 187          
 188          ------------------------------------------------------------------------------*/
 189          #define REENVIA_TRAMA     0
 190          #define ESPERA_MAS_TIEMPO 1
 191          /*----------------------------------------------------------------------------
 192           definiciones de lintech en la inicializacion de expedidor o verificador
 193           funcion usada en lintech que me debuelve la respuesta de comunicacion del expedidor
 194           o verificador Trama_Validacion_P_N()
 195          RSPT_TRP_OK             (0) respuesta_transporte_oksignifica que la trama es valida y continua en el proceso
 196          NO_RSPD_TRP_PTO_COM     (1) no_responde_trasnporte_pto_com se cumple el tiempo de espera
 197          ESPR_RSPT_TRP_TRAMA     (2)Espera_respuesta_transporte_trama
 198          ERROR_TRP_TRAMA         (3) error_transpote_trama
 199          ------------------------------------------------------------------------------*/
 200          #define   RSPT_TRP_OK           0
 201          #define   NO_RSPD_TRP_PTO_COM   1
 202          #define   ESPR_RSPT_TRP_TRAMA   2
 203          #define   ERROR_TRP_TRAMA       3
 204          
 205          
 206          /*----------------------------------------------------------------------------
 207           definiciones de lintech en el comando Check_Status
 208          ------------------------------------------------------------------------------*/
 209          
 210          #define SENSOR_DETAIL       0x31
 211          #define SENSOR_NORMAL       0x30
 212          
 213          /*------------------------------------------------------------------------------
 214           definiciones de lintech en el comando Card_Insercion
 215          ------------------------------------------------------------------------------*/
 216          
 217          #define Habilita        0x30
 218          #define Inhabilita      0x31
 219          
 220          /*------------------------------------------------------------------------------
 221          Definicion de Lintech en el comando Inicializa
 222          ------------------------------------------------------------------------------*/
 223          
 224          #define TO_FRONT        '0'
 225          #define CAPTURE_BOX     '1'
 226          #define SIN_MOVIMIENTO  '3'
 227          
 228          /*------------------------------------------------------------------------------
 229          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 230          MovPos_Front        '0'   -> mueve  tarjeta al frente pero no la suelta
 231          MovPos_IC           '1'   ->mueve la tarjeta en posicion de read/write IC
 232          MovPos_RF           '2'   ->mueve tarjeta a RF card read/write
 233          MovPos_Capture      '3'   ->captura la tarjeta
 234          MovPos_EjectFront   '9'   ->lanza la tarjeta del mecanismo
 235          
 236          ------------------------------------------------------------------------------*/
 237          
 238          #define   MovPos_Front        '0'   
 239          #define   MovPos_IC           '1'
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 5   

 240          #define   MovPos_RF           '2'
 241          #define   MovPos_Capture      '3'
 242          #define   MovPos_EjectFront   '9'
 243          
 244          /*------------------------------------------------------------------------------
 245          Definicion de la trama Lintech de las respuestas de los cmd
 246          ------------------------------------------------------------------------------*/
 247          
 248          #define Pos_Length          3
 249          #define Pos_TipoResp        4
 250          #define Pos_St0             7
 251          #define Pos_St1             8
 252          #define Pos_St2             9
 253          #define Pos_IniDatMF        0x0a
 254          #define Card_type_H         0x0a
 255          #define Card_type_L         0x0b
 256          /*------------------------------------------------------------------------------
 257          Definicion del estado de st0,st1,st2 de la trama Lintech 
 258          NO_CARDS_IN_MCNSM -> No tiene tarjetas en el mecanismo      sto=0
 259          CARD_IN_MOUTH     -> hay una tarjeta dentro del bessel      st0=1
 260          CARD_OK_READ_RF   -> Tarjeta en posicion para leer/escribir dentro del mecanismo st0=2
 261          NO_HAVE_CARDS     -> no tiene tarjetas en el deposito st1=0
 262          LOW_NIVEL_CARDS   -> nivel bajo de tarjetas en el deposito  st1=1
 263          FULL_CARD         -> Deposito de tarjetas esta lleno        st1=2
 264          ------------------------------------------------------------------------------*/
 265          
 266          
 267          #define NO_CARDS_IN_MCNSM   '0'
 268          #define CARD_IN_MOUTH       '1'
 269          #define CARD_OK_READ_RF     '2'
 270          #define NO_HAVE_CARDS       '0'
 271          #define LOW_NIVEL_CARDS     '1'
 272          #define FULL_CARD           '2'
 273          /*----------------------------------------------------------------------------
 274          Comprobacion automatica del tipo de tarjeta 
 275          checking RF card type
 276          Card_type_H   Card_type_L  explicacion
 277              0             0           tarjeta desconocida
 278              1             0           MF50
 279              1             1           MF70
 280              1             2           MF_UL
 281              2             0           TYPE_A_CPU
 282          ------------------------------------------------------------------------------*/
 283          #define MF50_HIGH             '1'
 284          #define MF50_LOW              '0'
 285          
 286          /*----------------------------------------------------------------------------
 287          definicion de recepcion serial 
 288          ------------------------------------------------------------------------------*/
 289          
 290          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 291          
 292          /*----------------------------------------------------------------------------
 293          tiempo de delay entre funciones
 294          ------------------------------------------------------------------------------*/
 295          
 296          #define   TIME_CARD         100   //50
 297          #define   TIME_WAIT         18
 298          /*----------------------------------------------------------------------------
 299          definicion de datos de trama lintech
 300          ------------------------------------------------------------------------------*/
 301          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 6   

 302          //#define   ETX               03
 303          #define   STX_LINTECH       0xf2
 304          
 305          /*----------------------------------------------------------------------------
 306          msj de lcd tarjeta y lcd serie
 307          ------------------------------------------------------------------------------*/
 308          
 309          #define ERROR_LOOP              0XE0
 310          #define TARJETA_INVALIDA        0XE1
 311          #define ERROR_MF1               0XE2
 312          #define TARJETA_SIN_FORMATO     0xDF
 313          #define ERROR_COD_PARK          0XE5
 314          #define SIN_INGRESO             0XE6
 315          #define SIN_PAGO                0XE7
 316          #define EXCEDE_GRACIA           0XE8
 317          #define SIN_SALIDA              0XE9
 318          #define ERROR_TIPO_VEHICULO     0XF8
 319          #define GRACIAS                 0XFF
 320          #define TARJETA_VENCIDA         0XEC
 321          
 322          #define NO_CARD_MENSUAL         0XFC
 323          
 324          #define NO_CARD                 0xFA  
 325          #define LOW_CARD                0x01
 326          #define ATASCADO                0x02
 327          #define AUDIO_ENTRADA     0XA0
 328          #define AUDIO_CAJA        0XA1
 329          #define AUDIO_GRACIAS     0XA2
 330          /*----------------------------------------------------------------------------
 331          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 332          ------------------------------------------------------------------------------*/
 333          
 334          #define   ENVIADOS          0X0
 335          #define   RESPUESTA         0X01
 336          /*
 337          definicion  de daos del reloj
 338                    */
 339          
 340          #define RDIA            0x87
 341          #define RMES            0x89
 342          #define RANO            0x8D
 343          #define RDIA_SEMANA     0x8B
 344          #define RHORA           0x85
 345          #define RMIN            0x83
 346          #define Sabado          7
 347          #define Domingo         1
 348          /*----------------------------------------------------------------------------
 349          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 350          (0) si el dato es cero esta inactiva
 351          (1) activa o ROTACION
 352          (2) mensualidad
 353          ------------------------------------------------------------------------------*/
 354          enum Tipos_MF_TIPO_TARJETA{
 355            INACTIVA,         
 356            ROTACION,           
 357            MENSUALIDAD,
 358            PREPAGO,
 359            CORTESIA,
 360            LOCATARIO,
 361            TARJETA_PERDIDA = 0X10,
 362            INHABILITADA = 0X11
 363          };
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 7   

 364          /*----------------------------------------------------------------------------
 365          posicion de  MF  bloque 1 sector 1
 366          (0) tipo de tarjeta 
 367          (01) el id del cliente
 368          (03)codigo del parqueadero  
 369          ------------------------------------------------------------------------------*/
 370          #define   MF_TIPO_TARJETA   0X00
 371          #define   MF_COD_PARK       0x01      //MF_ID_CLIENTE
 372          #define   MF_ID_CLIENTE     0x03      //MF_COD_PARK
 373          
 374          /*----------------------------------------------------------------------------
 375          posicion de  MF bloque 2 sector 1
 376          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 377          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 378          ------------------------------------------------------------------------------*/
 379          
 380          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 381          
 382          
 383          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 384                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
 385          #define   MF_LSB            0x06
 386          
 387          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 388          
 389          #define   MF_IN_PAGO        0x09
 390          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 391          
 392          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 393          
 394          #define   MF_MENSUAL_ANO      0X05
 395          #define   MF_MENSUAL_MES      0X06
 396          #define   MF_MENSUAL_DIA      0X07
 397          
 398          #define   MF_UID_0      0X04
 399          #define   MF_UID_1      0X05
 400          #define   MF_UID_2      0X06
 401          #define   MF_UID_3      0X07
 402          
 403          #define   MF_EXPIRA_ANO     0X08
 404          #define   MF_EXPIRA_MES     0X09
 405          #define   MF_EXPIRA_DIA     0X0A
 406          
 407          #define   HABILITA_ADDR     15
 408          #define   Segundo_Tiempo    16
 409          
 410          enum Hora_Minutos_addr{
 411            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 412            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 413          };
 414          
 415          enum Estados_Expedidor{
 416           EstadoActual,
 417           EstadoPasado,
 418           EstadoFuturo,
 419           TareadelCmd  
 420          };
 421          enum expedidor {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 8   

 422           Sector,        
 423           Bloque,        
 424           Tipo_Tarjeta,
 425           Apb,
 426           Horario,
 427           Pico_Placa,
 428           Type_Vehiculo,
 429           Uid_0,
 430           Uid_1,
 431           Uid_2,
 432           Uid_3,
 433           Expira_ano,
 434           Expira_mes,
 435           Expira_dia
 436           
 437          };
 438          /*tipos de APB antipassback*/
 439          enum Tipos_MF_APB{
 440            
 441            APB_INICIADO,       
 442            APB_INT,              
 443            APB_OUT,              
 444            APB_NO              
 445          };
 446          /*tipo de vehiculo*/
 447          /*Sectores y bloques de Mf*/
 448          enum MF_Sector_Bloque{
 449            Sector_0,
 450            Sector_1,
 451            Sector_2,
 452            Bloque_0 = 0,
 453            Bloque_1 = 1,
 454            Bloque_2 = 2
 455          };
 456          /*comandos pto paralelo*/
 457          enum CMD_Trama_Pto_Paralelo{
 458            STX=02,
 459            CMD_PTO_PARALELO_EXPEDIDOR='a',
 460            ETX= 03,
 461            NULL=0,
 462            CMD_MONITOR_EXPEDIDOR='E',
 463            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 464          };
 465          enum EE_AntiPassBack{
 466            APB_INHABILITADO_SOFT,
 467            APB_HABILITADO_SOFT
 468          };  
 469          enum Tipos_Vehiculos{
 470              AUTOMOVIL,          
 471              MOTO,
 472              BICICLETA
 473          };  
 474          
 475          /*DATOS DE CONFIGURACION EEPROM*/
 476          #define EE_ID_CLIENTE           0x0000
 477          #define EE_ID_PARK              0x0002
 478          #define EE_DEBUG                0x0008
 479          #define EE_USE_LPR              0x000A
 480          #define EE_CARD_AUTOMATIC_BOTON 0x000f
 481          #define EE_HABILITA_APB         0x0010
 482          #define EE_PLACA                0X0011
 483          #define EE_VALIDA_TIPO_VEHICULO_MENSUAL 0X0014
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 9   

 484          #define EE_HABILITA_APB_MENSUAL 0X0015
 485          
 486          /*----------------------------------------------------------------------------
 487          Definicion de varaibles globales del objeto
 488          ------------------------------------------------------------------------------*/
 489          
 490          static unsigned char Estado=INICIA_LINTECH;
 491          bit MenSual = False;
 492          /*------------------------------------------------------------------------------
 493          
 494          ------------------------------------------------------------------------------*/
 495          unsigned char Captura_Expulsa()
 496          {
 497   1        unsigned char Estado_expedidor;
 498   1        if(MenSual !=  True)
 499   1        {
 500   2          Estado_expedidor=SEQ_CAPTURE_CARD;                                        
 501   2        }
 502   1        else
 503   1        {
 504   2        
 505   2        Estado_expedidor = SEQ_EXPULSAR_CARD;//SEQ_CARD_INSERCION_OFF;  
 506   2        }   
 507   1      return  Estado_expedidor;
 508   1      }
 509          /*------------------------------------------------------------------------------
 510          funcion que valida la trama del verificador o transporte lintech
 511          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 512          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 513          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 514          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 515          
 516          
 517          ------------------------------------------------------------------------------*/
 518          
 519          char Trama_Validacion_P_N()
 520          {
 521   1        char Trama_Validacion_P_N=ESPR_RSPT_TRP_TRAMA;                                /*espera respuesta del transporte*/
 522   1            
 523   1            if ((ValTimeOutCom==1)||(buffer_ready==1) )
 524   1            {
 525   2              if (buffer_ready==1)
 526   2              {
 527   3                buffer_ready=0;
 528   3                  
 529   3              
 530   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 531   3                {
 532   4                          
 533   4                  Trama_Validacion_P_N=RSPT_TRP_OK;                                       /*trama ok*/
 534   4                    
 535   4                }
 536   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 537   3                {
 538   4                  
 539   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;                                 /*error de trama*/
 540   4                  
 541   4                }
 542   3                else
 543   3                {
 544   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 10  

 545   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;   
 546   4                  
 547   4                }
 548   3              }
 549   2              else
 550   2              {
 551   3                          
 552   3                Trama_Validacion_P_N=NO_RSPD_TRP_PTO_COM;                                 /*pto serie no responde */
 553   3                                                  
 554   3              }
 555   2      
 556   2            }
 557   1            
 558   1        return Trama_Validacion_P_N;
 559   1      }
 560          /*------------------------------------------------------------------------------
 561          funcion de error de respuesta pto serie
 562          
 563          variable en uart. cnt__ask_off=cuenta los numeros de error pto serie y reset de transporte 
 564          se limpia cuando llega la respuesta del transporte. 
 565          Rele_Atasco = es un I/O del Mc que activa / inhabilita el rele
 566          ON    (1) esta activo 
 567          OFF   (0) inhactivo 
 568          REENVIA_TRAMA   1
 569          ESPERA_MAS_TIEMPO 0
 570          cnt_espera_ask_on= cuenta el tiempo de ASK que esta activo,sin que le llegue
 571                             la trama completa, al  5 tiempos borra el ask y retrasmite el cmd
 572          
 573          error_rx_pto= (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 574                      = (1)= REENVIA_TRAMA reenvia la trama al transporte
 575          
 576          cnt__ask_off= varible global esta definida en pto serie y es un contador , que 
 577          se limpia cada vez que la trama a llegado completa y validada
 578          
 579          aSk= significa que llego al pto serie el 06 = ask donde el transporte dice que a recibido el cmd
 580          esta ejecutando y nos enviara la respuesta,necesita tiempo esta bit esta definino en el modulo uart es glo
             -bal
 581          
 582          ------------------------------------------------------------------------------*/
 583          unsigned char error_rx_pto(void)
 584          {
 585   1      
 586   1      static unsigned cnt_espera_ask_on=0;
 587   1      unsigned char error_rx_pto=ESPERA_MAS_TIEMPO;
 588   1      
 589   1          
 590   1                
 591   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 592   1            Debug_chr_Tibbo (cnt__ask_off); 
 593   1            Debug_chr_Tibbo (cnt_espera_ask_on);
 594   1            Debug_chr_Tibbo (error_rx_pto);
 595   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 596   1            if (aSk==OFF)
 597   1            
 598   1            { 
 599   2                cnt__ask_off++;                                                                   /*cuento el error*/                                                               
 600   2              if(cnt__ask_off>=10)
 601   2              {                                                                                   /*no contesta debe reset el transporte*/
 602   3                Rele_Atasco=ON;                                                                   /*off el rele de reset del verificador*/    
 603   3                Delay_10ms(110);
 604   3                cnt__ask_off=0;                                                                   /*limpio ls errores*/
 605   3                cnt_espera_ask_on=0;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 11  

 606   3                error_rx_pto=ESPERA_MAS_TIEMPO;                                                   /**/
 607   3                Rele_Atasco=OFF;  
 608   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 609   3                ValTimeOutCom=TIME_CARD;
 610   3              }
 611   2              else;
 612   2              {
 613   3                error_rx_pto=REENVIA_TRAMA;                                                       /*1 reenvia trama*/
 614   3                ValTimeOutCom=TIME_CARD;
 615   3              }
 616   2            }                                                                                     /*aSk esta activo */
 617   1            else
 618   1            {
 619   2                cnt_espera_ask_on++;                                                              /*cuento n tiempos de ask para recibir el total de
             - la trama*/
 620   2              if(cnt_espera_ask_on>=3)
 621   2              {
 622   3                cnt__ask_off=0;                                                                   /*paso tiempo de espera y no se completo la trama 
 623   3                                                                                                  limpio los reg y reenvio la trama y ask=off*/
 624   3                cnt_espera_ask_on=0;
 625   3                error_rx_pto=REENVIA_TRAMA;
 626   3                aSk=OFF;
 627   3                ValTimeOutCom=TIME_CARD;
 628   3              }
 629   2              else
 630   2              {
 631   3                cnt__ask_off=0;                                                                   /*damos tiempo de espera de la trama del transporte*
             -/
 632   3                error_rx_pto=ESPERA_MAS_TIEMPO;;
 633   3                ValTimeOutCom=TIME_CARD;
 634   3              }
 635   2            }
 636   1              return (error_rx_pto);
 637   1      }
 638          /*------------------------------------------------------------------------------
 639          Funcion de respuesta a los cmd del transporte
 640          Retorna rta_cmd_transporte el estado en que queda
 641          Recibe tres datos unos es el 
 642          Estado_futuro= significa que la respuesta fue ok
 643          Estado_Error= en caso de que aya un error a que estado envia el codigo
 644          Estado_Actua= No ha llegado la respuesta y sigue en el mismo estado
 645          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 646          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 647          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 648          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 649          
 650          (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 651          (1)= REENVIA_TRAMA reenvia la trama al transporte
 652          ------------------------------------------------------------------------------*/
 653          unsigned char   rta_cmd_transporte(unsigned char *secuencia_Expedidor )
 654          {
 655   1        unsigned char temp;
 656   1        unsigned char EstadoComSeqMF;
 657   1        
 658   1            
 659   1      if((temp=Trama_Validacion_P_N())!=RSPT_TRP_OK )
 660   1          {
 661   2            if(temp==ESPR_RSPT_TRP_TRAMA)                                                         /*no he recibido respuesta espero*/
 662   2            {
 663   3            EstadoComSeqMF= *(secuencia_Expedidor + EstadoActual);                    //                                  /*SEQ_RTA_CARD_POSno
             - ha respondido*/
 664   3            } 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 12  

 665   2            else if (temp==ERROR_TRP_TRAMA)
 666   2            {
 667   3            Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR\r\n\r\n");                     /* trama no valida respuesta inco
             -rrecta falla en la escritura */
 668   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 669   3            EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                         /*SEQ_INICIO (3) Tram
             -a invalida cmd (N)reenvio cmd*/ 
 670   3            }     
 671   2            else
 672   2            {
 673   3            /*Dispensador No Responde PTO SERIE ...*/
 674   3          
 675   3              if(temp=error_rx_pto()==ESPERA_MAS_TIEMPO)
 676   3              {
 677   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoActual); 
 678   4              }                                                                                     /*SEQ_RTA_CARD_POS;*/
 679   3              else                                                                                  //(temp=error_rx_pto()==REENVIA_TRAMA)
 680   3              {
 681   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                     /*SEQ_INICIO*/
 682   4              }                                                 
 683   3            }       
 684   2          }
 685   1          else
 686   1          {
 687   2            
 688   2            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);
 689   2            EstadoComSeqMF=*(secuencia_Expedidor + EstadoFuturo); 
 690   2          }
 691   1        return EstadoComSeqMF;
 692   1      }
 693          
 694          /*------------------------------------------------------------------------------
 695          ------------------------------------------------------------------------------*/
 696          unsigned char Analiza_Presencia_Mensual()
 697          {
 698   1        unsigned char Estado_expedidor;
 699   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 700   1          {
 701   2            MenSual = True;
 702   2            Estado_expedidor = SEQ_TIPO_CARD;                 //SEQ_UID
 703   2          }
 704   1        else
 705   1          { 
 706   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 707   2              
 708   2              Estado_expedidor = SEQ_EXPULSAR_CARD; 
 709   2          }
 710   1        return Estado_expedidor;
 711   1      }
 712          /*------------------------------------------------------------------------------
 713          Funcion numero unico de identificacion
 714          ------------------------------------------------------------------------------*/
 715          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor)
 716          {
 717   1        unsigned char Estado_expedidor;
 718   1        unsigned char temp;
 719   1        unsigned char buffer_UID[17];
 720   1          if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
 721   1            {
 722   2              
 723   2                for (temp=0; temp<16; ++temp)
 724   2                {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 13  

 725   3                  buffer_UID [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de M
             -F en un arreglo*/
 726   3                 
 727   3                }
 728   2                
 729   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
 730   2                DebugBufferMF(buffer_UID,16,RESPUESTA);
 731   2                
 732   2        
 733   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
 734   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_0]));  
 735   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_1]));  
 736   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_2]));  
 737   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_3]));
 738   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
 739   2                
 740   2              *(Atributos_Expedidor + Uid_0) = buffer_UID [MF_UID_0];   
 741   2              *(Atributos_Expedidor + Uid_1) = buffer_UID [MF_UID_1];     
 742   2              *(Atributos_Expedidor + Uid_2) = buffer_UID [MF_UID_2];     
 743   2              *(Atributos_Expedidor + Uid_3) = buffer_UID [MF_UID_3]; 
 744   2              Estado_expedidor=SEQ_LOAD_PASSWORD;                                                       //SEQ_TIPO_CARD;
 745   2            }   
 746   1            else
 747   1            {
 748   2              
 749   2              send_portERR(ERROR_MF1);
 750   2              Estado_expedidor=SEQ_EXPULSAR_CARD;
 751   2            } 
 752   1            return Estado_expedidor;
 753   1      }
 754          /*------------------------------------------------------------------------------
 755          Se analiza si expulsa la tarjeta por boton o automatica
 756          ------------------------------------------------------------------------------*/
 757          unsigned char Ingreso_Vehiculo(void)
 758            {
 759   1          unsigned char CardAutomatic;  
 760   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 761   1          {
 762   2            CardAutomatic=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);  
 763   2            
 764   2            if (CardAutomatic==True)                                                    //se pregunta si expide la tarjeta automatica o por p
             -resionar el boton
 765   2              {
 766   3                Debug_txt_Tibbo((unsigned char *) "Tarjeta: Automatico\r\n");           //expide tarjetas automatico con p
             -resencia
 767   3                                                                                        // muevo la tarjeta hasta el lector de rf
 768   3                Estado=SEQ_MOVER_CARD_RF;                                               // valido el cmd enviado al verificador
 769   3               }
 770   2            else
 771   2              {
 772   3                    sel_Pulsa();                                                        //se valida el pulsador en hardware
 773   3                    if (DataIn!=True)       
 774   3                      {
 775   4                        Debug_txt_Tibbo((unsigned char *) "Pulsador Activo\r\n");       //el pulsador fue presionado
 776   4                                                                                        //muevo tarjeta hasta el lector de RF
 777   4                        Estado=SEQ_MOVER_CARD_RF;                                       //valido el cmd enviado al verificador
 778   4                      }
 779   3                    else
 780   3                        {
 781   4                          Estado=SEQ_INICIO;  
 782   4                        }
 783   3                  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 14  

 784   3              } 
 785   2          }
 786   1          else
 787   1              { 
 788   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 789   2                Estado=SEQ_INICIO;  
 790   2              }
 791   1        return Estado;
 792   1      }
 793           
 794          /*------------------------------------------------------------------------------
 795          Se pregunta por el estado del expedidor si hay tarjetas y presencia para expulsar tarjeta
 796          o si hay tarjeta en la boca o rf para entrar en mensuales
 797          ------------------------------------------------------------------------------*/
 798          
 799          unsigned char Responde_Estado_Sensores_Transporte()
 800          {
 801   1        unsigned char Estado_expedidor;
 802   1          
 803   1            Debug_txt_Tibbo((unsigned char *) "TAREA_PRESENCIA_VEHICULAR\r\n");                                 // trama valida Hab
             -ilitado 
 804   1          
 805   1            if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                                 // CANAL LIBRE    no tiene 
             -tarjetas en el mecanismo
 806   1            {
 807   2                
 808   2              if  ((Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS)||(Buffer_Rta_Lintech[Pos_St1]==FULL_CARD  ))  //  se
             - detecta la tarjeta en la boca TARJETA EN BEZZEL
 809   2              {
 810   3                if (Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS  )                                             // nivel de tarjetas
 811   3                  {
 812   4                    Debug_txt_Tibbo((unsigned char *) "Nivel bajo de tarjetas\r\n");                            // nivel bajo de tarj
             -etas 
 813   4                    send_portERR(LOW_CARD);                                                                     //envio msj al primario
 814   4                    PantallaLCD('a');                                                                           //envio msj por la raspberry nivel bajo de t
             -arjetas
 815   4                    Estado_expedidor=Ingreso_Vehiculo();        
 816   4                   }
 817   3                   else
 818   3                      {
 819   4                        /*respuesta ok*/
 820   4                       Estado_expedidor=Ingreso_Vehiculo();
 821   4                      
 822   4                      }
 823   3              } 
 824   2              else 
 825   2                  {
 826   3                    /*dispensador no posee tarjetas*/
 827   3                    Debug_txt_Tibbo((unsigned char *) "Dispensador SIN TARJETAS...\r\n"); 
 828   3                    
 829   3                    send_portERR(NO_CARD);                                                                      // se envia msj al uC principal, visualiza
             - en el lcd que no hay tarjetas
 830   3                    Estado_expedidor=SEQ_INICIO;                                                                //inicio el loop
 831   3                   }
 832   2            }
 833   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
 834   1              {
 835   2                    /*hay una tarjeta en la boca del verificador */
 836   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                                //se envia msj al debug
             -er q hay tarjeta en la boca
 837   2                                                                                                                //se habilita recepcion de tarjetas por boca
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 15  

 838   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;                                                     //se trabaja mensual        
 839   2              }
 840   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
 841   1                  
 842   1              {
 843   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en RF\r\n");
 844   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;
 845   2              }
 846   1            else
 847   1              {
 848   2                Estado_expedidor=SEQ_INICIO;  
 849   2              }
 850   1        return Estado_expedidor;  
 851   1      }
 852          
 853          /*------------------------------------------------------------------------------
 854          Funcion que nos dice el tipo de tarjeta que tiene en el mecanismo
 855          Comprobacion automatica del tipo de tarjeta 
 856          checking RF card type
 857          Card_type_H   Card_type_L  explicacion
 858              0             0           tarjeta desconocida
 859              1             0           MF50
 860              1             1           MF70
 861              1             2           MF_UL
 862              2             0           TYPE_A_CPU
 863          
 864          #define MF50_HIGH             '1'
 865          #define MF50_LOW              '0'
 866          ------------------------------------------------------------------------------*/
 867          unsigned char Responde_Tipo_Tarjeta()
 868            {
 869   1          unsigned char Estado_expedidor;
 870   1          
 871   1            Debug_txt_Tibbo((unsigned char *) "TAREA_TIPO DE TARJETA\r\n");                         // trama valida Habilitado 
 872   1            
 873   1        if (Buffer_Rta_Lintech[Card_type_H]==MF50_HIGH)                                             /* pregunto si la tarjeta en el tra
             -nsporte es MF 50 */
 874   1          {
 875   2          if (Buffer_Rta_Lintech[Card_type_L]==MF50_LOW)  
 876   2            {
 877   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n");                         /* trama valida son MF50*/
 878   3              Estado_expedidor=SEQ_UID;                                                             //SEQ_LOAD_PASSWORD;                        
 879   3                                                                                      
 880   3            }
 881   2            else
 882   2              {
 883   3                 if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta e
             -n la boca TARJETA EN BEZZEL
 884   3                {
 885   4                Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");           /* trama no valida */
 886   4                send_portERR(AUDIO_GRACIAS);                                                              /*error audio*/ 
 887   4                send_portERR(TARJETA_INVALIDA);                                                             /*envio msj principal tarjeta invalidad
             -*/
 888   4                PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la raspbe
             -rry*/
 889   4                Estado_expedidor = Captura_Expulsa();     
 890   4                } 
 891   3                else  
 892   3                {
 893   4                  MenSual = False;
 894   4                  Estado_expedidor = SEQ_INICIO;    
 895   4                }           
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 16  

 896   3              }
 897   2          }
 898   1          else 
 899   1            {
 900   2               if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta en
             - la boca TARJETA EN BEZZEL
 901   2                {
 902   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");           /* trama no valida */
 903   3              send_portERR(AUDIO_GRACIAS);                                                              /*error audio*/ 
 904   3              send_portERR(TARJETA_INVALIDA);                                                             //la tarjeta no es valida 
 905   3              PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la raspber
             -ry*/
 906   3              Estado_expedidor = Captura_Expulsa();   
 907   3                }
 908   2                else  
 909   2                {
 910   3                  MenSual = False;
 911   3                  Estado_expedidor = SEQ_INICIO;    
 912   3                }                     
 913   2            }
 914   1                    
 915   1          return Estado_expedidor;                                                                                                  
 916   1        } 
 917          /*------------------------------------------------------------------------------
 918            Funcion que lee los datos en el Sector 1 Bloque 1
 919            se lee
 920            ID_CLIENTE
 921            COD_PARK
 922            TIPO DE TARJETA
 923            EXPIRA_ANO
 924            EXPIRA_MES
 925            EXPIRA_DIA
 926          ------------------------------------------------------------------------------*/
 927          
 928          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
 929          {
 930   1        unsigned char temp;
 931   1        unsigned char Estado_expedidor;
 932   1        unsigned char buffer_S1_B1[17];
 933   1        unsigned char ID_CLIENTE;
 934   1        unsigned char COD_PARK;   
 935   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE1\r\n");   
 936   1                                        
 937   1                                      
 938   1            
 939   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 940   1            {
 941   2              
 942   2                for (temp=0; temp<16; ++temp)
 943   2                {
 944   3                  buffer_S1_B1 [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de
             - MF en un arreglo*/
 945   3                 
 946   3                }
 947   2                
 948   2                
 949   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b1\r\n");
 950   2                DebugBufferMF(buffer_S1_B1,16,RESPUESTA);
 951   2                ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
 952   2                COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
 953   2                /*Compara  MF_ID_CLIENTE y MF_COD_PARK con el codigo del parqueadero ID_CLIENTE  COD_PARK*/
 954   2                
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 17  

 955   2                if (((buffer_S1_B1 [ MF_ID_CLIENTE])==ID_CLIENTE) && ((buffer_S1_B1 [ MF_COD_PARK] ) == COD_PARK)||((
             -ID_CLIENTE==0)&&(COD_PARK==0)))   
 956   2                {
 957   3                    
 958   3                  Debug_txt_Tibbo((unsigned char *) "CARD ID_CLIENTE: ");               
 959   3                  Debug_HexDec((buffer_S1_B1 [ MF_ID_CLIENTE]));
 960   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 961   3                  
 962   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");                
 963   3                  Debug_HexDec(ID_CLIENTE);
 964   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 965   3                  
 966   3                  Debug_txt_Tibbo((unsigned char *) "CARD COD_PARK:");                    
 967   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
 968   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
 969   3                  
 970   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");                   
 971   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
 972   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
 973   3      
 974   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
 975   3                  Debug_chr_Tibbo(buffer_S1_B1 [MF_TIPO_TARJETA]);
 976   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 977   3                  
 978   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S1_B1 [MF_TIPO_TARJETA];
 979   3                  /*fecha de vencimiento de mensual o prepago*/
 980   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S1_B1 [MF_EXPIRA_ANO];
 981   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S1_B1 [MF_EXPIRA_MES];
 982   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S1_B1 [MF_EXPIRA_DIA];
 983   3                  
 984   3                  *(Atributos_Expedidor + Sector) = Sector_1;
 985   3                  *(Atributos_Expedidor + Bloque) = Bloque_2;
 986   3                  
 987   3                  Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
 988   3              
 989   3                }
 990   2                else
 991   2                {
 992   3                  Debug_txt_Tibbo((unsigned char *) "ERROR COD PARK\r\n");
 993   3                  send_portERR(ERROR_COD_PARK);
 994   3                  PantallaLCD(ERROR_COD_PARK);                                                        //envio el msj por la pantalla lcd o la rasp
             -berry
 995   3                  Estado_expedidor = Captura_Expulsa();                                                 //   codigo de parqueo erro expulso la 
             -tarjeta     
 996   3                }
 997   2            }
 998   1            else
 999   1            {
1000   2              Debug_txt_Tibbo((unsigned char *) "TARJETA SIN FORMATO\r\n");
1001   2              send_portERR(TARJETA_SIN_FORMATO);
1002   2              PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la r
             -aspberry*/
1003   2              Estado_expedidor = Captura_Expulsa(); //Estado_expedidor=SEQ_LOAD_EEPROM;
1004   2            }
1005   1            
1006   1        return Estado_expedidor;
1007   1      } 
1008          /*------------------------------------------------------------------------------
1009          
1010          ------------------------------------------------------------------------------*/
1011          
1012          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 18  

1013          {
1014   1        unsigned char temp;
1015   1        unsigned char Estado_expedidor;
1016   1        unsigned char buffer_S1_B2[17]; 
1017   1      
1018   1            
1019   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");   
1020   1            
1021   1                              
1022   1            
1023   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1024   1            {
1025   2              
1026   2                for (temp=0; temp<16; ++temp)
1027   2                {
1028   3                  buffer_S1_B2 [temp] =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion d
             -e MF en un arreglo*/
1029   3                }
1030   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b2\r\n");
1031   2                DebugBufferMF(buffer_S1_B2,16,RESPUESTA);
1032   2                
1033   2                      
1034   2                
1035   2                Debug_txt_Tibbo((unsigned char *) "HORARIO:");
1036   2                Debug_chr_Tibbo((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1037   2                *(Atributos_Expedidor + Horario)= ((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1038   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1039   2                
1040   2                Debug_txt_Tibbo((unsigned char *) "PICO Y PLACA:");
1041   2                
1042   2                *(Atributos_Expedidor + Pico_Placa)= ((buffer_S1_B2 [MF_IN_PAGO] & 0XF0) >> 4);
1043   2                Debug_chr_Tibbo(*(Atributos_Expedidor + Pico_Placa));
1044   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1045   2                
1046   2            
1047   2                Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK:");
1048   2                Debug_chr_Tibbo(buffer_S1_B2 [MF_APB] );
1049   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1050   2              
1051   2                /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
1052   2                
1053   2                *(Atributos_Expedidor + Apb)=   buffer_S1_B2 [MF_APB] ;
1054   2                
1055   2                
1056   2                  *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S1_B2 [MF_TIPO_VEHICULO]& 0x0f;
1057   2                  Estado_expedidor =SEQ_TIPO_TARJETAS;    // Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);
1058   2            
1059   2        
1060   2            }
1061   1            else
1062   1            {
1063   2              Estado_expedidor = Captura_Expulsa(); //momentario
1064   2            }
1065   1          return Estado_expedidor;  
1066   1      }
1067          unsigned char Responde_Write_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buf
             -fer_Write_MF)
1068          {
1069   1        unsigned char Estado_expedidor;
1070   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE2\r\n"); 
1071   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b2\r\n");
1072   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 19  

1073   1        if(MenSual !=  True)
1074   1        {
1075   2        *(Atributos_Expedidor + Sector) = Sector_1;
1076   2        *(Atributos_Expedidor + Bloque) = Bloque_0;
1077   2        Armar_Trama_Tarjeta_Sector1_Bloque0(Buffer_Write_MF);
1078   2          Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1079   2        }
1080   1        else
1081   1        {
1082   2          Estado_expedidor = SEQ_LPR;
1083   2        }
1084   1        return Estado_expedidor;
1085   1      }
1086          /*----------------------------------------------------------------------------
1087          ----------------------------------------------------------------------------*/
1088          unsigned char Responde_Write_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1089          {
1090   1      
1091   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE0\r\n"); 
1092   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b0\r\n");
1093   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1094   1        
1095   1        return SEQ_LPR;
1096   1      }
1097          /*----------------------------------------------------------------------------
1098          ----------------------------------------------------------------------------*/
1099          unsigned char Pregunta_Lpr(unsigned char *Atributos_Expedidor)
1100          {
1101   1        unsigned char Estado_expedidor;
1102   1          if(rd_eeprom(0xa8,EE_USE_LPR)== True)
1103   1             {
1104   2               Debug_txt_Tibbo(Armar_Trama_Monitor(Atributos_Expedidor));
1105   2                if (rd_eeprom(0xa8,EE_DEBUG) == False)
1106   2                 {
1107   3                   Debug_Tibbo=False;
1108   3                 }
1109   2             }
1110   1        
1111   1          if (rd_eeprom(0xa8,EE_PLACA)!= False)
1112   1          {
1113   2            Estado_expedidor=SEQ_WAIT_PLACA;
1114   2            ValTimeOutCom=TIME_WAIT ;
1115   2            Timer_wait=False;
1116   2          }
1117   1          else 
1118   1          {
1119   2          Estado_expedidor=SEQ_FRONT_CARD;
1120   2          }
1121   1        return Estado_expedidor;
1122   1      }
1123          /*----------------------------------------------------------------------------
1124          ----------------------------------------------------------------------------*/
1125          unsigned char Responde_Write_Tarjeta_Sector2_Bloque0(unsigned char *Buffer_Write_MF)
1126          {
1127   1        
1128   1        Debug_txt_Tibbo((unsigned char *) "PLACA:");  
1129   1        Debug_txt_Tibbo((unsigned char *) placa);
1130   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1131   1        Debug_txt_Tibbo((unsigned char *) "Write_s2_b0\r\n");
1132   1        DebugBufferMF(Buffer_Write_MF,16,ENVIADOS);
1133   1        return SEQ_FRONT_CARD;
1134   1      }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 20  

1135          unsigned char  Respuesta_Segunda_clave(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1136          {
1137   1        Debug_txt_Tibbo((unsigned char *) "TAREA_SEGUNDA CLAVE\r\n"); 
1138   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1139   1        *(Atributos_Expedidor + Sector) = Sector_2;
1140   1        *(Atributos_Expedidor + Bloque) = Bloque_0;
1141   1        Armar_Trama_Placa(Buffer_Write_MF);
1142   1        return SEQ_WRITE_SECTOR_BLOQUE;
1143   1      }
1144          /*------------------------------------------------------------------------------
1145          ------------------------------------------------------------------------------*/
1146          //void  Armar_Trama_Tarjeta_Sector1_Bloque1(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write
             -_MF)
1147          //{
1148          //  *(Buffer_Write_MF +0) = *(Atributos_Expedidor + Tipo_Tarjeta);
1149          //  *(Buffer_Write_MF +0) = *(Atributos_Expedidor + Tipo_Tarjeta);
1150          //} 
1151          
1152          /*------------------------------------------------------------------------------
1153          ------------------------------------------------------------------------------*/
1154          
1155          void  Armar_Trama_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_M
             -F)
1156          {
1157   1        
1158   1        /*fecha de ingreso se lee año,mes,dia,hora y minutos*/
1159   1        
1160   1        Block_read_Clock_Hex(Buffer_Write_MF);
1161   1        
1162   1        /*descuentos los borro*/
1163   1        
1164   1        *(Buffer_Write_MF + 5)=0;
1165   1        *(Buffer_Write_MF + 6)=0;
1166   1        *(Buffer_Write_MF + 7)=0;
1167   1        
1168   1        if (*(Atributos_Expedidor + Tipo_Tarjeta) == ROTACION)
1169   1        {
1170   2          *(Buffer_Write_MF + 8)  = Tipo_Vehiculo;
1171   2          *(Buffer_Write_MF + 9)  = (Dir_board())- 0x30;
1172   2          *(Buffer_Write_MF +10) = APB_INT;
1173   2        }
1174   1        
1175   1        /*mensual*/
1176   1        else
1177   1        {
1178   2          
1179   2          *(Buffer_Write_MF + 8)  = (*(Atributos_Expedidor + Horario) << 4) | (*(Atributos_Expedidor + Type_Vehicu
             -lo));
1180   2          *(Buffer_Write_MF + 9)  =  (*(Atributos_Expedidor + Pico_Placa) << 4)| (Dir_board())- 0x30;
1181   2          
1182   2          if (*(Atributos_Expedidor + Apb)== APB_NO)
1183   2           {
1184   3              *(Buffer_Write_MF +10) =APB_NO;
1185   3            }
1186   2          else 
1187   2          {
1188   3            *(Buffer_Write_MF +10) =APB_INT;
1189   3          }
1190   2        }
1191   1        /*fecha de salida maxima*/
1192   1        *(Buffer_Write_MF +11)=0;
1193   1        *(Buffer_Write_MF +12)=0;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 21  

1194   1        *(Buffer_Write_MF +13)=0;
1195   1        *(Buffer_Write_MF +14)=0;
1196   1        *(Buffer_Write_MF +15)=0;
1197   1      }
1198          void Armar_Trama_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1199          {
1200   1        /*graba serie de Ticket*/
1201   1        strcpy(Buffer_Write_MF, Lee_No_Ticket());
1202   1      }
1203          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor()
1204          {
1205   1        static unsigned char buffer[28];
1206   1        unsigned char j;
1207   1        /*la trama esta compuesta de
1208   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1209   1      
1210   1        buffer[0]=STX;
1211   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR;
1212   1        buffer[2]=NULL;
1213   1        j=strlen(Lee_No_Ticket());
1214   1        strcat(buffer , Lee_No_Ticket());
1215   1        j=j+2;
1216   1        buffer[j++]= '-';
1217   1        
1218   1        Block_read_Clock_Hex(buffer+j);         //leo la fecha de entrada
1219   1        buffer[j]=buffer[j]+0x030;              /*año de entrada*/
1220   1        buffer[j+1]=buffer[j+1]+0x030;          /*mes de entrada*/
1221   1        buffer[j+2]=buffer[j+2]+0x030;          /*dia de entrada*/
1222   1        buffer[j+3]=buffer[j+3]+0x030;          /*hora de entrada*/
1223   1        buffer[j+4]=buffer[j+4]+0x030;          /*minutos de entrada*/
1224   1        buffer[j+5]= '-';
1225   1        /*placa*/
1226   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1227   1        {   
1228   2          if (placa_ready != False)
1229   2          {
1230   3            buffer[j+6]= placa[0];
1231   3            buffer[j+7]= placa[1];
1232   3            buffer[j+8]= placa[2];
1233   3            buffer[j+9]= placa[3];
1234   3            buffer[j+10]= placa[4];
1235   3            buffer[j+11]= placa[5];
1236   3            buffer[j+12]= NULL;
1237   3          }
1238   2          else
1239   2          {
1240   3            buffer[j+6]= ' ';
1241   3            buffer[j+7]= NULL;
1242   3          }
1243   2        }
1244   1        else 
1245   1        {
1246   2          buffer[j+6]= ' ';
1247   2          buffer[j+7]=NULL;
1248   2        }
1249   1        j=strlen(buffer);
1250   1        buffer[j]= ETX;
1251   1        buffer[j+1]= NULL;
1252   1        return buffer;
1253   1      }
1254          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor)
1255          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 22  

1256   1        static unsigned char buffer[28];
1257   1        //unsigned char j;
1258   1        /*la trama esta compuesta de
1259   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1260   1      
1261   1        buffer[0]=STX;
1262   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
1263   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
1264   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
1265   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
1266   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
1267   1        
1268   1        
1269   1        Block_read_Clock_Hex(buffer+6);         //leo la fecha de entrada
1270   1        buffer[6]=buffer[6]+0x030;              /*año de entrada*/
1271   1        buffer[7]=buffer[7]+0x030;          /*mes de entrada*/
1272   1        buffer[8]=buffer[8]+0x030;          /*dia de entrada*/
1273   1        buffer[9]=buffer[9]+0x030;          /*hora de entrada*/
1274   1        buffer[10]=buffer[10]+0x030;          /*minutos de entrada*/
1275   1      
1276   1        /*placa*/
1277   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1278   1        {   
1279   2          
1280   2            buffer[11]= placa[0];
1281   2            buffer[12]= placa[1];
1282   2            buffer[13]= placa[2];
1283   2            buffer[14]= placa[3];
1284   2            buffer[15]= placa[4];
1285   2            buffer[16]= placa[5];
1286   2      
1287   2        }
1288   1      
1289   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1290   1        {
1291   2          buffer[17]= 'C';
1292   2        }
1293   1        else
1294   1        {
1295   2          buffer[17]= 'M';
1296   2        }
1297   1        
1298   1        buffer[18]= ETX;
1299   1        buffer[19]= NULL;
1300   1        return buffer;
1301   1      }
1302          unsigned char *Armar_Trama_Monitor(unsigned char *Atributos_Expedidor)
1303          {
1304   1        static unsigned char buffer[24];
1305   1        unsigned char j;
1306   1        /*la trama esta compuesta de
1307   1        STX,address_board,CMD,Tipo_Vehiculo,NoTICKET,:,fecha int añomesdishoraminuto,:,ETX*/
1308   1        Debug_Tibbo=False;
1309   1        buffer[0]=STX;
1310   1        buffer[1]=Dir_board();
1311   1        buffer[2]=CMD_MONITOR_EXPEDIDOR;
1312   1        if(Tipo_Vehiculo == AUTOMOVIL)
1313   1          {
1314   2            buffer[3]= 'C';
1315   2          }
1316   1        else
1317   1          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 23  

1318   2            buffer[3]= 'M';
1319   2          }
1320   1          
1321   1          /*ticket*/
1322   1          if(MenSual !=  True)
1323   1          {
1324   2          buffer[4]=NULL;
1325   2          strcat(buffer , Lee_No_Ticket());
1326   2          }
1327   1          else
1328   1          {
1329   2            ByteHex_Decimal(buffer+4,*(Atributos_Expedidor + Uid_2));
1330   2            j=strlen(buffer);
1331   2            buffer[j]= ' ';
1332   2            buffer[j+1]= NULL;
1333   2            j=strlen(buffer);
1334   2            Two_ByteHex_Decimal(buffer+j,*(Atributos_Expedidor + Uid_1),*(Atributos_Expedidor + Uid_0));
1335   2            
1336   2          }
1337   1          j=strlen(buffer);
1338   1          buffer[j]=':';
1339   1          /*fecha de entrada*/
1340   1          Block_read_clock_ascii(buffer+j+1);     //leo la fecha de entrada
1341   1          j=strlen(buffer);
1342   1        
1343   1          buffer[j]= ':';
1344   1          buffer[j+1]=ETX;
1345   1          buffer[j+2]=NULL;
1346   1          Debug_Tibbo=True;
1347   1        return buffer;
1348   1      }
1349          void Armar_Trama_Placa(unsigned char *Buffer_Write_MF)
1350          {
1351   1        unsigned char j;
1352   1        
1353   1          for(j=0; j<8;j++)
1354   1          {
1355   2          *(Buffer_Write_MF +j)=placa[j];
1356   2          }
1357   1            for (j=8; j<16; j++)            
1358   1          {
1359   2            *(Buffer_Write_MF +j)=0x00;
1360   2          }
1361   1      }
1362          unsigned char Load_Secuencia_Expedidor(unsigned char *Secuencia_Expedidor,unsigned const  estadoactivo,uns
             -igned const estadoactual,unsigned const estadofuturo)
1363          {
1364   1        *(Secuencia_Expedidor + EstadoPasado ) = estadoactivo ;
1365   1        *(Secuencia_Expedidor + EstadoActual ) = estadoactual;
1366   1        *(Secuencia_Expedidor + EstadoFuturo ) = estadofuturo;
1367   1        return estadoactual;
1368   1      }
1369          unsigned char Disparo_Lock_Entrada_Vehiculo()
1370          {
1371   1        unsigned char Estado_expedidor;
1372   1        Debug_txt_Tibbo((unsigned char *) "TAKE CARD\r\n");
1373   1        if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                   // CANAL LIBRE    no tiene tarjetas 
             -en el mecanismo
1374   1          {
1375   2            Debug_txt_Tibbo((unsigned char *) "TAREA_OPEN_BARRERA\r\n");  
1376   2            lock=ON;
1377   2            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 24  

1378   2            Estado_expedidor=SEQ_PTO_PARALELO;
1379   2            
1380   2            
1381   2          }
1382   1        else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                      //  se detecta la tarjeta en la b
             -oca TARJETA EN BEZZEL
1383   1        {
1384   2          if(Valida_Sensor1_Auto()!= False)
1385   2          {
1386   3            Estado_expedidor=SEQ_DETAIL_CARD;
1387   3          }
1388   2          else
1389   2          {
1390   3            Estado_expedidor=SEQ_CAPTURE_CARD;
1391   3          }
1392   2        
1393   2        }
1394   1        return Estado_expedidor;
1395   1      }
1396          unsigned char Send_Pto_Paralelo(unsigned char *Atributos_Expedidor)
1397          {
1398   1        unsigned char *Trama_Expedidor ;
1399   1        if(MenSual == True)
1400   1        {
1401   2        Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor);
1402   2        }
1403   1        else 
1404   1        {
1405   2          Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor();
1406   2          Incremente_Ticket();
1407   2        }
1408   1        send_port(Trama_Expedidor,strlen(Trama_Expedidor)); 
1409   1        Debug_txt_Tibbo((unsigned char *) "Trama_pto_paralelo\r\n");
1410   1        DebugBufferMF(Trama_Expedidor,strlen(Trama_Expedidor),ENVIADOS);
1411   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1412   1        
1413   1        
1414   1        clear_placa();
1415   1        ValTimeOutCom=TIME_WAIT ;
1416   1        Timer_wait=0;
1417   1        return SEQ_ESPERA_VEHICULO_ENTRE;
1418   1      }
1419          
1420          /*------------------------------------------------------------------------------
1421          ------------------------------------------------------------------------------*/
1422          unsigned char Entrega_Card_Captura()
1423          {
1424   1        unsigned char Estado_expedidor;
1425   1        
1426   1          
1427   1        Debug_txt_Tibbo((unsigned char *) "ESPERA VEHICULO ENTRE\r\n"); 
1428   1        sel_Sensor2();                                //garantiso q la barrera se encuentre en posicion baja  
1429   1        if ((DataIn==0))        
1430   1        {  
1431   2          if (ValidaSensor()==0)
1432   2          {
1433   3            lock=OFF;
1434   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo Entrando");
1435   3            Estado_expedidor=SEQ_INICIO;
1436   3          }
1437   2          
1438   2        }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 25  

1439   1        else
1440   1        {
1441   2            if(Valida_Sensor1_Auto()!= False)
1442   2            {
1443   3            /*presencia vehicular*/
1444   3              Estado_expedidor=SEQ_ESPERA_VEHICULO_ENTRE;//SEQ_INICIO;//
1445   3              
1446   3              if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1447   3              {
1448   4                  if (Timer_wait >= 5)
1449   4               {
1450   5                 lock=OFF;
1451   5                 Estado_expedidor=SEQ_INICIO;;
1452   5               }
1453   4              else if (Timer_wait <= 4)
1454   4               {
1455   5                ValTimeOutCom=TIME_WAIT ;
1456   5               }
1457   4             }
1458   3              
1459   3            }
1460   2            else
1461   2            {
1462   3            lock=OFF;
1463   3            Estado_expedidor=SEQ_INICIO;
1464   3            }
1465   2        } 
1466   1       
1467   1        return Estado_expedidor;
1468   1      }
1469          unsigned char Wait_Placa(unsigned char *secuencia_expedidor, unsigned char estadoactivo)
1470          {
1471   1        unsigned char Estado_expedidor;
1472   1        
1473   1        
1474   1      while ((ValTimeOutCom != 1) && (ValTimeOutCom <= TIME_WAIT) && (placa_ready == False))
1475   1        {
1476   2          if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
1477   2              {
1478   3                
1479   3                Rx_Monitor();
1480   3              }
1481   2        }
1482   1        
1483   1          if(placa_ready!=False)
1484   1            {
1485   2              Clave_Seguridad_S2();
1486   2              Estado_expedidor=Load_Secuencia_Expedidor(secuencia_expedidor,estadoactivo,SEQ_CMD_ACEPTADO,SEQ_RESPUE
             -STA_TRANSPORTE);    
1487   2              *(secuencia_expedidor +TareadelCmd ) = TAREA_WRITE_PLACA_CARD;
1488   2            }
1489   1            else
1490   1            {
1491   2                Estado_expedidor=SEQ_WAIT_PLACA;
1492   2             if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1493   2             {  
1494   3              if (Timer_wait >= 5)
1495   3               {
1496   4                 Estado_expedidor=SEQ_FRONT_CARD;
1497   4               }
1498   3              else if (Timer_wait <= 4)
1499   3               {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 26  

1500   4                ValTimeOutCom=TIME_WAIT ;
1501   4               }
1502   3             }
1503   2            }
1504   1        return Estado_expedidor;
1505   1      }
1506          unsigned char Valida_Vehiculo_Card_Mensual(unsigned char *Atributos_Expedidor)
1507          {
1508   1        unsigned char Estado_expedidor;
1509   1        
1510   1          Debug_txt_Tibbo((unsigned char *) "VEHICULO MENSUAL TARJETA: ");
1511   1          if(*(Atributos_Expedidor + Type_Vehiculo  ) == False)
1512   1           {
1513   2            Debug_txt_Tibbo((unsigned char *) "(0) CARRO");
1514   2           }
1515   1          else
1516   1           {
1517   2            Debug_txt_Tibbo((unsigned char *) "(1) MOTO");
1518   2           }
1519   1                            
1520   1          Debug_txt_Tibbo((unsigned char *) "\r\n");
1521   1        if ((rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL)) != True) 
1522   1        {
1523   2          if  (*(Atributos_Expedidor + Type_Vehiculo  ) == Tipo_Vehiculo )          
1524   2          {
1525   3           Debug_txt_Tibbo((unsigned char *) "COINCIDE CARD CON LOOK\r\n ");
1526   3            Estado_expedidor = True ;
1527   3          }
1528   2          
1529   2          else
1530   2          {
1531   3            send_portERR(ERROR_TIPO_VEHICULO);  
1532   3            Debug_txt_Tibbo((unsigned char *) "TIPO DE VEHICULO NO CORRESPONDE\r\n ");
1533   3            Estado_expedidor = False; 
1534   3          }
1535   2        } 
1536   1        else 
1537   1        {
1538   2            Debug_txt_Tibbo((unsigned char *) "NO INTERESA COINCIDENCIA CARD CON LOOK\r\n ");
1539   2            Estado_expedidor = True ;
1540   2        }
1541   1          return Estado_expedidor;
1542   1      }
1543          unsigned char Tarjeta_Mensual(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1544          {
1545   1        unsigned char Estado_expedidor;
1546   1        
1547   1        /*cheque la fecha de expiracion del mensual*/
1548   1        if (Horarios(Atributos_Expedidor) == True)
1549   1        {
1550   2         if ( check_fechaOut(Atributos_Expedidor+Expira_ano) == True )
1551   2            {
1552   3              /*valida el vehiculo en el loop y en la card*/
1553   3              if( Valida_Vehiculo_Card_Mensual(Atributos_Expedidor) == False)
1554   3              {
1555   4              Estado_expedidor = Captura_Expulsa();   
1556   4              }
1557   3              else
1558   3              {
1559   4                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1560   4                *(Atributos_Expedidor + Sector) = Sector_1;
1561   4                *(Atributos_Expedidor + Bloque) = Bloque_2;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 27  

1562   4                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1563   4                Estado_expedidor=SEQ_WRITE_SECTOR_BLOQUE;
1564   4              }
1565   3            }
1566   2            else 
1567   2            {
1568   3              send_portERR(TARJETA_VENCIDA);  
1569   3              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
1570   3              Estado_expedidor = SEQ_EXPULSAR_CARD;
1571   3            }
1572   2        }
1573   1        else
1574   1        {
1575   2          
1576   2          Estado_expedidor = SEQ_EXPULSAR_CARD;
1577   2        }
1578   1        return Estado_expedidor;
1579   1      }
1580          unsigned char Tarjeta_Rotacion(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1581          {
1582   1              *(Atributos_Expedidor + Sector) = Sector_1;
1583   1                *(Atributos_Expedidor + Bloque) = Bloque_2;
1584   1                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1585   1                return  SEQ_WRITE_SECTOR_BLOQUE;
1586   1        
1587   1        
1588   1      }
1589          unsigned char Valida_Tipo_Tarjeta(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1590          {
1591   1        unsigned char Estado_expedidor;
1592   1        if(*(Atributos_Expedidor + Tipo_Tarjeta) ==  MENSUALIDAD)
1593   1        {
1594   2          Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
1595   2          if(MenSual ==  True)
1596   2          {
1597   3          //Estado_expedidor=SEQ_CAPTURE_CARD;                                        
1598   3        //}
1599   3          /*APB Habilitado por software*/
1600   3          
1601   3            if( (rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL) == APB_HABILITADO_SOFT) )
1602   3            {
1603   4              /*APB por Card*/
1604   4           
1605   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO))       
1606   4              {
1607   5                Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1608   5      
1609   5              }
1610   4              else
1611   4              {
1612   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK MENSUAL \r\n");
1613   5                Estado_expedidor = Captura_Expulsa(); 
1614   5              } 
1615   4            }
1616   3          
1617   3          else
1618   3          {
1619   4            Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO MENSUAL \r\n");
1620   4          
1621   4           Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1622   4          }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 28  

1623   3        }
1624   2        else
1625   2         {
1626   3          Estado_expedidor = SEQ_CAPTURE_CARD;
1627   3         } 
1628   2       }
1629   1        else if (*(Atributos_Expedidor + Tipo_Tarjeta) ==  ROTACION)
1630   1        {
1631   2          
1632   2            Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n ");
1633   2          if(MenSual != True)
1634   2          {
1635   3            if ( (rd_eeprom(0xa8,EE_HABILITA_APB))!= APB_INHABILITADO_SOFT)
1636   3            {
1637   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO) )
1638   4                                    
1639   4              {
1640   5                Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
1641   5              }
1642   4              else
1643   4              {
1644   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK ROTACION \r\n");
1645   5                send_portERR(SIN_SALIDA);
1646   5                PantallaLCD(SIN_SALIDA);
1647   5                Estado_expedidor = Captura_Expulsa();
1648   5              }
1649   4            }
1650   3            else
1651   3            {
1652   4              Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO ROTACION \r\n");
1653   4              Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
1654   4            } 
1655   3          }
1656   2          else
1657   2          {
1658   3            send_portERR(NO_CARD_MENSUAL);
1659   3            Estado_expedidor = Captura_Expulsa();   
1660   3          }
1661   2        }
1662   1        else
1663   1        {
1664   2          Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n ");
1665   2          send_portERR(TARJETA_INVALIDA);
1666   2          PantallaLCD(TARJETA_INVALIDA);    
1667   2          Estado_expedidor = Captura_Expulsa();   
1668   2        }
1669   1        
1670   1        return Estado_expedidor;
1671   1      }
1672          unsigned char Festivos()
1673          {
1674   1        
1675   1        unsigned char dia_semana,day, month, year,DiaFestivo=0;
1676   1      
1677   1        
1678   1        dia_semana=bcd_hex(lee_clk(RDIA_SEMANA));
1679   1        day = bcd_hex(lee_clk(RDIA));
1680   1        month = bcd_hex(lee_clk(RMES));
1681   1        year = bcd_hex(lee_clk(RANO));
1682   1        
1683   1        if (year==20)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 29  

1684   1        {
1685   2          if (((month==1)&&(day==1))||((month==1)&&(day==6))||((month==3)&&(day==23))||((month==4)&&(day==9))||((m
             -onth==4)&&(day==10))||((month==5)&&(day==1))||((month==5)&&(day==25))||((month==6)&&(day==3)))  
1686   2          {
1687   3            DiaFestivo = True;
1688   3            }
1689   2          else if (((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==17))||((month==10)&&(day==1
             -2))||((month==11)&&(day==2))||((month==11)&&(day==16))||((month==12)&&(day==8))||((month==12)&&(day==25)))
1690   2          {
1691   3            DiaFestivo = True;
1692   3          }
1693   2      
1694   2        }
1695   1        else if (year==21)
1696   1        {
1697   2          if (((month==1)&&(day==1))||((month==1)&&(day==11))||((month==3)&&(day==22))||((month==4)&&(day==1))||((
             -month==4)&&(day==2))||((month==5)&&(day==1))||((month==5)&&(day==17))||((month==6)&&(day==7))||((month==6)&&(day==14))) 
1698   2          {
1699   3            DiaFestivo = True;
1700   3            }
1701   2          else if (((month==7)&&(day==5))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==16)
             -)||((month==10)&&(day==18))||((month==11)&&(day==1))||((month==11)&&(day==15))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
1702   2          {
1703   3            DiaFestivo = True;
1704   3          }
1705   2      
1706   2        }
1707   1        else if (year==22)
1708   1        {
1709   2          if (((month==1)&&(day==1))||((month==1)&&(day==10))||((month==3)&&(day==21))||((month==4)&&(day==14))||(
             -(month==4)&&(day==15))||((month==5)&&(day==1))||((month==5)&&(day==30))||((month==6)&&(day==20))||((month==6)&&(day==27)
             -))  
1710   2          {
1711   3            DiaFestivo = True;
1712   3            }
1713   2          else if (((month==7)&&(day==4))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==15)
             -)||((month==10)&&(day==17))||((month==11)&&(day==7))||((month==11)&&(day==14))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
1714   2          {
1715   3            DiaFestivo = True;
1716   3          }
1717   2      
1718   2        
1719   2        
1720   2        }
1721   1        if ((dia_semana == Sabado)||(dia_semana == Domingo)||(DiaFestivo == True))
1722   1        {
1723   2          DiaFestivo = True;
1724   2        }
1725   1        else
1726   1        {
1727   2          DiaFestivo = False;
1728   2        }
1729   1        return DiaFestivo;
1730   1      }
1731          unsigned char Dia_Pico_Placa(unsigned char * Atributos_Expedidor)
1732          {
1733   1        unsigned char Par_Impar;
1734   1        unsigned char dato;
1735   1        
1736   1        if( Festivos() == False)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 30  

1737   1        {
1738   2        dato=lee_clk(RDIA);
1739   2      
1740   2          if((dato % 2 == False) && (*(Atributos_Expedidor + Pico_Placa)  == True))
1741   2          {
1742   3          
1743   3          /*es par*/
1744   3          Par_Impar = True;
1745   3          
1746   3          }
1747   2          else
1748   2          {
1749   3          /*es impar */
1750   3          Par_Impar = False;
1751   3          }
1752   2        }
1753   1        else
1754   1        {
1755   2          Par_Impar = True;
1756   2        }
1757   1        return Par_Impar;
1758   1      }
1759          unsigned char Horarios(unsigned char * Atributos_Expedidor)
1760          {
1761   1        unsigned char Estado_Horario;
1762   1        
1763   1        unsigned char Addr_horarios [11];
1764   1        unsigned char dia_semana,EE_dia_semana;
1765   1        unsigned int addr;
1766   1        if (*(Atributos_Expedidor + Horario) != False )
1767   1        {
1768   2          /*se Lee la direccion del horario*/
1769   2          strcpy (Addr_horarios,(Addr_Horarios()));
1770   2          
1771   2          addr= Addr_horarios[(*(Atributos_Expedidor + Horario)) -1] ;
1772   2          
1773   2           /*leemos si esta habilitado*/
1774   2          
1775   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
1776   2          {
1777   3            /*miramos si el dia de la semana esta habilitado*/
1778   3            dia_semana = lee_clk(RDIA_SEMANA);
1779   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
1780   3            Debug_chr_Tibbo(dia_semana);
1781   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
1782   3            
1783   3          
1784   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
1785   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
1786   3            Debug_chr_Tibbo(EE_dia_semana);
1787   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
1788   3          
1789   3            if ( EE_dia_semana == dia_semana)
1790   3            {
1791   4              /*miramos si esta en el rango del horario*/
1792   4              Estado_Horario = Bloque_Horario(addr);
1793   4            }
1794   3            else
1795   3            {
1796   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
1797   4              Estado_Horario= False;
1798   4            }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 31  

1799   3          }
1800   2          else 
1801   2          {
1802   3            
1803   3            Estado_Horario= False;
1804   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
1805   3            
1806   3          }
1807   2          
1808   2        }
1809   1        else
1810   1        {
1811   2          Estado_Horario = True;
1812   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
1813   2        }
1814   1        return Estado_Horario;
1815   1      }
1816          unsigned int Hora_Maxima(unsigned int addr)
1817          {
1818   1        unsigned char Hora_High,  Minuto_High;
1819   1        unsigned char HoraIni , MinutoIni; 
1820   1        unsigned int  Hora_Prog;
1821   1        
1822   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
1823   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
1824   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
1825   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
1826   1         Debug_chr_Tibbo(HoraIni);
1827   1         Debug_chr_Tibbo(MinutoIni);
1828   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
1829   1        
1830   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
1831   1      }
1832          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
1833          {
1834   1        unsigned char Estado_Horario; 
1835   1        
1836   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
1837   1        {
1838   2          
1839   2          /*hasta la hora que puede ingresar el vehiculo */
1840   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
1841   2          Hora_Prog = Hora_Maxima(addr+4);
1842   2      
1843   2        
1844   2          if( HoraNow <= Hora_Prog)
1845   2          {
1846   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
1847   3            Estado_Horario = True;
1848   3          }
1849   2          else
1850   2          {
1851   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
1852   3            Estado_Horario = False;
1853   3          }
1854   2          
1855   2        }
1856   1        else
1857   1        {
1858   2            
1859   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
1860   2              Estado_Horario = False;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 32  

1861   2            
1862   2        }
1863   1        return Estado_Horario;
1864   1      }
1865          
1866          unsigned Bloque_Horario(unsigned int addr)
1867          {
1868   1        unsigned char Estado_Horario; 
1869   1        unsigned int HoraNow, Hora_Prog;
1870   1        
1871   1        /*la hora del momento de entrada del vehiculo*/
1872   1        
1873   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
1874   1        Debug_chr_Tibbo(lee_clk(RHORA));
1875   1        Debug_chr_Tibbo(lee_clk(RMIN));
1876   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1877   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
1878   1        
1879   1        /* desde la hora en que puede ingresar vehiculo */
1880   1        
1881   1        
1882   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
1883   1        Hora_Prog = Hora_Maxima(addr);
1884   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
1885   1        if(Estado_Horario == False )
1886   1        {
1887   2          
1888   2            
1889   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
1890   2            {
1891   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
1892   3              Hora_Prog = Hora_Maxima(addr+10);
1893   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
1894   3            }
1895   2            else
1896   2            {
1897   3              Estado_Horario = False;
1898   3            }
1899   2        }
1900   1      
1901   1      return Estado_Horario;
1902   1      }
1903          /*------------------------------------------------------------------------------
1904          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
1905          
1906          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
1907          ------------------------------------------------------------------------------*/
1908          
1909          
1910          unsigned char  Secuencia_inicio_expedidor(void)
1911          {
1912   1        char temp;
1913   1        switch (Estado)
1914   1        {
1915   2          case INICIA_LINTECH:
1916   2      
1917   2                
1918   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
1919   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
1920   2              
1921   2            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 33  

1922   2            return (Estado);
1923   2          break;
1924   2      
1925   2      
1926   2      /*------------------------------------------------------------------------------
1927   2      Envia la primera trama de inicializacion del transporte sin movimiento
1928   2            (0) LA RESPUESTA ES OK
1929   2            (1) NO RESPONDE EL PTO SERIE
1930   2            (2) NO RECIBIDO LA TRAMA 
1931   2            (3) ERROR DE TRAMA CMD (N)
1932   2      ------------------------------------------------------------------------------*/
1933   2            
1934   2          case SEQ_CAPTURE_DATOS_INI:
1935   2      
1936   2            if((temp=Trama_Validacion_P_N())!=0)
1937   2          {
1938   3            if(temp==2)
1939   3            {
1940   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
1941   4            } 
1942   3            else if (temp==3)
1943   3            {
1944   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
1945   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
1946   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
1947   4            }
1948   3            else
1949   3            {
1950   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
1951   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
1952   4            }
1953   3          }
1954   2          else
1955   2          {
1956   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
1957   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1958   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
1959   3          }     
1960   2          return (Estado);
1961   2          break;
1962   2            
1963   2      /*------------------------------------------------------------------------------
1964   2      Envia el cmd de grabar claves a la eeprom del transporte 
1965   2      ------------------------------------------------------------------------------*/
1966   2            
1967   2            case GRABA_EEPROM:
1968   2              
1969   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
1970   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
1971   2            
1972   2            
1973   2      
1974   2            return (Estado);
1975   2              break;
1976   2        
1977   2      /*------------------------------------------------------------------------------
1978   2      se analiza la respuesta 
1979   2            (0) LA RESPUESTA ES OK
1980   2            (1) NO RESPONDE EL PTO SERIE
1981   2            (2) NO RECIBIDO LA TRAMA 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 34  

1982   2            (3) ERROR DE TRAMA CMD (N)
1983   2      ------------------------------------------------------------------------------*/
1984   2            
1985   2          case SEQ_CAPTURA_OK_EEPROM:
1986   2          
1987   2          if((temp=Trama_Validacion_P_N())!=0)
1988   2          {
1989   3            if(temp==2)
1990   3            {
1991   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
1992   4            }
1993   3            else if (temp==3)
1994   3            {
1995   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
1996   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
1997   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
1998   4            }     
1999   3            else
2000   3            {
2001   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2002   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
2003   4            }       
2004   3          }
2005   2          else
2006   2          {
2007   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
2008   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2009   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
2010   3          }     
2011   2      
2012   2          return (Estado);
2013   2          break;
2014   2      
2015   2      /*------------------------------------------------------------------------------
2016   2      Fin de la secuencia de comandos con exito 
2017   2      ------------------------------------------------------------------------------*/    
2018   2            
2019   2              case FIN_OK:
2020   2      
2021   2              return (Estado);
2022   2          break;
2023   2            
2024   2                
2025   2              default:
2026   2              return Estado=INICIA_LINTECH; 
2027   2              break;
2028   2        }
2029   1      }
2030          
2031          /*------------------------------------------------------------------------------
2032          Prosedimiento  q hace paso a paso la secuencia de la MF
2033          atributos
2034          ValTimeOutCom = tiempo que  espera para recibir datos pto serie
2035          Tarjeta_on = detecto vehiculo en loop y tiene tarjeta en boca
2036          g_cEstadoComSeqMF = nos dice en el estado que nos encontramos dentro del seguimiento
2037          ------------------------------------------------------------------------------*/
2038          
2039          unsigned char SecuenciaExpedidorMF(unsigned char EstadoActivo)
2040          {
2041   1        static unsigned char Buffer_Write_MF[17];
2042   1        static unsigned char Atributos_Expedidor[15];
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 35  

2043   1        static unsigned char Secuencia_Expedidor[4];
2044   1        
2045   1        switch (EstadoActivo)
2046   1        {
2047   2      //***********************************************************************************************
2048   2          
2049   2          case SEQ_INICIO:
2050   2      
2051   2            if ((ValTimeOutCom==True)|| (ValTimeOutCom > TIME_CARD))
2052   2            {
2053   3              lock=OFF;                                                                                   /*rele de disparo a la barrera*/
2054   3              Rele_Atasco=OFF;                                                                           /*activo el rele de reset del verificador logica
             - negativa*/    
2055   3              Check_Status(SENSOR_NORMAL);                                                              /* se pregunta al transporte en q estado es
             -tan las TI*/
2056   3              EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_
             -TRANSPORTE);
2057   3              Secuencia_Expedidor [ TareadelCmd  ] = TAREA_PRESENCIA_VEHICULAR;
2058   3            
2059   3            }
2060   2       
2061   2          break;
2062   2          
2063   2          case  SEQ_CMD_ACEPTADO:
2064   2          /*cmd comun para todos*/
2065   2            EstadoActivo=rta_cmd_transporte(Secuencia_Expedidor);
2066   2            
2067   2          break;
2068   2      
2069   2      /*------------------------------------------------------------------------------
2070   2          Tareas especificas de cada paso
2071   2      ------------------------------------------------------------------------------*/      
2072   2          
2073   2            
2074   2          case SEQ_RESPUESTA_TRANSPORTE:
2075   2              ValTimeOutCom=TIME_WAIT;
2076   2            if (Secuencia_Expedidor [TareadelCmd]==TAREA_PRESENCIA_VEHICULAR)
2077   2            {
2078   3            EstadoActivo=Responde_Estado_Sensores_Transporte(); 
2079   3            
2080   3            }
2081   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_TIPO_TARJETA)
2082   2                {
2083   3                  
2084   3                  EstadoActivo=Responde_Tipo_Tarjeta();
2085   3                }
2086   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_LECTURA_TARJETA_SECTOR_BLOQUE)
2087   2                {
2088   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2089   3                  {
2090   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque1 (Atributos_Expedidor);
2091   4                  }
2092   3                  else
2093   3                  {
2094   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque2(Atributos_Expedidor);
2095   4                  }
2096   3                }
2097   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_WRITE_TARJETA_SECTOR_BLOQUE)
2098   2                { 
2099   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_2))
2100   3                  { 
2101   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor,Buffer_Write_MF);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 36  

2102   4                  }
2103   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_2)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2104   3                  {
2105   4                    EstadoActivo=Responde_Write_Tarjeta_Sector2_Bloque0(Buffer_Write_MF);
2106   4                  }
2107   3                  else
2108   3                  {
2109   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque0 (Buffer_Write_MF);
2110   4                  }
2111   3                }
2112   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_OPEN_BARRERA)
2113   2                {   
2114   3                  EstadoActivo = Disparo_Lock_Entrada_Vehiculo();
2115   3                }
2116   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_WRITE_PLACA_CARD)
2117   2                {   
2118   3                  EstadoActivo = Respuesta_Segunda_clave(Atributos_Expedidor,Buffer_Write_MF);
2119   3                }
2120   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_TIPO_MENSUAL) 
2121   2                {
2122   3                  EstadoActivo = Analiza_Presencia_Mensual();
2123   3                }
2124   2                
2125   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_UID ) 
2126   2                {
2127   3                  EstadoActivo = Analiza_Uid_Card(Atributos_Expedidor);
2128   3                }   
2129   2            else
2130   2                {
2131   3                  Debug_txt_Tibbo((unsigned char *) "TAREA_3\r\n");
2132   3                }
2133   2            break;
2134   2          case SEQ_MOVER_CARD_RF:
2135   2            Mov_Card(MovPos_RF);
2136   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_TIPO_CARD);
2137   2            break;
2138   2          case SEQ_CARD_INSERCION_ON:
2139   2            Card_Insercion(Habilita); 
2140   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2141   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_MENSUAL;
2142   2          break;
2143   2          case SEQ_TIPO_CARD:
2144   2            Aut_Card_check_Status();
2145   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2146   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_TARJETA;
2147   2          break;
2148   2          case SEQ_LOAD_PASSWORD:
2149   2            LoadVerify_EEprom();
2150   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECTOR
             -_BLOQUE);
2151   2            Atributos_Expedidor [ Sector ]    = Sector_1;
2152   2            Atributos_Expedidor [ Bloque ]    = Bloque_1;
2153   2            break;
2154   2          case SEQ_READ_SECTOR_BLOQUE:
2155   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
2156   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2157   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
2158   2          break;
2159   2          case SEQ_WRITE_SECTOR_BLOQUE:
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 37  

2160   2            WR_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ],Buffer_Write_MF);
2161   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2162   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_WRITE_TARJETA_SECTOR_BLOQUE;
2163   2          break;
2164   2          case SEQ_CAPTURE_CARD:
2165   2            Mov_Card(MovPos_Capture);
2166   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_MOVER_CARD_
             -RF);     //SEQ_INICIO
2167   2            break;
2168   2          case SEQ_CARD_INSERCION_OFF:
2169   2            Card_Insercion(Inhabilita);
2170   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_EXPULSAR_CA
             -RD);
2171   2          break;
2172   2          case SEQ_EXPULSAR_CARD:
2173   2            Mov_Card(MovPos_EjectFront);
2174   2            MenSual = False;
2175   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);    
2176   2            
2177   2          break;
2178   2          case SEQ_FRONT_CARD:
2179   2            Mov_Card(MovPos_Front);
2180   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_DETAIL_CAR
             -D);    
2181   2            
2182   2          break;
2183   2          case SEQ_DETAIL_CARD:
2184   2            Check_Status(SENSOR_DETAIL);
2185   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);    
2186   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_OPEN_BARRERA;
2187   2            break;
2188   2          case SEQ_LOAD_EEPROM:
2189   2            Dwload_EEprom();
2190   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECT
             -OR_BLOQUE);  
2191   2          break;
2192   2          case SEQ_ESPERA_VEHICULO_ENTRE:
2193   2            MenSual = False;
2194   2            EstadoActivo = Entrega_Card_Captura();
2195   2            break;
2196   2          case SEQ_PTO_PARALELO:
2197   2            EstadoActivo = Send_Pto_Paralelo(Atributos_Expedidor);
2198   2            
2199   2            break;
2200   2          case SEQ_WAIT_PLACA:
2201   2            EstadoActivo = Wait_Placa(Secuencia_Expedidor,EstadoActivo);
2202   2          break;
2203   2          case SEQ_UID: 
2204   2            Unique_Identifier_UID();
2205   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);    
2206   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_UID ;
2207   2          break;
2208   2          case SEQ_LPR:
2209   2            EstadoActivo = Pregunta_Lpr(Atributos_Expedidor);
2210   2            break;
2211   2          case SEQ_TIPO_TARJETAS:
2212   2            EstadoActivo = Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);;
2213   2            break;
2214   2          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/14/2020 08:20:41 PAGE 38  

2215   2          default:
2216   2          EstadoActivo = SEQ_INICIO;  
2217   2          break;  
2218   2            
2219   2        } 
2220   1        return EstadoActivo;
2221   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8023    ----
   CONSTANT SIZE    =   1709    ----
   XDATA SIZE       =    119     208
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
