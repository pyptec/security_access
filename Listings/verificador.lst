C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          
  12          
  13          extern void send_portERR(unsigned char cod_err);
  14          
  15          
  16          
  17          
  18          extern void PantallaLCD(unsigned char cod_msg);
  19          extern void PantallaLCD_LINEA_2(unsigned char cod_msg, unsigned char *buffer);
  20          
  21          //extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          
  23          
  24          /*funciones prototipo de clock*/
  25          
  26          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  27          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  28          void Block_read_clock_ascii(unsigned char *datos_clock);
  29          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  30          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l);
  31          extern char check_fechaOut(char *buffer);
  32          extern char lee_clk (unsigned char dir_clk);
  33          extern unsigned char bcd_hex (unsigned char l_data);
  34          extern void hex_ascii(unsigned char * datos,unsigned char * fecha_asii);
  35          
  36          extern void Cmd_Lpr_Int();
  37          extern void Delay_10ms(unsigned int cnt);
  38          
  39          /*funciones prototipo string */
  40          
  41          extern char  *strcat  (char *s1, const char *s2);
  42          extern char  *strcpy  (char *s1, const char *s2);
  43          extern unsigned int strlen  (const char *);
  44          
  45          /*funciones prototipo de EEprom*/
  46          
  47          extern unsigned char *Lee_No_Ticket();
  48          void Incremente_Ticket();
  49          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  50          
  51          /*funciones prototipo del transporte MODULO io_sensores*/
  52          
  53          extern unsigned char  ValidaSensoresPaso(void);
  54          unsigned char Valida_Sensor1_Auto();
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 2   

  55          extern unsigned char Dir_board();
  56          extern void sel_Pulsa(void);
  57          void sel_Sensor2(void);
  58          char ValidaSensor(void);
  59          
  60          /*funciones prototipo del transporte MODULO TIBBO*/
  61          
  62          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  63          extern void Debug_txt_Tibbo(unsigned char * str);
  64          extern void Debug_chr_Tibbo(unsigned char Dat);
  65          extern void Debug_HexDec(unsigned char xfc);
  66          
  67          /*funciones prototipo del transporte MODULO LINTECH*/
  68          
  69          extern void Aut_Card_check_Status(void);
  70          extern void Check_Status(unsigned char Detalle);
  71          extern void Dwload_EEprom (void);
  72          extern void Mov_Card(unsigned char Posicion);
  73          extern void Card_Insercion(char Tipo);
  74          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  75          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);  
  76          extern void LoadVerify_EEprom(void);
  77          extern void Clave_Seguridad_S2(void);
  78          extern void Unique_Identifier_UID(void);
  79          extern void Power_off(void);
  80          
  81          /*funcion prototipo monitor*/
  82          
  83          extern void clear_placa();
  84          extern void Rx_Monitor();
  85          
  86          /*funcion prototipo pto paralelo*/
  87          
  88          void  send_port(unsigned char *buffer_port, unsigned char length_char);
  89          
  90          /*funcion prototipo programacion*/
  91          extern unsigned char *Addr_Horarios();
  92          
  93          extern int    atoi (const char *s1);
  94          /*io sensores */
  95          
  96          sbit DataIn = P1^1;         //  dato de las entradas    
  97          sbit sel_A = P3^5;          //Pulsador                        *
  98          sbit sel_B = P3^6;          //Entrada Sensor 2                    *
  99          sbit sel_C = P3^7;          //Entrada Sensor 1                    *
 100          
 101          sbit lock = P1^7;           //Relevo  
 102          sbit Rele_Atasco = P0^3;        //Rele de on/off del verificador o transporte
 103          sbit led_err_imp = P0^2;      //Error   
 104          
 105          /*pines de ip tibbo*/
 106          
 107          sbit rx_ip = P0^0;    
 108          /*variables externas*/
 109          
 110          extern unsigned char g_cEstadoComSoft;
 111          extern unsigned char ValTimeOutCom;
 112          extern unsigned char g_cContByteRx;
 113          extern unsigned char xdata Buffer_Rta_Lintech[];
 114          
 115          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
 116          extern unsigned char Timer_wait;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 3   

 117          extern unsigned int  SIN_COBRO;
 118          extern unsigned char  Tarjeta_on;
 119          extern unsigned char cnt__ask_off;
 120          extern  unsigned char Tipo_Vehiculo;
 121          extern  unsigned char  Debug_Tibbo;                                                   /*variable q define expedicion de tarjetas 1=
             - automatico 0= a boton configurable en eeprom*/
 122          extern unsigned char placa[];
 123          /*externo bit*/
 124          
 125          extern bit aSk;
 126          extern bit buffer_ready;
 127          extern bit placa_ready;
 128          
 129          /*----------------------------------------------------------------------------
 130          Definiciones de sequencias de verificador y expedidor
 131          ------------------------------------------------------------------------------*/
 132          
 133          #define SEQ_INICIO                      0X00  
 134          #define SEQ_RESPUESTA_TRANSPORTE        0X01
 135          #define SEQ_CMD_ACEPTADO                0x02
 136          #define SEQ_MOVER_CARD_RF               0x03
 137          #define SEQ_CARD_INSERCION_ON           0x04
 138          #define SEQ_TIPO_CARD                   0X05
 139          #define SEQ_LOAD_PASSWORD               0X06
 140          #define SEQ_READ_SECTOR_BLOQUE          0X07
 141          #define SEQ_WRITE_SECTOR_BLOQUE         0X08
 142          #define SEQ_CAPTURE_CARD                0X09
 143          #define SEQ_CARD_INSERCION_OFF          0x0a
 144          #define SEQ_EXPULSAR_CARD               0x0b
 145          #define SEQ_LOAD_EEPROM                 0x0c
 146          #define SEQ_FRONT_CARD                  0x0d
 147          #define SEQ_ESPERA_VEHICULO_ENTRE       0x0e
 148          #define SEQ_DETAIL_CARD                 0x0f
 149          #define SEQ_PTO_PARALELO                0x10
 150          #define SEQ_WAIT_PLACA                  0x11
 151          #define SEQ_UID                         0X12
 152          #define SEQ_LPR                         0X13  
 153          #define SEQ_TIPO_TARJETAS               0X14
 154          #define SEQ_CAPTURE_CARD_LOOP           0X15
 155          #define SEQ_POWER_OFF                   0X16
 156          #define SEQ_POWER_ON                    0X17
 157          
 158          /*----------------------------------------------------------------------------
 159          Definiciones de sequencias de tareas del verificador y expedidor
 160          ------------------------------------------------------------------------------*/
 161          #define TAREA_PRESENCIA_VEHICULAR             0X00  
 162          #define TAREA_TIPO_TARJETA                    0X01
 163          #define TAREA_LECTURA_TARJETA_SECTOR_BLOQUE   0x02
 164          #define TAREA_WRITE_TARJETA_SECTOR_BLOQUE     0X03
 165          #define TAREA_OPEN_BARRERA                    0X04
 166          #define TAREA_WRITE_PLACA_CARD                0x05
 167          #define TAREA_TIPO_MENSUAL                    0x06
 168          #define TAREA_UID                             0X07
 169          
 170          /*----------------------------------------------------------------------------
 171           definiciones de lintech en la inicializacion de expedidor o verificador
 172          ------------------------------------------------------------------------------*/
 173          
 174          #define INICIA_LINTECH          0x30
 175          #define SEQ_CAPTURE_DATOS_INI   0x31
 176          #define GRABA_EEPROM            0x32
 177          #define SEQ_CAPTURA_OK_EEPROM   0X33
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 4   

 178          #define FIN_OK                  0x00
 179          
 180          
 181          #define True                    0x01
 182          #define False                   0x00
 183          /*----------------------------------------------------------------------------
 184           Definicion de datos asociados al buffer de resetcion del dato del trnasporte 
 185          
 186          ------------------------------------------------------------------------------*/
 187          
 188          
 189          #define ON    1
 190          #define OFF   0
 191          /*----------------------------------------------------------------------------
 192           ERRORES pto serie 
 193          
 194          ------------------------------------------------------------------------------*/
 195          #define REENVIA_TRAMA     0
 196          #define ESPERA_MAS_TIEMPO 1
 197          /*----------------------------------------------------------------------------
 198           definiciones de lintech en la inicializacion de expedidor o verificador
 199           funcion usada en lintech que me debuelve la respuesta de comunicacion del expedidor
 200           o verificador Trama_Validacion_P_N()
 201          RSPT_TRP_OK             (0) respuesta_transporte_oksignifica que la trama es valida y continua en el proceso
 202          NO_RSPD_TRP_PTO_COM     (1) no_responde_trasnporte_pto_com se cumple el tiempo de espera
 203          ESPR_RSPT_TRP_TRAMA     (2)Espera_respuesta_transporte_trama
 204          ERROR_TRP_TRAMA         (3) error_transpote_trama
 205          ------------------------------------------------------------------------------*/
 206          #define   RSPT_TRP_OK           0
 207          #define   NO_RSPD_TRP_PTO_COM   1
 208          #define   ESPR_RSPT_TRP_TRAMA   2
 209          #define   ERROR_TRP_TRAMA       3
 210          
 211          
 212          /*----------------------------------------------------------------------------
 213           definiciones de lintech en el comando Check_Status
 214          ------------------------------------------------------------------------------*/
 215          
 216          #define SENSOR_DETAIL       0x31
 217          #define SENSOR_NORMAL       0x30
 218          
 219          /*------------------------------------------------------------------------------
 220           definiciones de lintech en el comando Card_Insercion
 221          ------------------------------------------------------------------------------*/
 222          
 223          #define Habilita        0x30
 224          #define Inhabilita      0x31
 225          
 226          /*------------------------------------------------------------------------------
 227          Definicion de Lintech en el comando Inicializa
 228          ------------------------------------------------------------------------------*/
 229          
 230          #define TO_FRONT        '0'
 231          #define CAPTURE_BOX     '1'
 232          #define SIN_MOVIMIENTO  '3'
 233          
 234          /*------------------------------------------------------------------------------
 235          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 236          MovPos_Front        '0'   -> mueve  tarjeta al frente pero no la suelta
 237          MovPos_IC           '1'   ->mueve la tarjeta en posicion de read/write IC
 238          MovPos_RF           '2'   ->mueve tarjeta a RF card read/write
 239          MovPos_Capture      '3'   ->captura la tarjeta
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 5   

 240          MovPos_EjectFront   '9'   ->lanza la tarjeta del mecanismo
 241          
 242          ------------------------------------------------------------------------------*/
 243          
 244          #define   MovPos_Front        '0'   
 245          #define   MovPos_IC           '1'
 246          #define   MovPos_RF           '2'
 247          #define   MovPos_Capture      '3'
 248          #define   MovPos_EjectFront   '9'
 249          
 250          /*------------------------------------------------------------------------------
 251          Definicion de la trama Lintech de las respuestas de los cmd
 252          ------------------------------------------------------------------------------*/
 253          
 254          #define Pos_Length          3
 255          #define Pos_TipoResp        4
 256          #define Pos_St0             7
 257          #define Pos_St1             8
 258          #define Pos_St2             9
 259          #define Pos_IniDatMF        0x0a
 260          #define Card_type_H         0x0a
 261          #define Card_type_L         0x0b
 262          #define Rtype               0x0A
 263          /*------------------------------------------------------------------------------
 264          Definicion del estado de st0,st1,st2 de la trama Lintech 
 265          NO_CARDS_IN_MCNSM -> No tiene tarjetas en el mecanismo      sto=0
 266          CARD_IN_MOUTH     -> hay una tarjeta dentro del bessel      st0=1
 267          CARD_OK_READ_RF   -> Tarjeta en posicion para leer/escribir dentro del mecanismo st0=2
 268          NO_HAVE_CARDS     -> no tiene tarjetas en el deposito st1=0
 269          LOW_NIVEL_CARDS   -> nivel bajo de tarjetas en el deposito  st1=1
 270          FULL_CARD         -> Deposito de tarjetas esta lleno        st1=2
 271          ------------------------------------------------------------------------------*/
 272          
 273          
 274          #define NO_CARDS_IN_MCNSM   '0'
 275          #define CARD_IN_MOUTH       '1'
 276          #define CARD_OK_READ_RF     '2'
 277          #define NO_HAVE_CARDS       '0'
 278          #define LOW_NIVEL_CARDS     '1'
 279          #define FULL_CARD           '2'
 280          /*----------------------------------------------------------------------------
 281          Comprobacion automatica del tipo de tarjeta 
 282          checking RF card type
 283          Card_type_H   Card_type_L  explicacion
 284              0             0           tarjeta desconocida
 285              1             0           MF50
 286              1             1           MF70
 287              1             2           MF_UL
 288              2             0           TYPE_A_CPU
 289          ------------------------------------------------------------------------------*/
 290          #define MF50_HIGH             '1'
 291          #define MF50_LOW              '0'
 292          #define OPERATE_FAIL          0X6F
 293          
 294          /*----------------------------------------------------------------------------
 295          definicion de recepcion serial 
 296          ------------------------------------------------------------------------------*/
 297          
 298          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 299          
 300          /*----------------------------------------------------------------------------
 301          tiempo de delay entre funciones
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 6   

 302          ------------------------------------------------------------------------------*/
 303          
 304          #define   TIME_CARD         100   //50
 305          #define   TIME_WAIT         18
 306          /*----------------------------------------------------------------------------
 307          definicion de datos de trama lintech
 308          ------------------------------------------------------------------------------*/
 309          
 310          //#define   ETX               03
 311          #define   STX_LINTECH       0xf2
 312          
 313          /*----------------------------------------------------------------------------
 314          msj de lcd tarjeta y lcd serie
 315          ------------------------------------------------------------------------------*/
 316          /*Los cmd PRMR son enviados por el primario*/
 317          #define PRMR_ERROR_LOOP         0XE0
 318          #define ERROR_LOOP              170
 319          #define PRMR_ERROR_COD_PARK     0XE5
 320          #define ERROR_COD_PARK          171
 321          #define PRMR_TARJETA_INVALIDA   0XE1
 322          #define PULSE_BOTON             172
 323          #define PRMR_TARJETA_SIN_FORMATO  0xDF
 324          #define TARJETA_SIN_FORMATO       173
 325          
 326          #define PRMR_NO_CARD_MENSUAL          0XFC
 327          #define NO_CARD_MENSUAL         176
 328          #define TARJETA_INVALIDA        177
 329          
 330          #define PRMR_NO_ROTACION              0XFD
 331          
 332          #define PRMR_SIN_SALIDA             0XE9
 333          #define SIN_SALIDA              178
 334          #define REGISTRA_INGRESO        179
 335          
 336          #define PRMR_TARJETA_VENCIDA          0XEC
 337          #define TARJETA_VENCIDA         180
 338          #define PRMR_ERROR_TIPO_VEHICULO      0XF8
 339          #define PRMR_MENSUAL_FUERA_HORARIO    0Xb5
 340          #define MENSUAL_FUERA_HORARIO   181
 341          #define ERROR_MF1               0XE2
 342          #define HORARIO_NO_PROG         182
 343          
 344          #define SIN_INGRESO             0XE6
 345          #define SIN_PAGO                0XE7
 346          #define EXCEDE_GRACIA           0XE8
 347          
 348          
 349          
 350          
 351          
 352          
 353          #define GRACIAS                 0XFF
 354          
 355          
 356          
 357          #define IN_HORARIO  0XB8
 358          #define EXPIRO    0Xb4
 359          #define HORARIO   0Xb5
 360          #define DiaX    0XB9
 361          
 362          
 363          #define BIENVENIDO              0XFE
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 7   

 364          #define NO_CARD                 0xFA  
 365          
 366          #define RETIRE_TARJETA          0XA1
 367          
 368          #define LOW_CARD                0x01
 369          #define ATASCADO                0x02
 370          #define AUDIO_ENTRADA     0XA0
 371          #define AUDIO_CAJA        0XA1
 372          #define AUDIO_GRACIAS     0XA2
 373          /*----------------------------------------------------------------------------
 374          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 375          ------------------------------------------------------------------------------*/
 376          
 377          #define   ENVIADOS          0X0
 378          #define   RESPUESTA         0X01
 379          /*
 380          definicion  de daos del reloj
 381                    */
 382          
 383          #define RDIA            0x87
 384          #define RMES            0x89
 385          #define RANO            0x8D
 386          #define RDIA_SEMANA     0x8B
 387          #define RHORA           0x85
 388          #define RMIN            0x83
 389          #define Sabado          7
 390          #define Domingo         1
 391          /*----------------------------------------------------------------------------
 392          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 393          (0) si el dato es cero esta inactiva
 394          (1) activa o ROTACION
 395          (2) mensualidad
 396          ------------------------------------------------------------------------------*/
 397          enum Tipos_MF_TIPO_TARJETA{
 398            INACTIVA,         
 399            ROTACION,           
 400            MENSUALIDAD,
 401            PREPAGO,
 402            CORTESIA,
 403            LOCATARIO,
 404            TARJETA_PERDIDA = 0X10,
 405            INHABILITADA = 0X11
 406          };
 407          /*----------------------------------------------------------------------------
 408          posicion de  MF  bloque 1 sector 1
 409          (0) tipo de tarjeta 
 410          (01) el id del cliente
 411          (03)codigo del parqueadero  
 412          ------------------------------------------------------------------------------*/
 413          #define   MF_TIPO_TARJETA   0X00
 414          #define   MF_COD_PARK       0x01      //MF_ID_CLIENTE
 415          #define   MF_ID_CLIENTE     0x03      //MF_COD_PARK
 416          
 417          /*----------------------------------------------------------------------------
 418          posicion de  MF bloque 2 sector 1
 419          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 420          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 421          ------------------------------------------------------------------------------*/
 422          
 423          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 424          
 425          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 8   

 426          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 427                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
 428          #define   MF_LSB            0x06
 429          
 430          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 431          
 432          #define   MF_IN_PAGO        0x09
 433          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 434          
 435          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 436          
 437          #define   MF_MENSUAL_ANO      0X05
 438          #define   MF_MENSUAL_MES      0X06
 439          #define   MF_MENSUAL_DIA      0X07
 440          
 441          #define   MF_UID_0      0X04
 442          #define   MF_UID_1      0X05
 443          #define   MF_UID_2      0X06
 444          #define   MF_UID_3      0X07
 445          
 446          #define   MF_EXPIRA_ANO     0X08
 447          #define   MF_EXPIRA_MES     0X09
 448          #define   MF_EXPIRA_DIA     0X0A
 449          
 450          #define   HABILITA_ADDR     15
 451          #define   Segundo_Tiempo    16
 452          
 453          enum Hora_Minutos_addr{
 454            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 455            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 456          };
 457          
 458          enum Estados_Expedidor{
 459           EstadoActual,
 460           EstadoPasado,
 461           EstadoFuturo,
 462           TareadelCmd  
 463          };
 464          enum expedidor {
 465           Sector,        
 466           Bloque,        
 467           Tipo_Tarjeta,
 468           Apb,
 469           Horario,
 470           Pico_Placa,
 471           Type_Vehiculo,
 472           Uid_0,
 473           Uid_1,
 474           Uid_2,
 475           Uid_3,
 476           Expira_ano,
 477           Expira_mes,
 478           Expira_dia
 479           
 480          };
 481          /*tipos de APB antipassback*/
 482          enum Tipos_MF_APB{
 483            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 9   

 484            APB_INICIADO,       
 485            APB_INT,              
 486            APB_OUT,              
 487            APB_NO              
 488          };
 489          /*tipo de vehiculo*/
 490          /*Sectores y bloques de Mf*/
 491          enum MF_Sector_Bloque{
 492            Sector_0,
 493            Sector_1,
 494            Sector_2,
 495            Bloque_0 = 0,
 496            Bloque_1 = 1,
 497            Bloque_2 = 2
 498          };
 499          /*comandos pto paralelo*/
 500          enum CMD_Trama_Pto_Paralelo{
 501            STX=02,
 502            CMD_PTO_PARALELO_EXPEDIDOR='a',
 503            ETX= 03,
 504            NULL=0,
 505            CMD_MONITOR_EXPEDIDOR='E',
 506            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 507          };
 508          enum EE_AntiPassBack{
 509            APB_INHABILITADO_SOFT,
 510            APB_HABILITADO_SOFT
 511          };  
 512          enum Tipos_Vehiculos{
 513              AUTOMOVIL,          
 514              MOTO,
 515              BICICLETA
 516          };  
 517          
 518          /*DATOS DE CONFIGURACION EEPROM*/
 519          #define EE_ID_CLIENTE           0x0000
 520          #define EE_ID_PARK              0x0002
 521          #define EE_DEBUG                0x0008
 522          #define EE_USE_LPR              0x000A
 523          #define EE_CARD_AUTOMATIC_BOTON 0x000f
 524          #define EE_HABILITA_APB         0x0010
 525          #define EE_PLACA                0X0011
 526          #define EE_VALIDA_TIPO_VEHICULO_MENSUAL 0X0014
 527          #define EE_HABILITA_APB_MENSUAL 0X0015
 528          
 529          /*----------------------------------------------------------------------------
 530          Definicion de varaibles globales del objeto
 531          ------------------------------------------------------------------------------*/
 532          
 533          static unsigned char Estado=INICIA_LINTECH;
 534          bit MenSual = False;
 535          /*------------------------------------------------------------------------------
 536          
 537          ------------------------------------------------------------------------------*/
 538          unsigned char Captura_Expulsa()
 539          {
 540   1        unsigned char Estado_expedidor;
 541   1        
 542   1        
 543   1        if(MenSual !=  True)
 544   1        {
 545   2          Estado_expedidor=SEQ_CAPTURE_CARD_LOOP; //SEQ_CAPTURE_CARD;                                       
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 10  

 546   2        }
 547   1        else
 548   1        {
 549   2        
 550   2        Estado_expedidor = SEQ_EXPULSAR_CARD;//SEQ_CARD_INSERCION_OFF;  
 551   2        } 
 552   1      
 553   1      
 554   1      return  Estado_expedidor;
 555   1      }
 556          /*------------------------------------------------------------------------------
 557          funcion que valida la trama del verificador o transporte lintech
 558          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 559          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 560          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 561          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 562          
 563          
 564          ------------------------------------------------------------------------------*/
 565          
 566          char Trama_Validacion_P_N()
 567          {
 568   1        char Trama_Validacion_P_N=ESPR_RSPT_TRP_TRAMA;                                /*espera respuesta del transporte*/
 569   1            
 570   1            if ((ValTimeOutCom==1)||(buffer_ready==1) )
 571   1            {
 572   2              if (buffer_ready==1)
 573   2              {
 574   3                buffer_ready=0;
 575   3                  
 576   3              
 577   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 578   3                {
 579   4                          
 580   4                  Trama_Validacion_P_N=RSPT_TRP_OK;                                       /*trama ok*/
 581   4                    
 582   4                }
 583   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 584   3                {
 585   4                  
 586   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;                                 /*error de trama*/
 587   4                  
 588   4                }
 589   3                else
 590   3                {
 591   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
 592   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;   
 593   4                  
 594   4                }
 595   3              }
 596   2              else
 597   2              {
 598   3                          
 599   3                Trama_Validacion_P_N=NO_RSPD_TRP_PTO_COM;                                 /*pto serie no responde */
 600   3                                                  
 601   3              }
 602   2      
 603   2            }
 604   1            
 605   1        return Trama_Validacion_P_N;
 606   1      }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 11  

 607          /*------------------------------------------------------------------------------
 608          funcion de error de respuesta pto serie
 609          
 610          variable en uart. cnt__ask_off=cuenta los numeros de error pto serie y reset de transporte 
 611          se limpia cuando llega la respuesta del transporte. 
 612          Rele_Atasco = es un I/O del Mc que activa / inhabilita el rele
 613          ON    (1) esta activo 
 614          OFF   (0) inhactivo 
 615          REENVIA_TRAMA   1
 616          ESPERA_MAS_TIEMPO 0
 617          cnt_espera_ask_on= cuenta el tiempo de ASK que esta activo,sin que le llegue
 618                             la trama completa, al  5 tiempos borra el ask y retrasmite el cmd
 619          
 620          error_rx_pto= (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 621                      = (1)= REENVIA_TRAMA reenvia la trama al transporte
 622          
 623          cnt__ask_off= varible global esta definida en pto serie y es un contador , que 
 624          se limpia cada vez que la trama a llegado completa y validada
 625          
 626          aSk= significa que llego al pto serie el 06 = ask donde el transporte dice que a recibido el cmd
 627          esta ejecutando y nos enviara la respuesta,necesita tiempo esta bit esta definino en el modulo uart es glo
             -bal
 628          
 629          ------------------------------------------------------------------------------*/
 630          unsigned char error_rx_pto(void)
 631          {
 632   1      
 633   1      static unsigned cnt_espera_ask_on=0;
 634   1      unsigned char error_rx_pto=ESPERA_MAS_TIEMPO;
 635   1      
 636   1          
 637   1                
 638   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 639   1            Debug_chr_Tibbo (cnt__ask_off); 
 640   1            Debug_chr_Tibbo (cnt_espera_ask_on);
 641   1            Debug_chr_Tibbo (error_rx_pto);
 642   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 643   1            if (aSk==OFF)
 644   1            
 645   1            { 
 646   2                cnt__ask_off++;                                                                   /*cuento el error*/                                                               
 647   2              if(cnt__ask_off>=10)
 648   2              { 
 649   3                Debug_txt_Tibbo((unsigned char *) "ATASCADO RESET\r\n\r\n");                                                                      /*no c
             -ontesta debe reset el transporte*/
 650   3                Rele_Atasco=ON;                                                                   /*off el rele de reset del verificador*/    
 651   3                Delay_10ms(110);
 652   3                cnt__ask_off=0;                                                                   /*limpio ls errores*/
 653   3                cnt_espera_ask_on=0;
 654   3                error_rx_pto=ESPERA_MAS_TIEMPO;                                                   /**/
 655   3                Rele_Atasco=OFF;  
 656   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 657   3                ValTimeOutCom=TIME_CARD;
 658   3              }
 659   2              else;
 660   2              {
 661   3                error_rx_pto=REENVIA_TRAMA;                                                       /*1 reenvia trama*/
 662   3                ValTimeOutCom=TIME_CARD;
 663   3              }
 664   2            }                                                                                     /*aSk esta activo */
 665   1            else
 666   1            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 12  

 667   2                cnt_espera_ask_on++;                                                              /*cuento n tiempos de ask para recibir el total de
             - la trama*/
 668   2              if(cnt_espera_ask_on>=3)
 669   2              {
 670   3                cnt__ask_off=0;                                                                   /*paso tiempo de espera y no se completo la trama 
 671   3                                                                                                  limpio los reg y reenvio la trama y ask=off*/
 672   3                cnt_espera_ask_on=0;
 673   3                error_rx_pto=REENVIA_TRAMA;
 674   3                aSk=OFF;
 675   3                ValTimeOutCom=TIME_CARD;
 676   3              }
 677   2              else
 678   2              {
 679   3                cnt__ask_off=0;                                                                   /*damos tiempo de espera de la trama del transporte*
             -/
 680   3                error_rx_pto=ESPERA_MAS_TIEMPO;;
 681   3                ValTimeOutCom=TIME_CARD;
 682   3              }
 683   2            }
 684   1              return (error_rx_pto);
 685   1      }
 686          /*------------------------------------------------------------------------------
 687          Funcion de respuesta a los cmd del transporte
 688          Retorna rta_cmd_transporte el estado en que queda
 689          Recibe tres datos unos es el 
 690          Estado_futuro= significa que la respuesta fue ok
 691          Estado_Error= en caso de que aya un error a que estado envia el codigo
 692          Estado_Actua= No ha llegado la respuesta y sigue en el mismo estado
 693          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 694          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 695          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 696          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 697          
 698          (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 699          (1)= REENVIA_TRAMA reenvia la trama al transporte
 700          ------------------------------------------------------------------------------*/
 701          unsigned char   rta_cmd_transporte(unsigned char *secuencia_Expedidor )
 702          {
 703   1        unsigned char temp;
 704   1        unsigned char EstadoComSeqMF;
 705   1        
 706   1            
 707   1      if((temp=Trama_Validacion_P_N())!=RSPT_TRP_OK )
 708   1          {
 709   2            if(temp==ESPR_RSPT_TRP_TRAMA)                                                         /*no he recibido respuesta espero*/
 710   2            {
 711   3            EstadoComSeqMF= *(secuencia_Expedidor + EstadoActual);                    //                                  /*SEQ_RTA_CARD_POSno
             - ha respondido*/
 712   3            } 
 713   2            else if (temp==ERROR_TRP_TRAMA)
 714   2            {
 715   3            Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR\r\n\r\n");                     /* trama no valida respuesta inco
             -rrecta falla en la escritura */
 716   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 717   3            EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                         /*SEQ_INICIO (3) Tram
             -a invalida cmd (N)reenvio cmd*/ 
 718   3            }     
 719   2            else
 720   2            {
 721   3            /*Dispensador No Responde PTO SERIE ...*/
 722   3          
 723   3              if(temp=error_rx_pto()==ESPERA_MAS_TIEMPO)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 13  

 724   3              {
 725   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoActual); 
 726   4              }                                                                                     /*SEQ_RTA_CARD_POS;*/
 727   3              else                                                                                  //(temp=error_rx_pto()==REENVIA_TRAMA)
 728   3              {
 729   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                     /*SEQ_INICIO*/
 730   4              }                                                 
 731   3            }       
 732   2          }
 733   1          else
 734   1          {
 735   2            
 736   2            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);
 737   2            EstadoComSeqMF=*(secuencia_Expedidor + EstadoFuturo); 
 738   2          }
 739   1        return EstadoComSeqMF;
 740   1      }
 741          
 742          /*------------------------------------------------------------------------------
 743          ------------------------------------------------------------------------------*/
 744          unsigned char Analiza_Presencia_Mensual()
 745          {
 746   1        unsigned char Estado_expedidor;
 747   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 748   1          {
 749   2            MenSual = True;
 750   2            Estado_expedidor = SEQ_TIPO_CARD;                 //SEQ_UID
 751   2          }
 752   1        else
 753   1          { 
 754   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 755   2              send_portERR(PRMR_ERROR_LOOP);
 756   2              PantallaLCD(ERROR_LOOP);
 757   2              Estado_expedidor = SEQ_EXPULSAR_CARD;
 758   2                    
 759   2          }
 760   1        return Estado_expedidor;
 761   1      }
 762          unsigned char Analiza_Presencia_rotacion()
 763          {
 764   1        unsigned char Estado_expedidor;
 765   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 766   1          {
 767   2            
 768   2            Estado_expedidor = SEQ_MOVER_CARD_RF;                 //SEQ_UID
 769   2          }
 770   1        else
 771   1          { 
 772   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 773   2              send_portERR(PRMR_ERROR_LOOP);
 774   2              PantallaLCD(ERROR_LOOP);
 775   2              Estado_expedidor = SEQ_INICIO;  //SEQ_EXPULSAR_CARD;
 776   2                    
 777   2          }
 778   1        return Estado_expedidor;
 779   1      }
 780          /*------------------------------------------------------------------------------
 781          Funcion numero unico de identificacion
 782          ------------------------------------------------------------------------------*/
 783          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor )
 784          {
 785   1        unsigned char Estado_expedidor;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 14  

 786   1        unsigned char temp;
 787   1        unsigned char buffer_UID[17];
 788   1          if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
 789   1            {
 790   2              
 791   2                for (temp=0; temp<16; ++temp)
 792   2                {
 793   3                  buffer_UID [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de M
             -F en un arreglo*/
 794   3                 
 795   3                }
 796   2                
 797   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
 798   2                DebugBufferMF(buffer_UID,16,RESPUESTA);
 799   2                
 800   2        
 801   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
 802   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_0]));  
 803   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_1]));  
 804   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_2]));  
 805   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_3]));
 806   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
 807   2                
 808   2              *(Atributos_Expedidor + Uid_0) = buffer_UID [MF_UID_0];   
 809   2              *(Atributos_Expedidor + Uid_1) = buffer_UID [MF_UID_1];     
 810   2              *(Atributos_Expedidor + Uid_2) = buffer_UID [MF_UID_2];     
 811   2              *(Atributos_Expedidor + Uid_3) = buffer_UID [MF_UID_3]; 
 812   2              Estado_expedidor=SEQ_LOAD_PASSWORD;                                                       //SEQ_TIPO_CARD;
 813   2            }   
 814   1            else
 815   1            {
 816   2              Estado_expedidor=SEQ_POWER_OFF;
 817   2            } 
 818   1            return Estado_expedidor;
 819   1      }
 820          /*------------------------------------------------------------------------------
 821          Se analiza si expulsa la tarjeta por boton o automatica
 822          ------------------------------------------------------------------------------*/
 823          unsigned char Ingreso_Vehiculo(void)
 824            {
 825   1          unsigned char CardAutomatic;  
 826   1          static unsigned char pulseboton=0;
 827   1        
 828   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 829   1          {
 830   2            CardAutomatic=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);  
 831   2            
 832   2            if (CardAutomatic==True)                                                    //se pregunta si expide la tarjeta automatica o por p
             -resionar el boton
 833   2              {
 834   3                Debug_txt_Tibbo((unsigned char *) "Tarjeta: Automatico\r\n");           //expide tarjetas automatico con p
             -resencia
 835   3                                                                                        // muevo la tarjeta hasta el lector de rf
 836   3                Estado=SEQ_MOVER_CARD_RF;                                               // valido el cmd enviado al verificador
 837   3               }
 838   2            else
 839   2              {     
 840   3                  if(pulseboton==False)
 841   3                  { PantallaLCD(PULSE_BOTON); 
 842   4                  }
 843   3                  else
 844   3                   {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 15  

 845   4                     pulseboton++;
 846   4                    
 847   4                   
 848   4                   }
 849   3                    sel_Pulsa();                                                        //se valida el pulsador en hardware
 850   3                    if (DataIn!=True)       
 851   3                      {
 852   4                        Debug_txt_Tibbo((unsigned char *) "Pulsador Activo\r\n");       //el pulsador fue presionado
 853   4                        pulseboton=0;                                                               //muevo tarjeta hasta el lector de RF
 854   4                        Estado=SEQ_MOVER_CARD_RF;                                       //valido el cmd enviado al verificador
 855   4                      }
 856   3                    else
 857   3                        {
 858   4                          Estado=SEQ_INICIO;  
 859   4                        }
 860   3                  
 861   3              } 
 862   2          }
 863   1          else
 864   1              { 
 865   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 866   2                Estado=SEQ_INICIO;  
 867   2              }
 868   1        return Estado;
 869   1      }
 870           
 871          /*------------------------------------------------------------------------------
 872          Se pregunta por el estado del expedidor si hay tarjetas y presencia para expulsar tarjeta
 873          o si hay tarjeta en la boca o rf para entrar en mensuales
 874          ------------------------------------------------------------------------------*/
 875          
 876          unsigned char Responde_Estado_Sensores_Transporte()
 877          {
 878   1        unsigned char Estado_expedidor;
 879   1          
 880   1            Debug_txt_Tibbo((unsigned char *) "TAREA_PRESENCIA_VEHICULAR\r\n");                                 // trama valida Hab
             -ilitado 
 881   1          
 882   1            if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                                 // CANAL LIBRE    no tiene 
             -tarjetas en el mecanismo
 883   1            {
 884   2                
 885   2              if  ((Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS)||(Buffer_Rta_Lintech[Pos_St1]==FULL_CARD  ))  //  se
             - detecta la tarjeta en la boca TARJETA EN BEZZEL
 886   2              {
 887   3                if (Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS  )                                             // nivel de tarjetas
 888   3                  {
 889   4                    Debug_txt_Tibbo((unsigned char *) "Nivel bajo de tarjetas\r\n");                            // nivel bajo de tarj
             -etas 
 890   4                    send_portERR(LOW_CARD);                                                                     //envio msj al primario
 891   4                  //  PantallaLCD(LOW_CARD);                                                                            //envio msj por la raspberry nivel ba
             -jo de tarjetas
 892   4                    Estado_expedidor=Ingreso_Vehiculo();        
 893   4                   }
 894   3                   else
 895   3                      {
 896   4                        /*respuesta ok*/
 897   4                       Estado_expedidor=Ingreso_Vehiculo();
 898   4                      
 899   4                      }
 900   3              } 
 901   2              else 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 16  

 902   2                  {
 903   3                    /*dispensador no posee tarjetas*/
 904   3                    Debug_txt_Tibbo((unsigned char *) "Dispensador SIN TARJETAS...\r\n"); 
 905   3                    
 906   3                    send_portERR(NO_CARD);  
 907   3                                                                          // se envia msj al uC principal, visualiza en el lcd que no hay tarjetas
 908   3                  //  PantallaLCD(NO_CARD);   
 909   3                    Estado_expedidor=SEQ_INICIO;                                                                //inicio el loop
 910   3                   }
 911   2            }
 912   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
 913   1              {
 914   2                    /*hay una tarjeta en la boca del verificador */
 915   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                                //se envia msj al debug
             -er q hay tarjeta en la boca
 916   2                                                                                                                //se habilita recepcion de tarjetas por boca
 917   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;                                                     //se trabaja mensual        
 918   2              }
 919   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
 920   1                  
 921   1              {
 922   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en RF\r\n");
 923   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;
 924   2              }
 925   1            else
 926   1              {
 927   2                Estado_expedidor=SEQ_INICIO;  
 928   2              }
 929   1        return Estado_expedidor;  
 930   1      }
 931          
 932          /*------------------------------------------------------------------------------
 933          Funcion que nos dice el tipo de tarjeta que tiene en el mecanismo
 934          Comprobacion automatica del tipo de tarjeta 
 935          checking RF card type
 936          Card_type_H   Card_type_L  explicacion
 937              0             0           tarjeta desconocida
 938              1             0           MF50
 939              1             1           MF70
 940              1             2           MF_UL
 941              2             0           TYPE_A_CPU
 942          
 943          #define MF50_HIGH             '1'
 944          #define MF50_LOW              '0'
 945          ------------------------------------------------------------------------------*/
 946          unsigned char Responde_Tipo_Tarjeta()
 947            {
 948   1          unsigned char Estado_expedidor;
 949   1          
 950   1            Debug_txt_Tibbo((unsigned char *) "TAREA_TIPO DE TARJETA\r\n");                         // trama valida Habilitado 
 951   1            
 952   1        if (Buffer_Rta_Lintech[Card_type_H]==MF50_HIGH)                                             /* pregunto si la tarjeta en el tra
             -nsporte es MF 50 */
 953   1          {
 954   2          if (Buffer_Rta_Lintech[Card_type_L]==MF50_LOW)  
 955   2            {
 956   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n");                         /* trama valida son MF50*/
 957   3              if(MenSual ==  True)
 958   3              {
 959   4              Estado_expedidor = SEQ_UID;                                                             //SEQ_LOAD_PASSWORD;                        
 960   4              }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 17  

 961   3              else  
 962   3              {
 963   4                Estado_expedidor = SEQ_LOAD_PASSWORD;
 964   4              }         
 965   3            }
 966   2            else
 967   2              {
 968   3                 if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
 969   3                {
 970   4                Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida1 no es MF50\r\n");            /* trama no valida */
 971   4                send_portERR(PRMR_TARJETA_INVALIDA);                                                              /*envio msj principal tarjeta inva
             -lidad*/
 972   4                PantallaLCD(TARJETA_INVALIDA);
 973   4                        
 974   4                  Estado_expedidor = Captura_Expulsa(); 
 975   4                
 976   4                } 
 977   3                else  
 978   3                {
 979   4                  MenSual = False;
 980   4                  Estado_expedidor = SEQ_INICIO;    
 981   4                }           
 982   3              }
 983   2          }
 984   1          else 
 985   1            {
 986   2               if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta 
             -en la boca TARJETA EN BEZZEL
 987   2                {
 988   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");           /* trama no valida */
 989   3              //send_portERR(AUDIO_GRACIAS);                                                              /*error audio*/ 
 990   3              send_portERR(PRMR_TARJETA_INVALIDA);                                                              //la tarjeta no es valida 
 991   3              PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la raspber
             -ry*/
 992   3                        
 993   3                  Estado_expedidor = Captura_Expulsa(); 
 994   3                          
 995   3                  
 996   3                }
 997   2                else  
 998   2                {
 999   3                  MenSual = False;
1000   3                  Estado_expedidor = SEQ_INICIO;    
1001   3                }                     
1002   2            }
1003   1                    
1004   1          return Estado_expedidor;                                                                                                  
1005   1        } 
1006          /*------------------------------------------------------------------------------
1007            Funcion que lee los datos en el Sector 1 Bloque 1
1008            se lee
1009            ID_CLIENTE
1010            COD_PARK
1011            TIPO DE TARJETA
1012            EXPIRA_ANO
1013            EXPIRA_MES
1014            EXPIRA_DIA
1015          ------------------------------------------------------------------------------*/
1016          
1017          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
1018          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 18  

1019   1        unsigned char temp;
1020   1        unsigned char Estado_expedidor;
1021   1        unsigned char buffer_S1_B1[17];
1022   1        unsigned char ID_CLIENTE;
1023   1        unsigned char COD_PARK;   
1024   1        static unsigned char falla=0;
1025   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE1\r\n");   
1026   1                                        
1027   1                                      
1028   1            
1029   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1030   1            {
1031   2              
1032   2                for (temp=0; temp<16; ++temp)
1033   2                {
1034   3                  buffer_S1_B1 [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de
             - MF en un arreglo*/
1035   3                 
1036   3                }
1037   2                
1038   2                
1039   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b1\r\n");
1040   2                DebugBufferMF(buffer_S1_B1,16,RESPUESTA);
1041   2                ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1042   2                COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
1043   2                /*Compara  MF_ID_CLIENTE y MF_COD_PARK con el codigo del parqueadero ID_CLIENTE  COD_PARK*/
1044   2                
1045   2                if (((buffer_S1_B1 [ MF_ID_CLIENTE])==ID_CLIENTE) && ((buffer_S1_B1 [ MF_COD_PARK] ) == COD_PARK)||((
             -ID_CLIENTE==0)&&(COD_PARK==0)))   
1046   2                {
1047   3                    
1048   3                  Debug_txt_Tibbo((unsigned char *) "CARD ID_CLIENTE: ");               
1049   3                  Debug_HexDec((buffer_S1_B1 [ MF_ID_CLIENTE]));
1050   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1051   3                  
1052   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");                
1053   3                  Debug_HexDec(ID_CLIENTE);
1054   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1055   3                  
1056   3                  Debug_txt_Tibbo((unsigned char *) "CARD COD_PARK:");                    
1057   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1058   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1059   3                  
1060   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");                   
1061   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1062   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1063   3      
1064   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
1065   3                  Debug_chr_Tibbo(buffer_S1_B1 [MF_TIPO_TARJETA]);
1066   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1067   3                  
1068   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S1_B1 [MF_TIPO_TARJETA];
1069   3                  /*fecha de vencimiento de mensual o prepago*/
1070   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S1_B1 [MF_EXPIRA_ANO];
1071   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S1_B1 [MF_EXPIRA_MES];
1072   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S1_B1 [MF_EXPIRA_DIA];
1073   3                  
1074   3                  *(Atributos_Expedidor + Sector) = Sector_1;
1075   3                  *(Atributos_Expedidor + Bloque) = Bloque_2;
1076   3                  falla=0;
1077   3                  Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1078   3              
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 19  

1079   3                }
1080   2                else
1081   2                {
1082   3                  falla=0;
1083   3                  Debug_txt_Tibbo((unsigned char *) "ERROR COD PARK\r\n");
1084   3                  send_portERR(PRMR_ERROR_COD_PARK);
1085   3                  PantallaLCD(ERROR_COD_PARK);                                                        //envio el msj por la pantalla lcd o la rasp
             -berry
1086   3                  Estado_expedidor = Captura_Expulsa();                                                 //   codigo de parqueo erro expulso la 
             -tarjeta     
1087   3                }
1088   2            }
1089   1            else
1090   1            {
1091   2                
1092   2              if ((Buffer_Rta_Lintech[Rtype]) == OPERATE_FAIL)
1093   2              {
1094   3                falla++;
1095   3              }
1096   2               if (falla <= 2)
1097   2                
1098   2              {
1099   3                Debug_txt_Tibbo((unsigned char *) "ERROR OPERATE FAIL\r\n");
1100   3                Estado_expedidor = SEQ_POWER_ON;
1101   3                                    
1102   3              }
1103   2              else
1104   2              {
1105   3                falla=0;
1106   3                Debug_txt_Tibbo((unsigned char *) "TARJETA SIN FORMATO\r\n");
1107   3                send_portERR(PRMR_TARJETA_SIN_FORMATO);
1108   3                PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la 
             -raspberry*/
1109   3               Estado_expedidor =Captura_Expulsa();   
1110   3              }
1111   2            }
1112   1            
1113   1        return Estado_expedidor;
1114   1      } 
1115          /*------------------------------------------------------------------------------
1116          
1117          ------------------------------------------------------------------------------*/
1118          
1119          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
1120          {
1121   1        unsigned char temp;
1122   1        unsigned char Estado_expedidor;
1123   1        unsigned char buffer_S1_B2[17]; 
1124   1      
1125   1            
1126   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");   
1127   1            
1128   1                              
1129   1            
1130   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1131   1            {
1132   2              
1133   2                for (temp=0; temp<16; ++temp)
1134   2                {
1135   3                  buffer_S1_B2 [temp] =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion d
             -e MF en un arreglo*/
1136   3                }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 20  

1137   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b2\r\n");
1138   2                DebugBufferMF(buffer_S1_B2,16,RESPUESTA);
1139   2                
1140   2                      
1141   2                
1142   2                Debug_txt_Tibbo((unsigned char *) "HORARIO:");
1143   2                Debug_chr_Tibbo((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1144   2                *(Atributos_Expedidor + Horario)= ((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1145   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1146   2                
1147   2                Debug_txt_Tibbo((unsigned char *) "PICO Y PLACA:");
1148   2                
1149   2                *(Atributos_Expedidor + Pico_Placa)= ((buffer_S1_B2 [MF_IN_PAGO] & 0XF0) >> 4);
1150   2                Debug_chr_Tibbo(*(Atributos_Expedidor + Pico_Placa));
1151   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1152   2                
1153   2            
1154   2                Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK:");
1155   2                Debug_chr_Tibbo(buffer_S1_B2 [MF_APB] );
1156   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1157   2              
1158   2                /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
1159   2                
1160   2                *(Atributos_Expedidor + Apb)=   buffer_S1_B2 [MF_APB] ;
1161   2                
1162   2                
1163   2                  *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S1_B2 [MF_TIPO_VEHICULO]& 0x0f;
1164   2                  Estado_expedidor =SEQ_TIPO_TARJETAS;    // Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);
1165   2            
1166   2        
1167   2            }
1168   1            else
1169   1            {
1170   2              Estado_expedidor = Captura_Expulsa(); //momentario
1171   2            }
1172   1          return Estado_expedidor;  
1173   1      }
1174          unsigned char Responde_Write_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buf
             -fer_Write_MF)
1175          {
1176   1        unsigned char Estado_expedidor;
1177   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE2\r\n"); 
1178   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b2\r\n");
1179   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1180   1        if(MenSual !=  True)
1181   1        {
1182   2        *(Atributos_Expedidor + Sector) = Sector_1;
1183   2        *(Atributos_Expedidor + Bloque) = Bloque_0;
1184   2        Armar_Trama_Tarjeta_Sector1_Bloque0(Buffer_Write_MF);
1185   2          Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1186   2        }
1187   1        else
1188   1        {
1189   2          Estado_expedidor = SEQ_LPR;
1190   2        }
1191   1        return Estado_expedidor;
1192   1      }
1193          /*----------------------------------------------------------------------------
1194          ----------------------------------------------------------------------------*/
1195          unsigned char Responde_Write_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1196          {
1197   1      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 21  

1198   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE0\r\n"); 
1199   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b0\r\n");
1200   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1201   1        
1202   1        return SEQ_LPR;
1203   1      }
1204          /*----------------------------------------------------------------------------
1205          ----------------------------------------------------------------------------*/
1206          unsigned char Pregunta_Lpr(unsigned char *Atributos_Expedidor)
1207          {
1208   1        unsigned char Estado_expedidor;
1209   1          if(rd_eeprom(0xa8,EE_USE_LPR)== True)
1210   1             {
1211   2               Debug_txt_Tibbo(Armar_Trama_Monitor(Atributos_Expedidor));
1212   2                if (rd_eeprom(0xa8,EE_DEBUG) == False)
1213   2                 {
1214   3                   Debug_Tibbo=False;
1215   3                 }
1216   2             }
1217   1        
1218   1          if (rd_eeprom(0xa8,EE_PLACA)!= False)
1219   1          {
1220   2            Estado_expedidor=SEQ_WAIT_PLACA;
1221   2            ValTimeOutCom=TIME_WAIT ;
1222   2            Timer_wait=False;
1223   2          }
1224   1          else 
1225   1          {
1226   2          Estado_expedidor=SEQ_FRONT_CARD;
1227   2          }
1228   1        return Estado_expedidor;
1229   1      }
1230          /*----------------------------------------------------------------------------
1231          ----------------------------------------------------------------------------*/
1232          unsigned char Responde_Write_Tarjeta_Sector2_Bloque0(unsigned char *Buffer_Write_MF)
1233          {
1234   1        
1235   1        Debug_txt_Tibbo((unsigned char *) "PLACA:");  
1236   1        Debug_txt_Tibbo((unsigned char *) placa);
1237   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1238   1        Debug_txt_Tibbo((unsigned char *) "Write_s2_b0\r\n");
1239   1        DebugBufferMF(Buffer_Write_MF,16,ENVIADOS);
1240   1        return SEQ_FRONT_CARD;
1241   1      }
1242          unsigned char  Respuesta_Segunda_clave(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1243          {
1244   1        Debug_txt_Tibbo((unsigned char *) "TAREA_SEGUNDA CLAVE\r\n"); 
1245   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1246   1        *(Atributos_Expedidor + Sector) = Sector_2;
1247   1        *(Atributos_Expedidor + Bloque) = Bloque_0;
1248   1        Armar_Trama_Placa(Buffer_Write_MF);
1249   1        return SEQ_WRITE_SECTOR_BLOQUE;
1250   1      }
1251          /*------------------------------------------------------------------------------
1252          ------------------------------------------------------------------------------*/
1253          //void  Armar_Trama_Tarjeta_Sector1_Bloque1(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write
             -_MF)
1254          //{
1255          //  *(Buffer_Write_MF +0) = *(Atributos_Expedidor + Tipo_Tarjeta);
1256          //  *(Buffer_Write_MF +0) = *(Atributos_Expedidor + Tipo_Tarjeta);
1257          //} 
1258          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 22  

1259          /*------------------------------------------------------------------------------
1260          ------------------------------------------------------------------------------*/
1261          
1262          void  Armar_Trama_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_M
             -F)
1263          {
1264   1        
1265   1        /*fecha de ingreso se lee año,mes,dia,hora y minutos*/
1266   1        
1267   1        Block_read_Clock_Hex(Buffer_Write_MF);
1268   1        
1269   1        /*descuentos los borro*/
1270   1        
1271   1        *(Buffer_Write_MF + 5)=0;
1272   1        *(Buffer_Write_MF + 6)=0;
1273   1        *(Buffer_Write_MF + 7)=0;
1274   1        
1275   1        if (*(Atributos_Expedidor + Tipo_Tarjeta) == ROTACION)
1276   1        {
1277   2          *(Buffer_Write_MF + 8)  = Tipo_Vehiculo;
1278   2          *(Buffer_Write_MF + 9)  = (Dir_board())- 0x30;
1279   2          *(Buffer_Write_MF +10) = APB_INT;
1280   2        }
1281   1        
1282   1        /*mensual*/
1283   1        else
1284   1        {
1285   2          
1286   2          *(Buffer_Write_MF + 8)  = (*(Atributos_Expedidor + Horario) << 4) | (*(Atributos_Expedidor + Type_Vehicu
             -lo));
1287   2          *(Buffer_Write_MF + 9)  =  (*(Atributos_Expedidor + Pico_Placa) << 4)| (Dir_board())- 0x30;
1288   2          
1289   2          if (*(Atributos_Expedidor + Apb)== APB_NO)
1290   2           {
1291   3              *(Buffer_Write_MF +10) =APB_NO;
1292   3            }
1293   2          else 
1294   2          {
1295   3            *(Buffer_Write_MF +10) =APB_INT;
1296   3          }
1297   2        }
1298   1        /*fecha de salida maxima*/
1299   1        *(Buffer_Write_MF +11)=0;
1300   1        *(Buffer_Write_MF +12)=0;
1301   1        *(Buffer_Write_MF +13)=0;
1302   1        *(Buffer_Write_MF +14)=0;
1303   1        *(Buffer_Write_MF +15)=0;
1304   1      }
1305          void Armar_Trama_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1306          {
1307   1        /*graba serie de Ticket*/
1308   1        strcpy(Buffer_Write_MF, Lee_No_Ticket());
1309   1      }
1310          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor()
1311          {
1312   1        static unsigned char buffer[28];
1313   1        unsigned char j;
1314   1        /*la trama esta compuesta de
1315   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1316   1      
1317   1        buffer[0]=STX;
1318   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 23  

1319   1        buffer[2]=NULL;
1320   1        j=strlen(Lee_No_Ticket());
1321   1        strcat(buffer , Lee_No_Ticket());
1322   1        j=j+2;
1323   1        buffer[j++]= '-';
1324   1        
1325   1        Block_read_Clock_Hex(buffer+j);         //leo la fecha de entrada
1326   1        buffer[j]=buffer[j]+0x030;              /*año de entrada*/
1327   1        buffer[j+1]=buffer[j+1]+0x030;          /*mes de entrada*/
1328   1        buffer[j+2]=buffer[j+2]+0x030;          /*dia de entrada*/
1329   1        buffer[j+3]=buffer[j+3]+0x030;          /*hora de entrada*/
1330   1        buffer[j+4]=buffer[j+4]+0x030;          /*minutos de entrada*/
1331   1        buffer[j+5]= '-';
1332   1        /*placa*/
1333   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1334   1        {   
1335   2          if (placa_ready != False)
1336   2          {
1337   3            buffer[j+6]= placa[0];
1338   3            buffer[j+7]= placa[1];
1339   3            buffer[j+8]= placa[2];
1340   3            buffer[j+9]= placa[3];
1341   3            buffer[j+10]= placa[4];
1342   3            buffer[j+11]= placa[5];
1343   3            buffer[j+12]= NULL;
1344   3          }
1345   2          else
1346   2          {
1347   3            buffer[j+6]= ' ';
1348   3            buffer[j+7]= NULL;
1349   3          }
1350   2        }
1351   1        else 
1352   1        {
1353   2          buffer[j+6]= ' ';
1354   2          buffer[j+7]=NULL;
1355   2        }
1356   1        j=strlen(buffer);
1357   1        buffer[j]= ETX;
1358   1        buffer[j+1]= NULL;
1359   1        return buffer;
1360   1      }
1361          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor)
1362          {
1363   1        static unsigned char buffer[28];
1364   1        //unsigned char j;
1365   1        /*la trama esta compuesta de
1366   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1367   1      
1368   1        buffer[0]=STX;
1369   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
1370   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
1371   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
1372   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
1373   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
1374   1        
1375   1        
1376   1        Block_read_Clock_Hex(buffer+6);         //leo la fecha de entrada
1377   1        buffer[6]=buffer[6]+0x030;              /*año de entrada*/
1378   1        buffer[7]=buffer[7]+0x030;          /*mes de entrada*/
1379   1        buffer[8]=buffer[8]+0x030;          /*dia de entrada*/
1380   1        buffer[9]=buffer[9]+0x030;          /*hora de entrada*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 24  

1381   1        buffer[10]=buffer[10]+0x030;          /*minutos de entrada*/
1382   1      
1383   1        /*placa*/
1384   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1385   1        {   
1386   2          
1387   2            buffer[11]= placa[0];
1388   2            buffer[12]= placa[1];
1389   2            buffer[13]= placa[2];
1390   2            buffer[14]= placa[3];
1391   2            buffer[15]= placa[4];
1392   2            buffer[16]= placa[5];
1393   2      
1394   2        }
1395   1      
1396   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1397   1        {
1398   2          buffer[17]= 'C';
1399   2        }
1400   1        else
1401   1        {
1402   2          buffer[17]= 'M';
1403   2        }
1404   1        
1405   1        buffer[18]= ETX;
1406   1        buffer[19]= NULL;
1407   1        return buffer;
1408   1      }
1409          unsigned char *Armar_Trama_Monitor(unsigned char *Atributos_Expedidor)
1410          {
1411   1        static unsigned char buffer[24];
1412   1        unsigned char j;
1413   1        /*la trama esta compuesta de
1414   1        STX,address_board,CMD,Tipo_Vehiculo,NoTICKET,:,fecha int añomesdishoraminuto,:,ETX*/
1415   1        Debug_Tibbo=False;
1416   1        buffer[0]=STX;
1417   1        buffer[1]=Dir_board();
1418   1        buffer[2]=CMD_MONITOR_EXPEDIDOR;
1419   1        if(Tipo_Vehiculo == AUTOMOVIL)
1420   1          {
1421   2            buffer[3]= 'C';
1422   2          }
1423   1        else
1424   1          {
1425   2            buffer[3]= 'M';
1426   2          }
1427   1          
1428   1          /*ticket*/
1429   1          if(MenSual !=  True)
1430   1          {
1431   2          buffer[4]=NULL;
1432   2          strcat(buffer , Lee_No_Ticket());
1433   2          }
1434   1          else
1435   1          {
1436   2            ByteHex_Decimal(buffer+4,*(Atributos_Expedidor + Uid_2));
1437   2            j=strlen(buffer);
1438   2            buffer[j]= ' ';
1439   2            buffer[j+1]= NULL;
1440   2            j=strlen(buffer);
1441   2            Two_ByteHex_Decimal(buffer+j,*(Atributos_Expedidor + Uid_1),*(Atributos_Expedidor + Uid_0));
1442   2            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 25  

1443   2          }
1444   1          j=strlen(buffer);
1445   1          buffer[j]=':';
1446   1          /*fecha de entrada*/
1447   1          Block_read_clock_ascii(buffer+j+1);     //leo la fecha de entrada
1448   1          j=strlen(buffer);
1449   1        
1450   1          buffer[j]= ':';
1451   1          buffer[j+1]=ETX;
1452   1          buffer[j+2]=NULL;
1453   1          Debug_Tibbo=True;
1454   1        return buffer;
1455   1      }
1456          void Armar_Trama_Placa(unsigned char *Buffer_Write_MF)
1457          {
1458   1        unsigned char j;
1459   1        
1460   1          for(j=0; j<8;j++)
1461   1          {
1462   2          *(Buffer_Write_MF +j)=placa[j];
1463   2          }
1464   1            for (j=8; j<16; j++)            
1465   1          {
1466   2            *(Buffer_Write_MF +j)=0x00;
1467   2          }
1468   1      }
1469          unsigned char Load_Secuencia_Expedidor(unsigned char *Secuencia_Expedidor,unsigned const  estadoactivo,uns
             -igned const estadoactual,unsigned const estadofuturo)
1470          {
1471   1        *(Secuencia_Expedidor + EstadoPasado ) = estadoactivo ;
1472   1        *(Secuencia_Expedidor + EstadoActual ) = estadoactual;
1473   1        *(Secuencia_Expedidor + EstadoFuturo ) = estadofuturo;
1474   1        return estadoactual;
1475   1      }
1476          unsigned char Disparo_Lock_Entrada_Vehiculo()
1477          {
1478   1        unsigned char Estado_expedidor;
1479   1        Debug_txt_Tibbo((unsigned char *) "TAKE CARD\r\n");
1480   1        
1481   1        PantallaLCD(RETIRE_TARJETA);
1482   1        
1483   1        if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                   // CANAL LIBRE    no tiene tarjetas 
             -en el mecanismo
1484   1          {
1485   2            Debug_txt_Tibbo((unsigned char *) "TAREA_OPEN_BARRERA\r\n");  
1486   2            lock=ON;
1487   2            send_portERR(BIENVENIDO);
1488   2            PantallaLCD(BIENVENIDO);
1489   2            Estado_expedidor=SEQ_PTO_PARALELO;
1490   2            
1491   2            
1492   2          }
1493   1        else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                      //  se detecta la tarjeta en la b
             -oca TARJETA EN BEZZEL
1494   1        {
1495   2          if(Valida_Sensor1_Auto()!= False)
1496   2          {
1497   3            Estado_expedidor=SEQ_DETAIL_CARD;
1498   3          }
1499   2          else
1500   2          {
1501   3            Estado_expedidor=SEQ_CAPTURE_CARD;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 26  

1502   3          }
1503   2        
1504   2        }
1505   1        return Estado_expedidor;
1506   1      }
1507          unsigned char Send_Pto_Paralelo(unsigned char *Atributos_Expedidor)
1508          {
1509   1        unsigned char *Trama_Expedidor ;
1510   1        if(MenSual == True)
1511   1        {
1512   2        Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor);
1513   2        }
1514   1        else 
1515   1        {
1516   2          Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor();
1517   2          Incremente_Ticket();
1518   2        }
1519   1        send_port(Trama_Expedidor,strlen(Trama_Expedidor)); 
1520   1        Debug_txt_Tibbo((unsigned char *) "Trama_pto_paralelo\r\n");
1521   1        DebugBufferMF(Trama_Expedidor,strlen(Trama_Expedidor),ENVIADOS);
1522   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1523   1        
1524   1        
1525   1        clear_placa();
1526   1        ValTimeOutCom=TIME_WAIT ;
1527   1        Timer_wait=0;
1528   1        return SEQ_ESPERA_VEHICULO_ENTRE;
1529   1      }
1530          
1531          /*------------------------------------------------------------------------------
1532          ------------------------------------------------------------------------------*/
1533          unsigned char Entrega_Card_Captura()
1534          {
1535   1        unsigned char Estado_expedidor;
1536   1        
1537   1          
1538   1        Debug_txt_Tibbo((unsigned char *) "ESPERA VEHICULO ENTRE\r\n"); 
1539   1        sel_Sensor2();                                //garantiso q la barrera se encuentre en posicion baja  
1540   1        if ((DataIn==0))        
1541   1        {  
1542   2          if (ValidaSensor()==0)
1543   2          {
1544   3            lock=OFF;
1545   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo Entrando");
1546   3            Estado_expedidor=SEQ_INICIO;
1547   3          }
1548   2          
1549   2        }
1550   1        else
1551   1        {
1552   2            if(Valida_Sensor1_Auto()!= False)
1553   2            {
1554   3            /*presencia vehicular*/
1555   3              Estado_expedidor=SEQ_ESPERA_VEHICULO_ENTRE;//SEQ_INICIO;//
1556   3              
1557   3              if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1558   3              {
1559   4                  if (Timer_wait >= 5)
1560   4               {
1561   5                 lock=OFF;
1562   5                 Estado_expedidor=SEQ_INICIO;;
1563   5               }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 27  

1564   4              else if (Timer_wait <= 4)
1565   4               {
1566   5                ValTimeOutCom=TIME_WAIT ;
1567   5               }
1568   4             }
1569   3              
1570   3            }
1571   2            else
1572   2            {
1573   3            lock=OFF;
1574   3            Estado_expedidor=SEQ_INICIO;
1575   3            }
1576   2        } 
1577   1       
1578   1        return Estado_expedidor;
1579   1      }
1580          unsigned char Wait_Placa(unsigned char *secuencia_expedidor, unsigned char estadoactivo)
1581          {
1582   1        unsigned char Estado_expedidor;
1583   1        
1584   1        
1585   1      while ((ValTimeOutCom != 1) && (ValTimeOutCom <= TIME_WAIT) && (placa_ready == False))
1586   1        {
1587   2          if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
1588   2              {
1589   3                
1590   3                Rx_Monitor();
1591   3              }
1592   2        }
1593   1        
1594   1          if(placa_ready!=False)
1595   1            {
1596   2              Clave_Seguridad_S2();
1597   2              Estado_expedidor=Load_Secuencia_Expedidor(secuencia_expedidor,estadoactivo,SEQ_CMD_ACEPTADO,SEQ_RESPUE
             -STA_TRANSPORTE);    
1598   2              *(secuencia_expedidor +TareadelCmd ) = TAREA_WRITE_PLACA_CARD;
1599   2            }
1600   1            else
1601   1            {
1602   2                Estado_expedidor=SEQ_WAIT_PLACA;
1603   2             if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1604   2             {  
1605   3              if (Timer_wait >= 5)
1606   3               {
1607   4                 Estado_expedidor=SEQ_FRONT_CARD;
1608   4               }
1609   3              else if (Timer_wait <= 4)
1610   3               {
1611   4                ValTimeOutCom=TIME_WAIT ;
1612   4               }
1613   3             }
1614   2            }
1615   1        return Estado_expedidor;
1616   1      }
1617          unsigned char Valida_Vehiculo_Card_Mensual(unsigned char *Atributos_Expedidor)
1618          {
1619   1        unsigned char Estado_expedidor;
1620   1        
1621   1          Debug_txt_Tibbo((unsigned char *) "VEHICULO MENSUAL TARJETA: ");
1622   1          if(*(Atributos_Expedidor + Type_Vehiculo  ) == False)
1623   1           {
1624   2            Debug_txt_Tibbo((unsigned char *) "(0) CARRO");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 28  

1625   2           }
1626   1          else
1627   1           {
1628   2            Debug_txt_Tibbo((unsigned char *) "(1) MOTO");
1629   2           }
1630   1                            
1631   1          Debug_txt_Tibbo((unsigned char *) "\r\n");
1632   1        if ((rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL)) != True) 
1633   1        {
1634   2          if  (*(Atributos_Expedidor + Type_Vehiculo  ) == Tipo_Vehiculo )          
1635   2          {
1636   3           Debug_txt_Tibbo((unsigned char *) "COINCIDE CARD CON LOOK\r\n ");
1637   3            Estado_expedidor = True ;
1638   3          }
1639   2          
1640   2          else
1641   2          {
1642   3            send_portERR(PRMR_ERROR_TIPO_VEHICULO); 
1643   3            Debug_txt_Tibbo((unsigned char *) "TIPO DE VEHICULO NO CORRESPONDE\r\n ");
1644   3            Estado_expedidor = False; 
1645   3          }
1646   2        } 
1647   1        else 
1648   1        {
1649   2            Debug_txt_Tibbo((unsigned char *) "NO INTERESA COINCIDENCIA CARD CON LOOK\r\n ");
1650   2            Estado_expedidor = True ;
1651   2        }
1652   1          return Estado_expedidor;
1653   1      }
1654          unsigned char Tarjeta_Mensual(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1655          {
1656   1        unsigned char Estado_expedidor;
1657   1      //  unsigned char fecha_asii[7];
1658   1        
1659   1        /*cheque la fecha de expiracion del mensual*/
1660   1        if (Horarios(Atributos_Expedidor) == True)
1661   1        {
1662   2         if ( check_fechaOut(Atributos_Expedidor+Expira_ano) == True )
1663   2            {
1664   3              /*valida el vehiculo en el loop y en la card*/
1665   3              if( Valida_Vehiculo_Card_Mensual(Atributos_Expedidor) == False)
1666   3              {
1667   4              Estado_expedidor = Captura_Expulsa();   
1668   4              }
1669   3              else
1670   3              {
1671   4                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1672   4                *(Atributos_Expedidor + Sector) = Sector_1;
1673   4                *(Atributos_Expedidor + Bloque) = Bloque_2;
1674   4                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1675   4                Estado_expedidor=SEQ_WRITE_SECTOR_BLOQUE;
1676   4              }
1677   3            }
1678   2            else 
1679   2            {
1680   3              send_portERR(PRMR_TARJETA_VENCIDA); 
1681   3              //hex_ascii((Atributos_Expedidor + Expira_ano),fecha_asii);
1682   3            
1683   3              PantallaLCD(TARJETA_VENCIDA);
1684   3              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
1685   3              Estado_expedidor = SEQ_EXPULSAR_CARD;
1686   3            }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 29  

1687   2        }
1688   1        else
1689   1        {
1690   2          
1691   2          Estado_expedidor = SEQ_EXPULSAR_CARD;
1692   2        }
1693   1        return Estado_expedidor;
1694   1      }
1695          unsigned char Tarjeta_Rotacion(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1696          {
1697   1              *(Atributos_Expedidor + Sector) = Sector_1;
1698   1                *(Atributos_Expedidor + Bloque) = Bloque_2;
1699   1                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1700   1                return  SEQ_WRITE_SECTOR_BLOQUE;
1701   1        
1702   1        
1703   1      }
1704          unsigned char Valida_Tipo_Tarjeta(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1705          {
1706   1        unsigned char Estado_expedidor;
1707   1        if(*(Atributos_Expedidor + Tipo_Tarjeta) ==  MENSUALIDAD)
1708   1        {
1709   2          Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
1710   2          if(MenSual ==  True)
1711   2          {
1712   3          //Estado_expedidor=SEQ_CAPTURE_CARD;                                        
1713   3      
1714   3          /*APB Habilitado por software*/
1715   3          
1716   3            if( (rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL) == APB_HABILITADO_SOFT) )
1717   3            {
1718   4              /*APB por Card*/
1719   4           
1720   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO))       
1721   4              {
1722   5                Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1723   5      
1724   5              }
1725   4              else
1726   4              {
1727   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK MENSUAL \r\n");
1728   5                send_portERR(PRMR_SIN_SALIDA);
1729   5                PantallaLCD(REGISTRA_INGRESO);
1730   5                Estado_expedidor = Captura_Expulsa(); 
1731   5              } 
1732   4            }
1733   3          
1734   3          else
1735   3          {
1736   4            Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO MENSUAL \r\n");
1737   4          
1738   4           Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1739   4          }
1740   3        }
1741   2        else
1742   2         {
1743   3          send_portERR(PRMR_NO_CARD_MENSUAL);
1744   3          PantallaLCD(NO_CARD_MENSUAL);     
1745   3          Estado_expedidor = Captura_Expulsa(); 
1746   3         } 
1747   2       }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 30  

1748   1        else if (*(Atributos_Expedidor + Tipo_Tarjeta) ==  ROTACION)
1749   1        {
1750   2          
1751   2            Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n ");
1752   2          if(MenSual != True)
1753   2          {
1754   3            if ( (rd_eeprom(0xa8,EE_HABILITA_APB))!= APB_INHABILITADO_SOFT)
1755   3            {
1756   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO) )
1757   4                                    
1758   4              {
1759   5                Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
1760   5              }
1761   4              else
1762   4              {
1763   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK ROTACION \r\n");
1764   5                send_portERR(PRMR_SIN_SALIDA);
1765   5                PantallaLCD(SIN_SALIDA);
1766   5                Estado_expedidor = Captura_Expulsa();
1767   5              }
1768   4            }
1769   3            else
1770   3            {
1771   4              Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO ROTACION \r\n");
1772   4              Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
1773   4            } 
1774   3          }
1775   2          else
1776   2          {
1777   3            send_portERR(PRMR_NO_CARD_MENSUAL);
1778   3            PantallaLCD(NO_CARD_MENSUAL);     
1779   3            Estado_expedidor = Captura_Expulsa();   
1780   3          }
1781   2        }
1782   1        else
1783   1        {
1784   2          Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n ");
1785   2          send_portERR(PRMR_NO_ROTACION);
1786   2          
1787   2          Estado_expedidor = Captura_Expulsa();   
1788   2        }
1789   1        
1790   1        return Estado_expedidor;
1791   1      }
1792          /*
1793          unsigned char Festivos()
1794          {
1795            
1796            unsigned char dia_semana,day, month, year,DiaFestivo=0;
1797          
1798            
1799            dia_semana=bcd_hex(lee_clk(RDIA_SEMANA));
1800            day = bcd_hex(lee_clk(RDIA));
1801            month = bcd_hex(lee_clk(RMES));
1802            year = bcd_hex(lee_clk(RANO));
1803            
1804            if (year==20)
1805            {
1806              if (((month==1)&&(day==1))||((month==1)&&(day==6))||((month==3)&&(day==23))||((month==4)&&(day==9))||((m
             -onth==4)&&(day==10))||((month==5)&&(day==1))||((month==5)&&(day==25))||((month==6)&&(day==3)))  
1807              {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 31  

1808                DiaFestivo = True;
1809                }
1810              else if (((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==17))||((month==10)&&(day==1
             -2))||((month==11)&&(day==2))||((month==11)&&(day==16))||((month==12)&&(day==8))||((month==12)&&(day==25)))
1811              {
1812                DiaFestivo = True;
1813              }
1814          
1815            }
1816            else if (year==21)
1817            {
1818              if (((month==1)&&(day==1))||((month==1)&&(day==11))||((month==3)&&(day==22))||((month==4)&&(day==1))||((
             -month==4)&&(day==2))||((month==5)&&(day==1))||((month==5)&&(day==17))||((month==6)&&(day==7))||((month==6)&&(day==14))) 
1819              {
1820                DiaFestivo = True;
1821                }
1822              else if (((month==7)&&(day==5))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==16)
             -)||((month==10)&&(day==18))||((month==11)&&(day==1))||((month==11)&&(day==15))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
1823              {
1824                DiaFestivo = True;
1825              }
1826          
1827            }
1828            else if (year==22)
1829            {
1830              if (((month==1)&&(day==1))||((month==1)&&(day==10))||((month==3)&&(day==21))||((month==4)&&(day==14))||(
             -(month==4)&&(day==15))||((month==5)&&(day==1))||((month==5)&&(day==30))||((month==6)&&(day==20))||((month==6)&&(day==27)
             -))  
1831              {
1832                DiaFestivo = True;
1833                }
1834              else if (((month==7)&&(day==4))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==15)
             -)||((month==10)&&(day==17))||((month==11)&&(day==7))||((month==11)&&(day==14))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
1835              {
1836                DiaFestivo = True;
1837              }
1838          
1839            
1840            
1841            }
1842            if ((dia_semana == Sabado)||(dia_semana == Domingo)||(DiaFestivo == True))
1843            {
1844              DiaFestivo = True;
1845            }
1846            else
1847            {
1848              DiaFestivo = False;
1849            }
1850            return DiaFestivo;
1851          }
1852          */
1853          /*
1854          unsigned char Dia_Pico_Placa(unsigned char * Atributos_Expedidor)
1855          {
1856            unsigned char Par_Impar;
1857            unsigned char dato;
1858            
1859            if( Festivos() == False)
1860            {
1861            dato=lee_clk(RDIA);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 32  

1862          
1863              if((dato % 2 == False) && (*(Atributos_Expedidor + Pico_Placa)  == True))
1864              {
1865              
1866              /*es par*/
1867          /*
1868              Par_Impar = True;
1869              
1870              }
1871              else
1872              {
1873              /*es impar */
1874              /*
1875              Par_Impar = False;
1876              }
1877            }
1878            else
1879            {
1880              Par_Impar = True;
1881            }
1882            return Par_Impar;
1883          }
1884          */
1885          unsigned char Horarios(unsigned char * Atributos_Expedidor)
1886          {
1887   1        unsigned char Estado_Horario;
1888   1        
1889   1        unsigned char Addr_horarios [11];
1890   1        unsigned char dia_semana,EE_dia_semana;
1891   1        unsigned int addr;
1892   1        if (*(Atributos_Expedidor + Horario) != False )
1893   1        {
1894   2          /*se Lee la direccion del horario*/
1895   2          strcpy (Addr_horarios,(Addr_Horarios()));
1896   2          
1897   2          addr= Addr_horarios[(*(Atributos_Expedidor + Horario)) -1] ;
1898   2          
1899   2           /*leemos si esta habilitado*/
1900   2          
1901   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
1902   2          {
1903   3            /*miramos si el dia de la semana esta habilitado*/
1904   3            dia_semana = lee_clk(RDIA_SEMANA);
1905   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
1906   3            Debug_chr_Tibbo(dia_semana);
1907   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
1908   3            
1909   3          
1910   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
1911   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
1912   3            Debug_chr_Tibbo(EE_dia_semana);
1913   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
1914   3          
1915   3            if ( EE_dia_semana == dia_semana)
1916   3            {
1917   4              /*miramos si esta en el rango del horario*/
1918   4              Estado_Horario = Bloque_Horario(addr);
1919   4            }
1920   3            else
1921   3            {
1922   4      
1923   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 33  

1924   4              Estado_Horario= False;
1925   4            }
1926   3          }
1927   2          else 
1928   2          {
1929   3            
1930   3            Estado_Horario= False;
1931   3            PantallaLCD(HORARIO_NO_PROG);
1932   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
1933   3            
1934   3          }
1935   2          
1936   2        }
1937   1        else
1938   1        {
1939   2          Estado_Horario = True;
1940   2        
1941   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
1942   2        }
1943   1        return Estado_Horario;
1944   1      }
1945          unsigned int Hora_Maxima(unsigned int addr)
1946          {
1947   1        unsigned char Hora_High,  Minuto_High;
1948   1        unsigned char HoraIni , MinutoIni; 
1949   1        unsigned int  Hora_Prog;
1950   1        
1951   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
1952   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
1953   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
1954   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
1955   1         Debug_chr_Tibbo(HoraIni);
1956   1         Debug_chr_Tibbo(MinutoIni);
1957   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
1958   1        
1959   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
1960   1      }
1961          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
1962          {
1963   1        unsigned char Estado_Horario; 
1964   1        
1965   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
1966   1        {
1967   2          
1968   2          /*hasta la hora que puede ingresar el vehiculo */
1969   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
1970   2          Hora_Prog = Hora_Maxima(addr+4);
1971   2      
1972   2        
1973   2          if( HoraNow <= Hora_Prog)
1974   2          {
1975   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
1976   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
1977   3            Estado_Horario = True;
1978   3          }
1979   2          else
1980   2          {
1981   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
1982   3            //PantallaLCD(MENSUAL_FUERA_HORARIO);
1983   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
1984   3            Estado_Horario = False;
1985   3          }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 34  

1986   2          
1987   2        }
1988   1        else
1989   1        {
1990   2              //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
1991   2              //PantallaLCD(MENSUAL_FUERA_HORARIO);
1992   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
1993   2              Estado_Horario = False;
1994   2            
1995   2        }
1996   1        return Estado_Horario;
1997   1      }
1998          
1999          unsigned Bloque_Horario(unsigned int addr)
2000          {
2001   1        unsigned char Estado_Horario; 
2002   1        unsigned int HoraNow, Hora_Prog;
2003   1        
2004   1        /*la hora del momento de entrada del vehiculo*/
2005   1        
2006   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
2007   1        Debug_chr_Tibbo(lee_clk(RHORA));
2008   1        Debug_chr_Tibbo(lee_clk(RMIN));
2009   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
2010   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
2011   1        
2012   1        /* desde la hora en que puede ingresar vehiculo */
2013   1        
2014   1        
2015   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
2016   1        Hora_Prog = Hora_Maxima(addr);
2017   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
2018   1        if(Estado_Horario == False )
2019   1        {
2020   2          
2021   2            
2022   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
2023   2            {
2024   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
2025   3              Hora_Prog = Hora_Maxima(addr+10);
2026   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
2027   3            }
2028   2            else
2029   2            {
2030   3              send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2031   3              PantallaLCD(MENSUAL_FUERA_HORARIO);
2032   3              Estado_Horario = False;
2033   3            }
2034   2        }
2035   1      
2036   1      return Estado_Horario;
2037   1      }
2038          /*------------------------------------------------------------------------------
2039          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
2040          
2041          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
2042          ------------------------------------------------------------------------------*/
2043          
2044          
2045          unsigned char  Secuencia_inicio_expedidor(void)
2046          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 35  

2047   1        char temp;
2048   1        switch (Estado)
2049   1        {
2050   2          case INICIA_LINTECH:
2051   2      
2052   2                
2053   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
2054   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
2055   2              
2056   2            
2057   2            return (Estado);
2058   2          break;
2059   2      
2060   2      
2061   2      /*------------------------------------------------------------------------------
2062   2      Envia la primera trama de inicializacion del transporte sin movimiento
2063   2            (0) LA RESPUESTA ES OK
2064   2            (1) NO RESPONDE EL PTO SERIE
2065   2            (2) NO RECIBIDO LA TRAMA 
2066   2            (3) ERROR DE TRAMA CMD (N)
2067   2      ------------------------------------------------------------------------------*/
2068   2            
2069   2          case SEQ_CAPTURE_DATOS_INI:
2070   2      
2071   2            if((temp=Trama_Validacion_P_N())!=0)
2072   2          {
2073   3            if(temp==2)
2074   3            {
2075   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
2076   4            } 
2077   3            else if (temp==3)
2078   3            {
2079   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
2080   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2081   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2082   4            }
2083   3            else
2084   3            {
2085   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2086   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
2087   4            }
2088   3          }
2089   2          else
2090   2          {
2091   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
2092   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2093   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
2094   3          }     
2095   2          return (Estado);
2096   2          break;
2097   2            
2098   2      /*------------------------------------------------------------------------------
2099   2      Envia el cmd de grabar claves a la eeprom del transporte 
2100   2      ------------------------------------------------------------------------------*/
2101   2            
2102   2            case GRABA_EEPROM:
2103   2              
2104   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
2105   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
2106   2            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 36  

2107   2            
2108   2      
2109   2            return (Estado);
2110   2              break;
2111   2        
2112   2      /*------------------------------------------------------------------------------
2113   2      se analiza la respuesta 
2114   2            (0) LA RESPUESTA ES OK
2115   2            (1) NO RESPONDE EL PTO SERIE
2116   2            (2) NO RECIBIDO LA TRAMA 
2117   2            (3) ERROR DE TRAMA CMD (N)
2118   2      ------------------------------------------------------------------------------*/
2119   2            
2120   2          case SEQ_CAPTURA_OK_EEPROM:
2121   2          
2122   2          if((temp=Trama_Validacion_P_N())!=0)
2123   2          {
2124   3            if(temp==2)
2125   3            {
2126   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
2127   4            }
2128   3            else if (temp==3)
2129   3            {
2130   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
2131   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2132   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2133   4            }     
2134   3            else
2135   3            {
2136   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2137   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
2138   4            }       
2139   3          }
2140   2          else
2141   2          {
2142   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
2143   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2144   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
2145   3          }     
2146   2      
2147   2          return (Estado);
2148   2          break;
2149   2      
2150   2      /*------------------------------------------------------------------------------
2151   2      Fin de la secuencia de comandos con exito 
2152   2      ------------------------------------------------------------------------------*/    
2153   2            
2154   2              case FIN_OK:
2155   2      
2156   2              return (Estado);
2157   2          break;
2158   2            
2159   2                
2160   2              default:
2161   2              return Estado=INICIA_LINTECH; 
2162   2              break;
2163   2        }
2164   1      }
2165          
2166          /*------------------------------------------------------------------------------
2167          Prosedimiento  q hace paso a paso la secuencia de la MF
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 37  

2168          atributos
2169          ValTimeOutCom = tiempo que  espera para recibir datos pto serie
2170          Tarjeta_on = detecto vehiculo en loop y tiene tarjeta en boca
2171          g_cEstadoComSeqMF = nos dice en el estado que nos encontramos dentro del seguimiento
2172          ------------------------------------------------------------------------------*/
2173          
2174          unsigned char SecuenciaExpedidorMF(unsigned char EstadoActivo)
2175          {
2176   1        static unsigned char Buffer_Write_MF[17];
2177   1        static unsigned char Atributos_Expedidor[15];
2178   1        static unsigned char Secuencia_Expedidor[4];
2179   1        
2180   1        switch (EstadoActivo)
2181   1        {
2182   2      //***********************************************************************************************
2183   2          
2184   2          case SEQ_INICIO:
2185   2      
2186   2            if ((ValTimeOutCom==True)|| (ValTimeOutCom > TIME_CARD))
2187   2            {
2188   3              lock=OFF;                                                                                   /*rele de disparo a la barrera*/
2189   3              Rele_Atasco=OFF;                                                                           /*activo el rele de reset del verificador logica
             - negativa*/    
2190   3              Check_Status(SENSOR_NORMAL);                                                              /* se pregunta al transporte en q estado es
             -tan las TI*/
2191   3              EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_
             -TRANSPORTE);
2192   3              Secuencia_Expedidor [ TareadelCmd  ] = TAREA_PRESENCIA_VEHICULAR;
2193   3            
2194   3            }
2195   2       
2196   2          break;
2197   2          
2198   2          case  SEQ_CMD_ACEPTADO:
2199   2          /*cmd comun para todos*/
2200   2            EstadoActivo=rta_cmd_transporte(Secuencia_Expedidor);
2201   2            
2202   2          break;
2203   2      
2204   2      /*------------------------------------------------------------------------------
2205   2          Tareas especificas de cada paso
2206   2      ------------------------------------------------------------------------------*/      
2207   2          
2208   2            
2209   2          case SEQ_RESPUESTA_TRANSPORTE:
2210   2              ValTimeOutCom=TIME_WAIT;
2211   2            if (Secuencia_Expedidor [TareadelCmd]==TAREA_PRESENCIA_VEHICULAR)
2212   2            {
2213   3            EstadoActivo=Responde_Estado_Sensores_Transporte(); 
2214   3            
2215   3            }
2216   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_TIPO_TARJETA)
2217   2                {
2218   3                  
2219   3                  EstadoActivo=Responde_Tipo_Tarjeta();
2220   3                }
2221   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_LECTURA_TARJETA_SECTOR_BLOQUE)
2222   2                {
2223   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2224   3                  {
2225   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque1 (Atributos_Expedidor);
2226   4                  }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 38  

2227   3                  else
2228   3                  {
2229   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque2(Atributos_Expedidor);
2230   4                  }
2231   3                }
2232   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_WRITE_TARJETA_SECTOR_BLOQUE)
2233   2                { 
2234   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_2))
2235   3                  { 
2236   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor,Buffer_Write_MF);
2237   4                  }
2238   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_2)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2239   3                  {
2240   4                    EstadoActivo=Responde_Write_Tarjeta_Sector2_Bloque0(Buffer_Write_MF);
2241   4                  }
2242   3                  else
2243   3                  {
2244   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque0 (Buffer_Write_MF);
2245   4                  }
2246   3                }
2247   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_OPEN_BARRERA)
2248   2                {   
2249   3                  EstadoActivo = Disparo_Lock_Entrada_Vehiculo();
2250   3                }
2251   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_WRITE_PLACA_CARD)
2252   2                {   
2253   3                  EstadoActivo = Respuesta_Segunda_clave(Atributos_Expedidor,Buffer_Write_MF);
2254   3                }
2255   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_TIPO_MENSUAL) 
2256   2                {
2257   3                  EstadoActivo = Analiza_Presencia_Mensual();
2258   3                }
2259   2                
2260   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_UID ) 
2261   2                {
2262   3                  EstadoActivo = Analiza_Uid_Card(Atributos_Expedidor);
2263   3                }   
2264   2            else
2265   2                {
2266   3                  Debug_txt_Tibbo((unsigned char *) "TAREA_3\r\n");
2267   3                }
2268   2            break;
2269   2          case SEQ_MOVER_CARD_RF:
2270   2            Mov_Card(MovPos_RF);
2271   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_TIPO_CARD);
2272   2            break;
2273   2          case SEQ_CARD_INSERCION_ON:
2274   2            Card_Insercion(Habilita); 
2275   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2276   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_MENSUAL;
2277   2          break;
2278   2          case SEQ_TIPO_CARD:
2279   2            Aut_Card_check_Status();
2280   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2281   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_TARJETA;
2282   2          break;
2283   2          case SEQ_LOAD_PASSWORD:
2284   2            LoadVerify_EEprom();
2285   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECTOR
             -_BLOQUE);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 39  

2286   2            Atributos_Expedidor [ Sector ]    = Sector_1;
2287   2            Atributos_Expedidor [ Bloque ]    = Bloque_1;
2288   2            break;
2289   2          case SEQ_READ_SECTOR_BLOQUE:
2290   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
2291   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2292   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
2293   2          break;
2294   2          case SEQ_WRITE_SECTOR_BLOQUE:
2295   2            WR_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ],Buffer_Write_MF);
2296   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2297   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_WRITE_TARJETA_SECTOR_BLOQUE;
2298   2          break;
2299   2          case SEQ_CAPTURE_CARD:
2300   2            Mov_Card(MovPos_Capture);
2301   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);     
             -//SEQ_INICIOSEQ_MOVER_CARD_RF
2302   2            break;
2303   2          case SEQ_CARD_INSERCION_OFF:
2304   2            Card_Insercion(Inhabilita);
2305   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_EXPULSAR_CA
             -RD);
2306   2          break;
2307   2          case SEQ_EXPULSAR_CARD:
2308   2            Mov_Card(MovPos_EjectFront);
2309   2            MenSual = False;
2310   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);    
2311   2            
2312   2          break;
2313   2          case SEQ_FRONT_CARD:
2314   2            Mov_Card(MovPos_Front);
2315   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_DETAIL_CAR
             -D);    
2316   2            
2317   2          break;
2318   2          case SEQ_DETAIL_CARD:
2319   2            Check_Status(SENSOR_DETAIL);
2320   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);    
2321   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_OPEN_BARRERA;
2322   2            break;
2323   2          case SEQ_LOAD_EEPROM:
2324   2            Dwload_EEprom();
2325   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECT
             -OR_BLOQUE);  
2326   2          break;
2327   2          case SEQ_ESPERA_VEHICULO_ENTRE:
2328   2            MenSual = False;
2329   2            EstadoActivo = Entrega_Card_Captura();
2330   2            break;
2331   2          case SEQ_PTO_PARALELO:
2332   2            EstadoActivo = Send_Pto_Paralelo(Atributos_Expedidor);
2333   2            
2334   2            break;
2335   2          case SEQ_WAIT_PLACA:
2336   2            EstadoActivo = Wait_Placa(Secuencia_Expedidor,EstadoActivo);
2337   2          break;
2338   2          case SEQ_UID: 
2339   2            Unique_Identifier_UID();
2340   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/21/2020 12:52:07 PAGE 40  

             -_TRANSPORTE);    
2341   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_UID ;
2342   2          break;
2343   2          case SEQ_LPR:
2344   2            EstadoActivo = Pregunta_Lpr(Atributos_Expedidor);
2345   2            break;
2346   2          case SEQ_TIPO_TARJETAS:
2347   2            EstadoActivo = Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);;
2348   2            break;
2349   2          case SEQ_CAPTURE_CARD_LOOP:
2350   2            Mov_Card(MovPos_Capture);
2351   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);  
             -   //SEQ_INICIOSEQ_MOVER_CARD_RF
2352   2            EstadoActivo = Analiza_Presencia_rotacion();
2353   2            break;
2354   2          case SEQ_POWER_OFF:
2355   2            Power_off();
2356   2              EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_UID);
2357   2            break;
2358   2          case SEQ_POWER_ON:
2359   2            Power_off();
2360   2              EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_LOAD_PAS
             -SWORD);
2361   2            break;
2362   2          default:
2363   2          EstadoActivo = SEQ_INICIO;  
2364   2          break;  
2365   2            
2366   2        } 
2367   1        return EstadoActivo;
2368   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7250    ----
   CONSTANT SIZE    =   1780    ----
   XDATA SIZE       =    121     201
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
