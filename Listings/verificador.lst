C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          
  12          
  13          extern void send_portERR(unsigned char cod_err);
  14          
  15          
  16          
  17          
  18          extern void PantallaLCD(unsigned char cod_msg);
  19          extern void PantallaLCD_LINEA_2(unsigned char cod_msg, unsigned char *buffer);
  20          
  21          //extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          
  23          
  24          /*funciones prototipo de clock*/
  25          
  26          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  27          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  28          void Block_read_clock_ascii(unsigned char *datos_clock);
  29          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  30          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l);
  31          extern char check_fechaOut(char *buffer);
  32          extern unsigned char lee_clk (unsigned char dir_clk);
  33          extern unsigned char bcd_hex (unsigned char l_data);
  34          extern void hex_ascii(unsigned char * datos,unsigned char * fecha_asii);
  35          extern void  hora_entrada_vehiculo(unsigned char *Atributos_Expedidor);
  36          
  37          extern void Cmd_Lpr_Int();
  38          extern void Delay_10ms(unsigned int cnt);
  39          
  40          /*funciones prototipo string */
  41          
  42          extern char  *strcat  (char *s1, const char *s2);
  43          extern char  *strcpy  (char *s1, const char *s2);
  44          extern unsigned int strlen  (const char *);
  45          extern char   strcmp  (const char *s1, const char *s2);
  46          
  47          /*funciones prototipo de EEprom*/
  48          
  49          extern unsigned char *Lee_No_Ticket();
  50          void Incremente_Ticket();
  51          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  52          
  53          /*funciones prototipo del transporte MODULO io_sensores*/
  54          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 2   

  55          extern unsigned char  ValidaSensoresPaso(void);
  56          unsigned char Valida_Sensor1_Auto();
  57          extern unsigned char Dir_board();
  58          extern void sel_Pulsa(void);
  59          void sel_Sensor2(void);
  60          char ValidaSensor(void);
  61          unsigned char Dir_Board_Monitor();
  62          extern void Botton ();
  63          
  64          /*funciones prototipo del transporte MODULO TIBBO*/
  65          
  66          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  67          extern void Debug_txt_Tibbo(unsigned char * str);
  68          extern void Debug_chr_Tibbo(unsigned char Dat);
  69          extern void Debug_HexDec(unsigned char xfc);
  70          
  71          /*funciones prototipo del transporte MODULO LINTECH*/
  72          
  73          extern void Aut_Card_check_Status(void);
  74          extern void Check_Status(unsigned char Detalle);
  75          extern void Dwload_EEprom (void);
  76          extern void Mov_Card(unsigned char Posicion);
  77          extern void Card_Insercion(char Tipo);
  78          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  79          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);  
  80          extern void LoadVerify_EEprom(void);
  81          extern void Clave_Seguridad_S2(void);
  82          extern void Unique_Identifier_UID(void);
  83          extern void Power_off(void);
  84          
  85          /*funcion prototipo monitor*/
  86          
  87          extern void clear_placa();
  88          extern void Rx_Monitor();
  89          
  90          /*funcion prototipo pto paralelo*/
  91          
  92          void  send_port(unsigned char *buffer_port, unsigned char length_char);
  93          
  94          /*funcion prototipo programacion*/
  95          extern unsigned char *Addr_Horarios();
  96          
  97          extern int    atoi (const char *s1);
  98          /*io sensores */
  99          
 100          sbit DataIn = P1^1;         //  dato de las entradas    
 101          sbit sel_A = P3^5;          //Pulsador                        *
 102          sbit sel_B = P3^6;          //Entrada Sensor 2                    *
 103          sbit sel_C = P3^7;          //Entrada Sensor 1                    *
 104          
 105          sbit lock = P1^7;           //Relevo  
 106          sbit Atascado_GP0_PIN_3 = P0^3;       //Rele de on/off del verificador o transporte
 107          sbit led_err_imp = P0^2;      //Error   
 108          
 109          /*pines de ip tibbo*/
 110          
 111          sbit rx_ip = P0^0;    
 112          /*variables externas*/
 113          
 114          extern unsigned char g_cEstadoComSoft;
 115          extern unsigned char ValTimeOutCom;
 116          extern unsigned char g_cContByteRx;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 3   

 117          extern unsigned char xdata Buffer_Rta_Lintech[];
 118          
 119          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
 120          extern unsigned char Timer_wait;
 121          extern unsigned int  SIN_COBRO;
 122          extern unsigned char  Tarjeta_on;
 123          extern unsigned char cnt__ask_off;
 124          extern  unsigned char Tipo_Vehiculo;
 125          extern  unsigned char  Debug_Tibbo;                                                   /*variable q define expedicion de tarjetas 1=
             - automatico 0= a boton configurable en eeprom*/
 126          extern idata unsigned char placa[];
 127          
 128          /*externo bit*/
 129          
 130          extern bit aSk;
 131          extern bit buffer_ready;
 132          extern bit placa_ready;
 133          extern bit    PULSADOR_BOTTON;
 134          extern bit pto_paraleo;
 135          
 136          /*----------------------------------------------------------------------------
 137          Definiciones de sequencias de verificador y expedidor
 138          ------------------------------------------------------------------------------*/
 139          
 140          #define SEQ_INICIO                      0X00  
 141          #define SEQ_RESPUESTA_TRANSPORTE        0X01
 142          #define SEQ_CMD_ACEPTADO                0x02
 143          #define SEQ_MOVER_CARD_RF               0x03
 144          #define SEQ_CARD_INSERCION_ON           0x04
 145          #define SEQ_TIPO_CARD                   0X05
 146          #define SEQ_LOAD_PASSWORD               0X06
 147          #define SEQ_READ_SECTOR_BLOQUE          0X07
 148          #define SEQ_WRITE_SECTOR_BLOQUE         0X08
 149          #define SEQ_CAPTURE_CARD                0X09
 150          #define SEQ_CARD_INSERCION_OFF          0x0a
 151          #define SEQ_EXPULSAR_CARD               0x0b
 152          #define SEQ_LOAD_EEPROM                 0x0c
 153          #define SEQ_FRONT_CARD                  0x0d
 154          #define SEQ_ESPERA_VEHICULO_ENTRE       0x0e
 155          #define SEQ_DETAIL_CARD                 0x0f
 156          #define SEQ_PTO_PARALELO                0x10
 157          #define SEQ_WAIT_PLACA                  0x11
 158          #define SEQ_UID                         0X12
 159          #define SEQ_LPR                         0X13  
 160          #define SEQ_TIPO_TARJETAS               0X14
 161          #define SEQ_CAPTURE_CARD_LOOP           0X15
 162          #define SEQ_POWER_OFF                   0X16
 163          #define SEQ_POWER_ON                    0X17
 164          #define SEQ_SECOND_PASSWORD             0X18
 165          #define SEQ_PLACA                       0X19
 166          #define SEQ_DETAIL_CARD_TRAMPA          0X1A
 167          #define SEQ_REELER_CARD_SECTOR1_BLOQUE1 0X1B
 168          
 169          /*----------------------------------------------------------------------------
 170          Definiciones de sequencias de tareas del verificador y expedidor
 171          ------------------------------------------------------------------------------*/
 172          #define TAREA_PRESENCIA_VEHICULAR             0X00  
 173          #define TAREA_TIPO_TARJETA                    0X01
 174          #define TAREA_LECTURA_TARJETA_SECTOR_BLOQUE   0x02
 175          #define TAREA_WRITE_TARJETA_SECTOR_BLOQUE     0X03
 176          #define TAREA_OPEN_BARRERA                    0X04
 177          #define TAREA_WRITE_PLACA_CARD                0x05
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 4   

 178          #define TAREA_TIPO_MENSUAL                    0x06
 179          #define TAREA_UID                             0X07
 180          #define TAREA_PRESENCIA_ROTACION              0X08
 181          /*----------------------------------------------------------------------------
 182           definiciones de lintech en la inicializacion de expedidor o verificador
 183          ------------------------------------------------------------------------------*/
 184          
 185          #define INICIA_LINTECH          0x30
 186          #define SEQ_CAPTURE_DATOS_INI   0x31
 187          #define GRABA_EEPROM            0x32
 188          #define SEQ_CAPTURA_OK_EEPROM   0X33
 189          #define FIN_OK                  0x00
 190          
 191          
 192          #define True                    0x01
 193          #define False                   0x00
 194          /*----------------------------------------------------------------------------
 195           Definicion de datos asociados al buffer de resetcion del dato del trnasporte 
 196          
 197          ------------------------------------------------------------------------------*/
 198          
 199          
 200          #define ON    1
 201          #define OFF   0
 202          /*----------------------------------------------------------------------------
 203           ERRORES pto serie 
 204          
 205          ------------------------------------------------------------------------------*/
 206          #define REENVIA_TRAMA     0
 207          #define ESPERA_MAS_TIEMPO 1
 208          /*----------------------------------------------------------------------------
 209           definiciones de lintech en la inicializacion de expedidor o verificador
 210           funcion usada en lintech que me debuelve la respuesta de comunicacion del expedidor
 211           o verificador Trama_Validacion_P_N()
 212          RSPT_TRP_OK             (0) respuesta_transporte_oksignifica que la trama es valida y continua en el proceso
 213          NO_RSPD_TRP_PTO_COM     (1) no_responde_trasnporte_pto_com se cumple el tiempo de espera
 214          ESPR_RSPT_TRP_TRAMA     (2)Espera_respuesta_transporte_trama
 215          ERROR_TRP_TRAMA         (3) error_transpote_trama
 216          ------------------------------------------------------------------------------*/
 217          #define   RSPT_TRP_OK           0
 218          #define   NO_RSPD_TRP_PTO_COM   1
 219          #define   ESPR_RSPT_TRP_TRAMA   2
 220          #define   ERROR_TRP_TRAMA       3
 221          
 222          
 223          /*----------------------------------------------------------------------------
 224           definiciones de lintech en el comando Check_Status
 225          ------------------------------------------------------------------------------*/
 226          
 227          #define SENSOR_DETAIL       0x31
 228          #define SENSOR_NORMAL       0x30
 229          
 230          /*------------------------------------------------------------------------------
 231           definiciones de lintech en el comando Card_Insercion
 232          ------------------------------------------------------------------------------*/
 233          
 234          #define Habilita        0x30
 235          #define Inhabilita      0x31
 236          
 237          /*------------------------------------------------------------------------------
 238          Definicion de Lintech en el comando Inicializa
 239          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 5   

 240          
 241          #define TO_FRONT        '0'
 242          #define CAPTURE_BOX     '1'
 243          #define SIN_MOVIMIENTO  '3'
 244          
 245          /*------------------------------------------------------------------------------
 246          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 247          MovPos_Front        '0'   -> mueve  tarjeta al frente pero no la suelta
 248          MovPos_IC           '1'   ->mueve la tarjeta en posicion de read/write IC
 249          MovPos_RF           '2'   ->mueve tarjeta a RF card read/write
 250          MovPos_Capture      '3'   ->captura la tarjeta
 251          MovPos_EjectFront   '9'   ->lanza la tarjeta del mecanismo
 252          
 253          ------------------------------------------------------------------------------*/
 254          
 255          #define   MovPos_Front        '0'   
 256          #define   MovPos_IC           '1'
 257          #define   MovPos_RF           '2'
 258          #define   MovPos_Capture      '3'
 259          #define   MovPos_EjectFront   '9'
 260          
 261          /*------------------------------------------------------------------------------
 262          Definicion de la trama Lintech de las respuestas de los cmd
 263          ------------------------------------------------------------------------------*/
 264          
 265          #define Pos_Length          3
 266          #define Pos_TipoResp        4
 267          #define ERROR_COLLECT_CARD  6
 268          #define Pos_St0             7
 269          #define Pos_St1             8
 270          #define Pos_St2             9
 271          #define Pos_IniDatMF        0x0a
 272          #define Card_type_H         0x0a
 273          #define Card_type_L         0x0b
 274          #define Rtype               0x0A
 275          /*------------------------------------------------------------------------------
 276          Definicion del estado de st0,st1,st2 de la trama Lintech 
 277          NO_CARDS_IN_MCNSM -> No tiene tarjetas en el mecanismo      sto=0
 278          CARD_IN_MOUTH     -> hay una tarjeta dentro del bessel      st0=1
 279          CARD_OK_READ_RF   -> Tarjeta en posicion para leer/escribir dentro del mecanismo st0=2
 280          NO_HAVE_CARDS     -> no tiene tarjetas en el deposito st1=0
 281          LOW_NIVEL_CARDS   -> nivel bajo de tarjetas en el deposito  st1=1
 282          FULL_CARD         -> Deposito de tarjetas esta lleno        st1=2
 283          ------------------------------------------------------------------------------*/
 284          
 285          
 286          #define NO_CARDS_IN_MCNSM   '0'
 287          #define CARD_IN_MOUTH       '1'
 288          #define CARD_OK_READ_RF     '2'
 289          #define NO_HAVE_CARDS       '0'
 290          #define LOW_NIVEL_CARDS     '1'
 291          #define FULL_CARD           '2'
 292          /*----------------------------------------------------------------------------
 293          Comprobacion automatica del tipo de tarjeta 
 294          checking RF card type
 295          Card_type_H   Card_type_L  explicacion
 296              0             0           tarjeta desconocida
 297              1             0           MF50
 298              1             1           MF70
 299              1             2           MF_UL
 300              2             0           TYPE_A_CPU
 301          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 6   

 302          #define MF50_HIGH             '1'
 303          #define MF50_LOW              '0'
 304          #define MF70                  '1'
 305          #define OPERATE_FAIL          0X6F
 306          
 307          /*----------------------------------------------------------------------------
 308          definicion de recepcion serial 
 309          ------------------------------------------------------------------------------*/
 310          
 311          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 312          
 313          /*----------------------------------------------------------------------------
 314          tiempo de delay entre funciones
 315          ------------------------------------------------------------------------------*/
 316          
 317          #define   TIME_CARD         100   //50
 318          #define   TIME_WAIT         18
 319          #define   TIME_PULSADOR     5
 320          
 321          /*----------------------------------------------------------------------------
 322          definicion de datos de trama lintech
 323          ------------------------------------------------------------------------------*/
 324          
 325          
 326          #define   STX_LINTECH       0xf2
 327          
 328          /*----------------------------------------------------------------------------
 329          msj de lcd tarjeta y lcd serie
 330          ------------------------------------------------------------------------------*/
 331          /*Los cmd PRMR son enviados por el primario*/
 332          #define PRMR_ERROR_LOOP         0XE0
 333          #define ERROR_LOOP              170
 334          #define PRMR_ERROR_COD_PARK     0XE5
 335          #define ERROR_COD_PARK          171
 336          #define PRMR_TARJETA_INVALIDA   0XE1
 337          #define PULSE_BOTON             172
 338          #define PRMR_TARJETA_SIN_FORMATO  0xDF
 339          #define TARJETA_SIN_FORMATO       173
 340          
 341          #define PRMR_NO_CARD_MENSUAL          0XFC
 342          #define NO_CARD_MENSUAL         176
 343          #define TARJETA_INVALIDA        177
 344          
 345          #define PRMR_NO_ROTACION              0XFD
 346          
 347          #define PRMR_SIN_SALIDA             0XE9
 348          #define SIN_SALIDA              178
 349          #define REGISTRA_INGRESO        179
 350          
 351          #define PRMR_TARJETA_VENCIDA          0XEC
 352          #define TARJETA_VENCIDA         180
 353          #define PRMR_ERROR_TIPO_VEHICULO      0XF8
 354          #define PRMR_MENSUAL_FUERA_HORARIO    0Xb5
 355          #define MENSUAL_FUERA_HORARIO   181
 356          #define ERROR_MF1               0XE2
 357          #define HORARIO_NO_PROG         182
 358          
 359          
 360          
 361          #define BIENVENIDO              0XFE
 362          #define NO_CARD                 0xFA  
 363          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 7   

 364          #define RETIRE_TARJETA          0XA1
 365          
 366          #define LOW_CARD                0x01
 367          
 368          #define AUDIO_ENTRADA     0XA0
 369          #define AUDIO_CAJA        0XA1
 370          #define AUDIO_GRACIAS     0XA2
 371          /*----------------------------------------------------------------------------
 372          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 373          ------------------------------------------------------------------------------*/
 374          
 375          #define   ENVIADOS          0X0
 376          #define   RESPUESTA         0X01
 377          #define   SIN_MSJ           0X02
 378          /*
 379          definicion  de daos del reloj
 380                    */
 381          
 382          #define RDIA            0x87
 383          #define RMES            0x89
 384          #define RANO            0x8D
 385          #define RDIA_SEMANA     0x8B
 386          #define RHORA           0x85
 387          #define RMIN            0x83
 388          #define Sabado          7
 389          #define Domingo         1
 390          /*----------------------------------------------------------------------------
 391          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 392          (0) si el dato es cero esta inactiva
 393          (1) activa o ROTACION
 394          (2) mensualidad
 395          ------------------------------------------------------------------------------*/
 396          enum Tipos_MF_TIPO_TARJETA{
 397            INACTIVA,         
 398            ROTACION,           
 399            MENSUALIDAD,
 400            PREPAGO,
 401            CORTESIA,
 402            LOCATARIO,
 403            TARJETA_PERDIDA = 0X10,
 404            INHABILITADA = 0X11
 405          };
 406          /*----------------------------------------------------------------------------
 407          posicion de  MF  bloque 1 sector 1
 408          (0) tipo de tarjeta 
 409          (01) el id del cliente
 410          (03)codigo del parqueadero  
 411          ------------------------------------------------------------------------------*/
 412          #define   MF_TIPO_TARJETA   0X00
 413          #define   MF_COD_PARK       0x01      //MF_ID_CLIENTE
 414          #define   MF_ID_CLIENTE     0x03      //MF_COD_PARK
 415          
 416          /*----------------------------------------------------------------------------
 417          posicion de  MF bloque 2 sector 1
 418          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 419          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 420          ------------------------------------------------------------------------------*/
 421          
 422          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 423          
 424          
 425          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 8   

             -,
 426                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
 427          #define   MF_LSB            0x06
 428          
 429          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 430          
 431          #define   MF_IN_PAGO        0x09
 432          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 433          
 434          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 435          
 436          #define   MF_MENSUAL_ANO      0X05
 437          #define   MF_MENSUAL_MES      0X06
 438          #define   MF_MENSUAL_DIA      0X07
 439          
 440          #define   MF_UID_0      0X04
 441          #define   MF_UID_1      0X05
 442          #define   MF_UID_2      0X06
 443          #define   MF_UID_3      0X07
 444          
 445          #define   MF_EXPIRA_ANO     0X08
 446          #define   MF_EXPIRA_MES     0X09
 447          #define   MF_EXPIRA_DIA     0X0A
 448          
 449          #define   HABILITA_ADDR     15
 450          #define   Segundo_Tiempo    16
 451          
 452          enum Hora_Minutos_addr{
 453            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 454            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 455          };
 456          
 457          enum Estados_Expedidor{
 458           EstadoActual,
 459           EstadoPasado,
 460           EstadoFuturo,
 461           TareadelCmd  
 462          };
 463          enum expedidor {
 464           Sector,        
 465           Bloque,        
 466           Tipo_Tarjeta,
 467           Apb,
 468           Horario,
 469           Pico_Placa,
 470           Type_Vehiculo,
 471           Uid_0,
 472           Uid_1,
 473           Uid_2,
 474           Uid_3,
 475           Expira_ano,
 476           Expira_mes,
 477           Expira_dia,
 478           DateTime_year,
 479           DateTime_month,
 480           DateTime_day,
 481           DateTime_hour,
 482           DateTime_minutes 
 483           
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 9   

 484          };
 485          /*tipos de APB antipassback*/
 486          enum Tipos_MF_APB{
 487            
 488            APB_INICIADO,       
 489            APB_INT,              
 490            APB_OUT,              
 491            APB_NO              
 492          };
 493          /*tipo de vehiculo*/
 494          /*Sectores y bloques de Mf*/
 495          enum MF_Sector_Bloque{
 496            Sector_0,
 497            Sector_1,
 498            Sector_2,
 499            Bloque_0 = 0,
 500            Bloque_1 = 1,
 501            Bloque_2 = 2
 502          };
 503          /*comandos pto paralelo*/
 504          enum CMD_Trama_Pto_Paralelo{
 505            STX=02,
 506            CMD_PTO_PARALELO_EXPEDIDOR='a',
 507            ETX= 03,
 508            NULL=0,
 509            CMD_MONITOR_EXPEDIDOR='E',
 510            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 511          };
 512          enum EE_AntiPassBack{
 513            APB_INHABILITADO_SOFT,
 514            APB_HABILITADO_SOFT
 515          };  
 516          enum Tipos_Vehiculos{
 517              AUTOMOVIL,          
 518              MOTO,
 519              BICICLETA
 520          };  
 521          
 522          /*DATOS DE CONFIGURACION EEPROM*/
 523          #define EE_ID_CLIENTE           0x0000
 524          #define EE_ID_PARK              0x0002
 525          #define EE_DEBUG                0x0008
 526          #define EE_USE_LPR              0x000A
 527          #define EE_CARD_AUTOMATIC_BOTON 0x000f
 528          #define EE_HABILITA_APB         0x0010
 529          #define EE_PLACA                0X0011
 530          #define EE_VALIDA_TIPO_VEHICULO_MENSUAL 0X0014
 531          #define EE_HABILITA_APB_MENSUAL 0X0015
 532          #define EE_MENSUAL_BOCA_ON_OFF  0X0016
 533          
 534          /*----------------------------------------------------------------------------
 535          Definicion de varaibles globales del objeto
 536          ------------------------------------------------------------------------------*/
 537          
 538          static unsigned char Estado=INICIA_LINTECH;
 539          bit MenSual = False;                      /*bit que informa si esta activo mensual*/
 540          /*------------------------------------------------------------------------------
 541          
 542          ------------------------------------------------------------------------------*/
 543          unsigned char Captura_Expulsa()
 544          {
 545   1        unsigned char Estado_expedidor;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 10  

 546   1        
 547   1        
 548   1        if(MenSual !=  True)
 549   1        {
 550   2          Estado_expedidor=SEQ_CAPTURE_CARD_LOOP; //SEQ_CAPTURE_CARD;                                       
 551   2        }
 552   1        else
 553   1        {
 554   2        
 555   2        Estado_expedidor = SEQ_EXPULSAR_CARD;//SEQ_CARD_INSERCION_OFF;  
 556   2        } 
 557   1      
 558   1      
 559   1      return  Estado_expedidor;
 560   1      }
 561          /*------------------------------------------------------------------------------
 562          funcion que valida la trama del verificador o transporte lintech
 563          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 564          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 565          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 566          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 567          
 568          
 569          ------------------------------------------------------------------------------*/
 570          
 571          char Trama_Validacion_P_N()
 572          {
 573   1        char Trama_Validacion_P_N=ESPR_RSPT_TRP_TRAMA;                                /*espera respuesta del transporte*/
 574   1            
 575   1            if ((ValTimeOutCom==1)||(buffer_ready==1)|| (ValTimeOutCom > TIME_CARD) )
 576   1            {
 577   2              if (buffer_ready==1)
 578   2              {
 579   3                buffer_ready=0;
 580   3                  
 581   3              
 582   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 583   3                {
 584   4                          
 585   4                  Trama_Validacion_P_N=RSPT_TRP_OK;                                       /*trama ok*/
 586   4                    
 587   4                }
 588   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 589   3                {
 590   4                  
 591   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;                                 /*error de trama*/
 592   4                  
 593   4                }
 594   3                else
 595   3                {
 596   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
 597   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;   
 598   4                  
 599   4                }
 600   3              }
 601   2              else
 602   2              {
 603   3                          
 604   3                Trama_Validacion_P_N=NO_RSPD_TRP_PTO_COM;                                 /*pto serie no responde */
 605   3                                                  
 606   3              }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 11  

 607   2      
 608   2            }
 609   1            
 610   1        return Trama_Validacion_P_N;
 611   1      }
 612          /*------------------------------------------------------------------------------
 613          funcion de error de respuesta pto serie
 614          
 615          variable en uart. cnt__ask_off=cuenta los numeros de error pto serie y reset de transporte 
 616          se limpia cuando llega la respuesta del transporte. 
 617          Rele_Atasco = es un I/O del Mc que activa / inhabilita el rele
 618          ON    (1) esta activo 
 619          OFF   (0) inhactivo 
 620          REENVIA_TRAMA   1
 621          ESPERA_MAS_TIEMPO 0
 622          cnt_espera_ask_on= cuenta el tiempo de ASK que esta activo,sin que le llegue
 623                             la trama completa, al  5 tiempos borra el ask y retrasmite el cmd
 624          
 625          error_rx_pto= (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 626                      = (1)= REENVIA_TRAMA reenvia la trama al transporte
 627          
 628          cnt__ask_off= varible global esta definida en pto serie y es un contador , que 
 629          se limpia cada vez que la trama a llegado completa y validada
 630          
 631          aSk= significa que llego al pto serie el 06 = ask donde el transporte dice que a recibido el cmd
 632          esta ejecutando y nos enviara la respuesta,necesita tiempo esta bit esta definino en el modulo uart es glo
             -bal
 633          
 634          ------------------------------------------------------------------------------*/
 635          unsigned char error_rx_pto(void)
 636          {
 637   1      
 638   1      static unsigned cnt_espera_ask_on=0;
 639   1      unsigned char error_rx_pto=ESPERA_MAS_TIEMPO;
 640   1      
 641   1          
 642   1                
 643   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...");
 644   1            Debug_chr_Tibbo (cnt__ask_off); 
 645   1            Debug_chr_Tibbo (cnt_espera_ask_on);
 646   1            Debug_chr_Tibbo (error_rx_pto);
 647   1            Debug_txt_Tibbo((unsigned char *) "\r\n");
 648   1            if (aSk==OFF)
 649   1            
 650   1            { 
 651   2                cnt__ask_off++;                                                                   /*cuento el error*/                                                               
 652   2              if(cnt__ask_off>=10)
 653   2              { 
 654   3                Debug_txt_Tibbo((unsigned char *) "ATASCADO RESET\r\n");                                                                      /*no conte
             -sta debe reset el transporte*/
 655   3                Atascado_GP0_PIN_3 = ON;                                                                    /*off el rele de reset del verificador*/    
 656   3                Delay_10ms(110);
 657   3                cnt__ask_off=0;                                                                   /*limpio ls errores*/
 658   3                cnt_espera_ask_on=0;
 659   3                error_rx_pto=ESPERA_MAS_TIEMPO;                                                   /**/
 660   3                Atascado_GP0_PIN_3 = OFF; 
 661   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 662   3                ValTimeOutCom=TIME_CARD;
 663   3              }
 664   2              else;
 665   2              {
 666   3                error_rx_pto=REENVIA_TRAMA;                                                       /*1 reenvia trama*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 12  

 667   3                ValTimeOutCom=TIME_CARD;
 668   3              }
 669   2            }                                                                                     /*aSk esta activo */
 670   1            else
 671   1            {
 672   2                cnt_espera_ask_on++;                                                              /*cuento n tiempos de ask para recibir el total de
             - la trama*/
 673   2              if(cnt_espera_ask_on>=1)
 674   2              {
 675   3                cnt__ask_off=0;                                                                   /*paso tiempo de espera y no se completo la trama 
 676   3                                                                                                  limpio los reg y reenvio la trama y ask=off*/
 677   3                cnt_espera_ask_on=0;
 678   3                error_rx_pto=REENVIA_TRAMA;
 679   3                aSk=OFF;
 680   3                ValTimeOutCom=TIME_CARD;
 681   3              }
 682   2              else
 683   2              {
 684   3                cnt__ask_off=0;                                                                   /*damos tiempo de espera de la trama del transporte*
             -/
 685   3                error_rx_pto=ESPERA_MAS_TIEMPO;;
 686   3                ValTimeOutCom=TIME_CARD;
 687   3              }
 688   2            }
 689   1              return (error_rx_pto);
 690   1      }
 691          /*------------------------------------------------------------------------------
 692          Funcion de respuesta a los cmd del transporte
 693          Retorna rta_cmd_transporte el estado en que queda
 694          Recibe tres datos unos es el 
 695          Estado_futuro= significa que la respuesta fue ok
 696          Estado_Error= en caso de que aya un error a que estado envia el codigo
 697          Estado_Actua= No ha llegado la respuesta y sigue en el mismo estado
 698          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 699          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 700          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 701          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 702          
 703          (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 704          (1)= REENVIA_TRAMA reenvia la trama al transporte
 705          ------------------------------------------------------------------------------*/
 706          unsigned char   rta_cmd_transporte(unsigned char *secuencia_Expedidor )
 707          {
 708   1        unsigned char temp;
 709   1        unsigned char EstadoComSeqMF;
 710   1        
 711   1        
 712   1            
 713   1      if((temp=Trama_Validacion_P_N())!=RSPT_TRP_OK )
 714   1          {
 715   2            if(temp==ESPR_RSPT_TRP_TRAMA)                                                         /*no he recibido respuesta espero*/
 716   2            {
 717   3            EstadoComSeqMF= *(secuencia_Expedidor + EstadoActual);                              /*SEQ_RTA_CARD_POSno ha respon
             -dido*/
 718   3            } 
 719   2            else if (temp==ERROR_TRP_TRAMA)
 720   2            {
 721   3            Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR\r\n");                             /* trama no valida respuesta inco
             -rrecta falla en la escritura */
 722   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 723   3            if(Buffer_Rta_Lintech[ERROR_COLLECT_CARD]==0x33)
 724   3              {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 13  

 725   4                Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR COLECTOR LLENO\r\n");  
 726   4              }
 727   3      
 728   3            EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado); 
 729   3            //EstadoComSeqMF=SEQ_INICIO ;                                                           /// (3) Trama invalida cmd (N)reenvio cmd*/ 
 730   3            }     
 731   2            else
 732   2            {
 733   3            /*Dispensador No Responde PTO SERIE ...*/
 734   3          
 735   3              if(temp=error_rx_pto()==ESPERA_MAS_TIEMPO)
 736   3              {
 737   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoActual); 
 738   4              }                                                                                     /*SEQ_RTA_CARD_POS;*/
 739   3              else                                                                                  //(temp=error_rx_pto()==REENVIA_TRAMA)
 740   3              {
 741   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                     /*SEQ_INICIO*/
 742   4              }                                                 
 743   3            }       
 744   2          }
 745   1          else
 746   1          {
 747   2            
 748   2            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);
 749   2            EstadoComSeqMF=*(secuencia_Expedidor + EstadoFuturo); 
 750   2          }
 751   1        return EstadoComSeqMF;
 752   1      }
 753          
 754          /*------------------------------------------------------------------------------
 755          ------------------------------------------------------------------------------*/
 756          unsigned char Analiza_Presencia_Mensual()
 757          {
 758   1        unsigned char Estado_expedidor;
 759   1      
 760   1        
 761   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 762   1          {
 763   2            if(rd_eeprom(0xa8,EE_MENSUAL_BOCA_ON_OFF) == True)  
 764   2              {
 765   3                  MenSual = True;
 766   3                  Estado_expedidor = SEQ_TIPO_CARD;                 //SEQ_UID
 767   3              }
 768   2            else
 769   2              {
 770   3                Estado_expedidor = SEQ_DETAIL_CARD_TRAMPA;
 771   3              }
 772   2            
 773   2            
 774   2          }
 775   1        else
 776   1          { 
 777   2            
 778   2              send_portERR(PRMR_ERROR_LOOP);
 779   2              PantallaLCD(ERROR_LOOP);
 780   2              Estado_expedidor = SEQ_DETAIL_CARD_TRAMPA;
 781   2          }
 782   1        return Estado_expedidor;
 783   1      }
 784          /*------------------------------------------------------------------------------*/
 785          // analiza si tiene una tarjeta en la boca o en rf  para debolverla
 786          /*------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 14  

 787          unsigned char Analiza_card_mount_rf()
 788          {
 789   1      unsigned char Estado_expedidor;
 790   1        ValTimeOutCom=TIME_WAIT;
 791   1           if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta en l
             -a boca TARJETA EN BEZZEL
 792   1              {
 793   2                    /*hay una tarjeta en la boca del verificador */
 794   2                    Debug_txt_Tibbo((unsigned char *) "Analiza_card_mount\r\n");                                //se envia msj al debug
             -er q hay tarjeta en la boca
 795   2                                                                                                                //se habilita recepcion de tarjetas por boca
 796   2                    Estado_expedidor = SEQ_CARD_INSERCION_ON;                                                     //se trabaja mensual        
 797   2              }
 798   1              else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
 799   1                  
 800   1              {
 801   2                    Debug_txt_Tibbo((unsigned char *)"Analiza_card_rf\r\n");
 802   2                    Estado_expedidor=SEQ_EXPULSAR_CARD;
 803   2              }
 804   1              
 805   1      
 806   1        return Estado_expedidor;
 807   1      }
 808          /*------------------------------------------------------------------------------*/
 809          
 810          /*------------------------------------------------------------------------------*/
 811          unsigned char Analiza_Presencia_rotacion()
 812          {
 813   1        unsigned char Estado_expedidor;
 814   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 815   1          {
 816   2            
 817   2            Estado_expedidor = SEQ_MOVER_CARD_RF;                 //SEQ_UID
 818   2          }
 819   1        else
 820   1          { 
 821   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 822   2              send_portERR(PRMR_ERROR_LOOP);
 823   2              PantallaLCD(ERROR_LOOP);
 824   2              Estado_expedidor = SEQ_INICIO;  //SEQ_EXPULSAR_CARD;
 825   2                    
 826   2          }
 827   1        return Estado_expedidor;
 828   1      }
 829          /*------------------------------------------------------------------------------
 830          Funcion numero unico de identificacion
 831          ------------------------------------------------------------------------------*/
 832          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor )
 833          {
 834   1        unsigned char Estado_expedidor;
 835   1        unsigned char temp;
 836   1        unsigned char buffer_UID[17];
 837   1          if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
 838   1            {
 839   2              
 840   2                for (temp=0; temp<16; ++temp)
 841   2                {
 842   3                  buffer_UID [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de M
             -F en un arreglo*/
 843   3                 
 844   3                }
 845   2                
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 15  

 846   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
 847   2                DebugBufferMF(buffer_UID,16,RESPUESTA);
 848   2                
 849   2        
 850   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
 851   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_0]));  
 852   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_1]));  
 853   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_2]));  
 854   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_3]));
 855   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
 856   2                
 857   2              *(Atributos_Expedidor + Uid_0) = buffer_UID [MF_UID_0];   
 858   2              *(Atributos_Expedidor + Uid_1) = buffer_UID [MF_UID_1];     
 859   2              *(Atributos_Expedidor + Uid_2) = buffer_UID [MF_UID_2];     
 860   2              *(Atributos_Expedidor + Uid_3) = buffer_UID [MF_UID_3]; 
 861   2              Estado_expedidor=SEQ_LPR;                                         ///SEQ_LOAD_PASSWORD;                                                       //SEQ_T
             -IPO_CARD;
 862   2            }   
 863   1            else
 864   1            {
 865   2              Estado_expedidor=SEQ_POWER_OFF;
 866   2            } 
 867   1            return Estado_expedidor;
 868   1      }
 869          /*------------------------------------------------------------------------------
 870          Se analiza si expulsa la tarjeta por boton o automatica
 871          ------------------------------------------------------------------------------*/
 872          unsigned char Ingreso_Vehiculo(void)
 873            {
 874   1          unsigned char CardAutomatic;  
 875   1          static unsigned char pulseboton=24;
 876   1          
 877   1        
 878   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 879   1          {
 880   2            CardAutomatic=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);  
 881   2            
 882   2            if (CardAutomatic==True)                                                    //se pregunta si expide la tarjeta automatica o por p
             -resionar el boton
 883   2              {
 884   3                Debug_txt_Tibbo((unsigned char *) "Tarjeta: Automatico\r\n");           //expide tarjetas automatico con p
             -resencia
 885   3                                                                                        // muevo la tarjeta hasta el lector de rf
 886   3                Estado=SEQ_MOVER_CARD_RF;                                               // valido el cmd enviado al verificador
 887   3               }
 888   2            else
 889   2              {   
 890   3            /*solo sale el msj pulse el boton una vez cada 24 veces */          
 891   3                  if(pulseboton >= 24)
 892   3                  { PantallaLCD(PULSE_BOTON); 
 893   4                    pulseboton=0;
 894   4                  }
 895   3                  else
 896   3                   {
 897   4                     pulseboton++;
 898   4                  
 899   4                   
 900   4                   }
 901   3                   Botton ();
 902   3                   if(PULSADOR_BOTTON == True)
 903   3                   {
 904   4                     PULSADOR_BOTTON = 0;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 16  

 905   4                     pulseboton=0;                                                                //muevo tarjeta hasta el lector de RF
 906   4                     Estado=SEQ_MOVER_CARD_RF;
 907   4                   }
 908   3                   else
 909   3                   {
 910   4                    Estado=SEQ_INICIO; 
 911   4                     ValTimeOutCom=TIME_PULSADOR;       //ojo
 912   4                   }
 913   3                
 914   3                  
 915   3              } 
 916   2          }
 917   1          else
 918   1              { 
 919   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 920   2                Estado=SEQ_INICIO;  
 921   2              }
 922   1        return Estado;
 923   1      }
 924           
 925          /*------------------------------------------------------------------------------
 926          Se pregunta por el estado del expedidor si hay tarjetas y presencia para expulsar tarjeta
 927          o si hay tarjeta en la boca o rf para entrar en mensuales
 928          ------------------------------------------------------------------------------*/
 929          
 930          unsigned char Responde_Estado_Sensores_Transporte()
 931          {
 932   1        unsigned char Estado_expedidor;
 933   1          
 934   1            Debug_txt_Tibbo((unsigned char *) "TAREA_PRESENCIA_VEHICULAR\r\n");                                 // trama valida Hab
             -ilitado 
 935   1          
 936   1            if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                                 // CANAL LIBRE    no tiene 
             -tarjetas en el mecanismo
 937   1            {
 938   2                
 939   2              if  ((Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS)||(Buffer_Rta_Lintech[Pos_St1]==FULL_CARD  ))  //  se
             - detecta la tarjeta en la boca TARJETA EN BEZZEL
 940   2              {
 941   3                if (Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS  )                                             // nivel de tarjetas
 942   3                  {
 943   4                    Debug_txt_Tibbo((unsigned char *) "Nivel bajo de tarjetas\r\n");                            // nivel bajo de tarj
             -etas 
 944   4                    send_portERR(LOW_CARD);                                                                     //envio msj al primario
 945   4                  //  PantallaLCD(LOW_CARD);                                                                            //envio msj por la raspberry nivel ba
             -jo de tarjetas
 946   4                    Estado_expedidor=Ingreso_Vehiculo();        
 947   4                   }
 948   3                   else
 949   3                      {
 950   4                        /*respuesta ok*/
 951   4                       Estado_expedidor=Ingreso_Vehiculo();
 952   4                      
 953   4                      }
 954   3              } 
 955   2              else 
 956   2                  {
 957   3                    /*dispensador no posee tarjetas*/
 958   3                    Debug_txt_Tibbo((unsigned char *) "Dispensador SIN TARJETAS...\r\n"); 
 959   3                    
 960   3                    send_portERR(NO_CARD);  
 961   3                                                                          // se envia msj al uC principal, visualiza en el lcd que no hay tarjetas
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 17  

 962   3                  //  PantallaLCD(NO_CARD);   
 963   3                    Estado_expedidor=SEQ_INICIO;                                                                //inicio el loop
 964   3                   }
 965   2            }
 966   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
 967   1              {
 968   2                    /*hay una tarjeta en la boca del verificador */
 969   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                                //se envia msj al debug
             -er q hay tarjeta en la boca
 970   2                                                                                                                //se habilita recepcion de tarjetas por boca
 971   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;                                                     //se trabaja mensual        
 972   2              }
 973   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
 974   1                  
 975   1              {
 976   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en RF\r\n");
 977   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;
 978   2              }
 979   1            else
 980   1              {
 981   2                Estado_expedidor=SEQ_INICIO;  
 982   2              }
 983   1        return Estado_expedidor;  
 984   1      }
 985          
 986          /*------------------------------------------------------------------------------
 987          Funcion que nos dice el tipo de tarjeta que tiene en el mecanismo
 988          Comprobacion automatica del tipo de tarjeta 
 989          checking RF card type
 990          Card_type_H   Card_type_L  explicacion
 991              0             0           tarjeta desconocida
 992              1             0           MF50
 993              1             1           MF70
 994              1             2           MF_UL
 995              2             0           TYPE_A_CPU
 996          
 997          #define MF50_HIGH             '1'
 998          #define MF50_LOW              '0'
 999          ------------------------------------------------------------------------------*/
1000          unsigned char Responde_Tipo_Tarjeta()
1001            {
1002   1          unsigned char Estado_expedidor;
1003   1          
1004   1            Debug_txt_Tibbo((unsigned char *) "TAREA_TIPO DE TARJETA\r\n");                         // trama valida Habilitado 
1005   1            
1006   1        if (Buffer_Rta_Lintech[Card_type_H]==MF50_HIGH)                                             /* pregunto si la tarjeta en el tra
             -nsporte es MF 50 */
1007   1          {
1008   2          if ((Buffer_Rta_Lintech[Card_type_L] == MF50_LOW) || (Buffer_Rta_Lintech[Card_type_L] == MF70)) 
1009   2            {
1010   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n");                         /* trama valida son MF50*/
1011   3              if(MenSual ==  True)
1012   3              {
1013   4              Estado_expedidor = SEQ_UID;                                                             //SEQ_LOAD_PASSWORD;                        
1014   4              }
1015   3              else  
1016   3              {
1017   4                Estado_expedidor = SEQ_LPR;   //SEQ_LOAD_PASSWORD;
1018   4              }         
1019   3            }
1020   2            else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 18  

1021   2              {
1022   3                 if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
1023   3                {
1024   4                
1025   4                Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida_1 no es MF50\r\n");           /* trama no valida */
1026   4                      
1027   4                send_portERR(PRMR_TARJETA_INVALIDA);                                                              /*envio msj principal tarjeta inva
             -lidad*/
1028   4                PantallaLCD(TARJETA_INVALIDA);
1029   4                    
1030   4                  Estado_expedidor = Captura_Expulsa(); 
1031   4                
1032   4                } 
1033   3                else  
1034   3                {
1035   4                  MenSual = False;
1036   4                  Estado_expedidor = SEQ_INICIO;    
1037   4                }           
1038   3              }
1039   2          }
1040   1          else 
1041   1            {
1042   2               if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta 
             -en la boca TARJETA EN BEZZEL
1043   2                {
1044   3                  /*patina el transporte */
1045   3                
1046   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");           /* trama no valida */
1047   3                      
1048   3              send_portERR(PRMR_TARJETA_INVALIDA);                                                              //la tarjeta no es valida 
1049   3              PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la raspber
             -ry*/
1050   3                        
1051   3              Estado_expedidor = Captura_Expulsa(); 
1052   3                          
1053   3                  
1054   3                }
1055   2                else  
1056   2                {
1057   3                  MenSual = False;
1058   3                  Estado_expedidor = SEQ_INICIO;    
1059   3                }                     
1060   2            }
1061   1                    
1062   1          return Estado_expedidor;                                                                                                  
1063   1        } 
1064          /*------------------------------------------------------------------------------
1065            Funcion que lee los datos en el Sector 1 Bloque 1
1066            se lee
1067            ID_CLIENTE
1068            COD_PARK
1069            TIPO DE TARJETA
1070            EXPIRA_ANO
1071            EXPIRA_MES
1072            EXPIRA_DIA
1073          ------------------------------------------------------------------------------*/
1074          
1075          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
1076          {
1077   1        unsigned char temp;
1078   1        unsigned char Estado_expedidor;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 19  

1079   1        unsigned char buffer_S1_B1[17];
1080   1        unsigned char ID_CLIENTE;
1081   1        unsigned char COD_PARK;   
1082   1        static unsigned char falla=0;
1083   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE1\r\n");   
1084   1                                        
1085   1                                      
1086   1            
1087   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1088   1            {
1089   2              
1090   2                for (temp=0; temp<16; ++temp)
1091   2                {
1092   3                  buffer_S1_B1 [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de
             - MF en un arreglo*/
1093   3                 
1094   3                }
1095   2                
1096   2                
1097   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b1\r\n");
1098   2                DebugBufferMF(buffer_S1_B1,16,RESPUESTA);
1099   2                ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1100   2                COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
1101   2                /*Compara  MF_ID_CLIENTE y MF_COD_PARK con el codigo del parqueadero ID_CLIENTE  COD_PARK*/
1102   2                
1103   2                if (((buffer_S1_B1 [ MF_ID_CLIENTE])==ID_CLIENTE) && ((buffer_S1_B1 [ MF_COD_PARK] ) == COD_PARK)||((
             -ID_CLIENTE==0)&&(COD_PARK==0)))   
1104   2                {
1105   3                    
1106   3                  Debug_txt_Tibbo((unsigned char *) "CARD ID_CLIENTE: ");               
1107   3                  Debug_HexDec((buffer_S1_B1 [ MF_ID_CLIENTE]));
1108   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1109   3                  
1110   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");                
1111   3                  Debug_HexDec(ID_CLIENTE);
1112   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1113   3                  
1114   3                  Debug_txt_Tibbo((unsigned char *) "CARD COD_PARK:");                    
1115   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1116   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1117   3                  
1118   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");                   
1119   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1120   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1121   3      
1122   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
1123   3                  Debug_chr_Tibbo(buffer_S1_B1 [MF_TIPO_TARJETA]);
1124   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1125   3                  
1126   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S1_B1 [MF_TIPO_TARJETA];
1127   3                  /*fecha de vencimiento de mensual o prepago*/
1128   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S1_B1 [MF_EXPIRA_ANO];
1129   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S1_B1 [MF_EXPIRA_MES];
1130   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S1_B1 [MF_EXPIRA_DIA];
1131   3                  
1132   3                  *(Atributos_Expedidor + Sector) = Sector_1;
1133   3                  *(Atributos_Expedidor + Bloque) = Bloque_2;
1134   3                  falla=0;
1135   3                  Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1136   3              
1137   3                }
1138   2                else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 20  

1139   2                {
1140   3                  falla=0;
1141   3                  Debug_txt_Tibbo((unsigned char *) "ERROR COD PARK\r\n");
1142   3                  send_portERR(PRMR_ERROR_COD_PARK);
1143   3                  PantallaLCD(ERROR_COD_PARK);                                                        //envio el msj por la pantalla lcd o la rasp
             -berry
1144   3                  Estado_expedidor = Captura_Expulsa();                                                 //   codigo de parqueo erro expulso la 
             -tarjeta     
1145   3                }
1146   2            }
1147   1            else
1148   1            {
1149   2                
1150   2              if ((Buffer_Rta_Lintech[Rtype]) == OPERATE_FAIL)
1151   2              {
1152   3                falla++;
1153   3              }
1154   2               if (falla <= 2)
1155   2                
1156   2              {
1157   3                Debug_txt_Tibbo((unsigned char *) "ERROR OPERATE FAIL\r\n");
1158   3                Estado_expedidor = SEQ_POWER_ON;
1159   3                                    
1160   3              }
1161   2              else
1162   2              {
1163   3                falla=0;
1164   3                Debug_txt_Tibbo((unsigned char *) "TARJETA SIN FORMATO\r\n");
1165   3                send_portERR(PRMR_TARJETA_SIN_FORMATO);
1166   3                PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la 
             -raspberry*/
1167   3               Estado_expedidor =Captura_Expulsa();   
1168   3              }
1169   2            }
1170   1            
1171   1        return Estado_expedidor;
1172   1      } 
1173          /*------------------------------------------------------------------------------
1174          
1175          ------------------------------------------------------------------------------*/
1176          
1177          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
1178          {
1179   1        unsigned char temp;
1180   1        unsigned char Estado_expedidor;
1181   1        unsigned char buffer_S1_B2[17]; 
1182   1      
1183   1            
1184   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");   
1185   1            
1186   1                              
1187   1            
1188   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1189   1            {
1190   2              
1191   2                for (temp=0; temp<16; ++temp)
1192   2                {
1193   3                  buffer_S1_B2 [temp] =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion d
             -e MF en un arreglo*/
1194   3                }
1195   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b2\r\n");
1196   2                DebugBufferMF(buffer_S1_B2,16,RESPUESTA);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 21  

1197   2                
1198   2                      
1199   2                
1200   2                Debug_txt_Tibbo((unsigned char *) "HORARIO:");
1201   2                Debug_chr_Tibbo((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1202   2                *(Atributos_Expedidor + Horario)= ((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1203   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1204   2                
1205   2                Debug_txt_Tibbo((unsigned char *) "PICO Y PLACA:");
1206   2                
1207   2                *(Atributos_Expedidor + Pico_Placa)= ((buffer_S1_B2 [MF_IN_PAGO] & 0XF0) >> 4);
1208   2                Debug_chr_Tibbo(*(Atributos_Expedidor + Pico_Placa));
1209   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1210   2                
1211   2            
1212   2                Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK:");
1213   2                Debug_chr_Tibbo(buffer_S1_B2 [MF_APB] );
1214   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1215   2              
1216   2                /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
1217   2                
1218   2                *(Atributos_Expedidor + Apb)=   buffer_S1_B2 [MF_APB] ;
1219   2                
1220   2                
1221   2                  *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S1_B2 [MF_TIPO_VEHICULO]& 0x0f;
1222   2                  Estado_expedidor =SEQ_TIPO_TARJETAS;    // Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);
1223   2            
1224   2        
1225   2            }
1226   1            else
1227   1            {
1228   2              Estado_expedidor = Captura_Expulsa(); //momentario
1229   2            }
1230   1          return Estado_expedidor;  
1231   1      }
1232          
1233          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque0 (unsigned char *Nombre_Mensual)
1234          {
1235   1        unsigned char temp;
1236   1        unsigned char Estado_expedidor;
1237   1          
1238   1      
1239   1            
1240   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE0\r\n");   
1241   1            
1242   1                              
1243   1            
1244   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1245   1            {
1246   2              
1247   2                for (temp=0; temp<16; ++temp)
1248   2                {
1249   3                  *(Nombre_Mensual + temp ) =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informa
             -cion de MF en un arreglo*/
1250   3                }
1251   2                *(Nombre_Mensual + temp )=NULL;
1252   2                Debug_txt_Tibbo((unsigned char *) "Nombre Mensual:");
1253   2                Debug_txt_Tibbo(Nombre_Mensual );
1254   2                Debug_txt_Tibbo((unsigned char *) "\r\n");      
1255   2                Estado_expedidor = SEQ_PLACA;   //SEQ_TIPO_TARJETAS;                                                // Valida_Tipo_Tarjeta(Atr
             -ibutos_Expedidor,Buffer_Write_MF);
1256   2            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 22  

1257   2        
1258   2            }
1259   1            else
1260   1            {
1261   2              Estado_expedidor = Captura_Expulsa(); //momentario
1262   2            }
1263   1          return Estado_expedidor;  
1264   1      }
1265          unsigned char Responde_ReeLectura_Tarjeta_Sector1_Bloque2 (unsigned char *lectura_anterior, unsigned char 
             -*Atributos_Expedidor)
1266          {
1267   1        unsigned char temp;
1268   1        unsigned char Estado_expedidor;
1269   1        unsigned char *reelectura;
1270   1        static unsigned char error_lectura=0;
1271   1            
1272   1            Debug_txt_Tibbo((unsigned char *) "TAREA_REELECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");    
1273   1                                  
1274   1            
1275   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1276   1            {
1277   2              
1278   2                for (temp=0; temp<16; ++temp)
1279   2                {
1280   3                  *(reelectura + temp ) =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion
             - de MF en un arreglo*/
1281   3                }
1282   2                *(reelectura + temp )=NULL;
1283   2                Debug_txt_Tibbo((unsigned char *) "Reeletura sector_1 bloque_2:");
1284   2                DebugBufferMF(reelectura,16,RESPUESTA);
1285   2                Debug_txt_Tibbo((unsigned char *) "\r\n");      
1286   2              
1287   2                  if(strcmp(reelectura,lectura_anterior)== 0)
1288   2                  {
1289   3                    error_lectura=0;
1290   3                    Debug_txt_Tibbo((unsigned char *) "Reeletura sector_1 bloque_2 ok");
1291   3                    Debug_txt_Tibbo((unsigned char *) "\r\n");      
1292   3                    *(Atributos_Expedidor + Sector) = Sector_1;
1293   3                    *(Atributos_Expedidor + Bloque) = Bloque_0;
1294   3                    Armar_Trama_Tarjeta_Sector1_Bloque0(lectura_anterior);//Buffer_Write_MF
1295   3                    Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1296   3                  }
1297   2                  else 
1298   2                  {
1299   3                    error_lectura++;
1300   3                    if (error_lectura >=3)
1301   3                    {
1302   4                      Debug_txt_Tibbo((unsigned char *) "Reeletura sector_1 bloque_2 falla");
1303   4                      Estado_expedidor =SEQ_CAPTURE_CARD;
1304   4                      
1305   4                    }
1306   3                    else
1307   3                    {
1308   4                    Debug_txt_Tibbo((unsigned char *) "Reeletura sector_1 bloque_2 falla");
1309   4                    Debug_txt_Tibbo((unsigned char *) "\r\n");      
1310   4                    *(Atributos_Expedidor + Sector) = Sector_1;
1311   4                    *(Atributos_Expedidor + Bloque) = Bloque_2;
1312   4                    Estado_expedidor =SEQ_WRITE_SECTOR_BLOQUE;
1313   4                      
1314   4                    }
1315   3                  }
1316   2                          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 23  

1317   2            }
1318   1              return Estado_expedidor ;
1319   1      }
1320          unsigned char Responde_Write_Tarjeta_Sector1_Bloque1(unsigned char *Buffer_Write_MF)
1321          {
1322   1        unsigned char Estado_expedidor;
1323   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE1\r\n"); 
1324   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b1\r\n");
1325   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1326   1        Estado_expedidor = SEQ_TIPO_CARD;
1327   1        return Estado_expedidor;
1328   1      }
1329          unsigned char Responde_Write_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buf
             -fer_Write_MF)
1330          {
1331   1        unsigned char Estado_expedidor;
1332   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE2\r\n"); 
1333   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b2\r\n");
1334   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1335   1        if(MenSual !=  True)
1336   1        {
1337   2          Estado_expedidor=SEQ_REELER_CARD_SECTOR1_BLOQUE1;
1338   2          /*se graba locatorios*/
1339   2        //*(Atributos_Expedidor + Sector) = Sector_1;
1340   2        //*(Atributos_Expedidor + Bloque) = Bloque_0;
1341   2        //Armar_Trama_Tarjeta_Sector1_Bloque0(Buffer_Write_MF);
1342   2        //  Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1343   2        }
1344   1        else
1345   1        {
1346   2          *(Atributos_Expedidor + Sector) = Sector_1;
1347   2          *(Atributos_Expedidor + Bloque) = Bloque_0;
1348   2          Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1349   2          
1350   2        }
1351   1        return Estado_expedidor;
1352   1      }
1353          /*----------------------------------------------------------------------------
1354          ----------------------------------------------------------------------------*/
1355          unsigned char Responde_Write_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1356          {
1357   1      
1358   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE0\r\n"); 
1359   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b0\r\n");
1360   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1361   1        
1362   1        return SEQ_PLACA;         //SEQ_LPR
1363   1      }
1364          /*----------------------------------------------------------------------------
1365          ----------------------------------------------------------------------------*/
1366          unsigned char Responde_Write_Tarjeta_Sector2_Bloque0(unsigned char *Buffer_Write_MF)
1367          {
1368   1        
1369   1        Debug_txt_Tibbo((unsigned char *) "PLACA:");  
1370   1        Debug_txt_Tibbo((unsigned char *) placa);
1371   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1372   1        Debug_txt_Tibbo((unsigned char *) "Write_s2_b0\r\n");
1373   1        DebugBufferMF(Buffer_Write_MF,16,ENVIADOS);
1374   1        return SEQ_FRONT_CARD;
1375   1      }
1376          
1377          /*----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 24  

1378          ----------------------------------------------------------------------------*/
1379          unsigned char Pregunta_Lpr(unsigned char *Atributos_Expedidor)
1380          {
1381   1        unsigned char Estado_expedidor;
1382   1        Debug_txt_Tibbo((unsigned char *) "PREGUNTA LPR\r\n");
1383   1         hora_entrada_vehiculo(Atributos_Expedidor);
1384   1          if(rd_eeprom(0xa8,EE_USE_LPR)== True)
1385   1             {
1386   2               /*monitor trama*/
1387   2               Debug_txt_Tibbo(Armar_Trama_Monitor(Atributos_Expedidor));
1388   2                if (rd_eeprom(0xa8,EE_DEBUG) == False)
1389   2                 {
1390   3                   Debug_Tibbo=False;
1391   3                 }
1392   2             }
1393   1        
1394   1      
1395   1          Estado_expedidor=SEQ_LOAD_PASSWORD;         //SEQ_TIPO_TARJETAS;
1396   1      
1397   1        return Estado_expedidor;
1398   1      }
1399          
1400          unsigned char Pregunta_Placa()
1401          {
1402   1        unsigned char Estado_expedidor;
1403   1        Debug_txt_Tibbo((unsigned char *) "PREGUNTA PLACA\r\n");
1404   1          if (rd_eeprom(0xa8,EE_PLACA)!= False)
1405   1          {
1406   2            /*espero placa*/
1407   2            Estado_expedidor=SEQ_WAIT_PLACA;
1408   2            ValTimeOutCom=TIME_WAIT ;
1409   2            Timer_wait=False;
1410   2          }
1411   1          else 
1412   1          {
1413   2          Estado_expedidor=SEQ_FRONT_CARD;
1414   2          }
1415   1        return Estado_expedidor;
1416   1      }
1417          unsigned char  Respuesta_Segunda_clave(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1418          {
1419   1        
1420   1        Debug_txt_Tibbo((unsigned char *) "TAREA_SEGUNDA CLAVE\r\n"); 
1421   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1422   1      
1423   1        
1424   1        *(Atributos_Expedidor + Sector) = Sector_2;
1425   1        *(Atributos_Expedidor + Bloque) = Bloque_0;
1426   1        Armar_Trama_Placa(Buffer_Write_MF);
1427   1          
1428   1        return SEQ_WRITE_SECTOR_BLOQUE;
1429   1      }
1430          unsigned char Respuesta_Placa_Cancel(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1431          {
1432   1        unsigned char Estado_expedidor;
1433   1        unsigned char *Cancel="CANCEL";
1434   1        Debug_txt_Tibbo((unsigned char *) "RESPUESTA PLACA O CANCEL = "); 
1435   1        Debug_txt_Tibbo((unsigned char *) placa);
1436   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1437   1        
1438   1        if(strcmp(placa,Cancel)== 0)
1439   1        {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 25  

1440   2          *(Atributos_Expedidor + Sector) = Sector_1;
1441   2          *(Atributos_Expedidor + Bloque) = Bloque_1;
1442   2          Armar_Trama_Tarjeta_Sector1_Bloque1_Camcel(Buffer_Write_MF);
1443   2          Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1444   2        }
1445   1        else
1446   1        {
1447   2          if(MenSual ==  True)
1448   2          {
1449   3            Estado_expedidor = SEQ_FRONT_CARD;  
1450   3          }
1451   2          else
1452   2          {
1453   3            
1454   3            Estado_expedidor = SEQ_SECOND_PASSWORD;
1455   3          }     
1456   2        } 
1457   1        return Estado_expedidor;
1458   1      }
1459          /*------------------------------------------------------------------------------
1460          ------------------------------------------------------------------------------*/
1461          void  Armar_Trama_Tarjeta_Sector1_Bloque1_Camcel(unsigned char *Buffer_Write_MF)
1462          {
1463   1        unsigned char ID_CLIENTE;
1464   1        unsigned char COD_PARK; 
1465   1          /*cuando se recibe el CAMCEL se bloquea la tarjeta*/
1466   1        clear_placa();
1467   1        ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1468   1        COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
1469   1      
1470   1        *(Buffer_Write_MF + MF_TIPO_TARJETA)  = MENSUALIDAD;
1471   1        *(Buffer_Write_MF + MF_COD_PARK)      = COD_PARK; 
1472   1        *(Buffer_Write_MF + MF_COD_PARK+1)    = NULL;
1473   1        *(Buffer_Write_MF + MF_ID_CLIENTE)    = ID_CLIENTE;
1474   1        *(Buffer_Write_MF + MF_ID_CLIENTE+1)  = NULL;
1475   1        *(Buffer_Write_MF + MF_MENSUAL_ANO)   = NULL;
1476   1        *(Buffer_Write_MF + MF_MENSUAL_MES)   = NULL;
1477   1        *(Buffer_Write_MF + MF_MENSUAL_DIA)   = NULL;
1478   1        *(Buffer_Write_MF + MF_EXPIRA_ANO)    = NULL;
1479   1        *(Buffer_Write_MF + MF_EXPIRA_MES)    = NULL;
1480   1        *(Buffer_Write_MF + MF_EXPIRA_DIA)    = NULL;
1481   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+1)  = NULL;
1482   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+2)  = NULL;
1483   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+3)  = NULL;
1484   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+4)  = NULL;
1485   1      }
1486          
1487          /*------------------------------------------------------------------------------
1488          ------------------------------------------------------------------------------*/
1489          
1490          void  Armar_Trama_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_M
             -F)
1491          {
1492   1        
1493   1        /*fecha de ingreso se lee año,mes,dia,hora y minutos*/
1494   1      
1495   1        //Block_read_Clock_Hex(Buffer_Write_MF);
1496   1        *(Buffer_Write_MF + 0)= bcd_hex(*(Atributos_Expedidor +  DateTime_year));
1497   1        *(Buffer_Write_MF + 1)= bcd_hex(*(Atributos_Expedidor +  DateTime_month));
1498   1        *(Buffer_Write_MF + 2)= bcd_hex(*(Atributos_Expedidor +  DateTime_day));
1499   1        *(Buffer_Write_MF + 3)= bcd_hex(*(Atributos_Expedidor +  DateTime_hour));
1500   1        *(Buffer_Write_MF + 4)= bcd_hex(*(Atributos_Expedidor +  DateTime_minutes));
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 26  

1501   1        /*descuentos los borro*/
1502   1        
1503   1        *(Buffer_Write_MF + 5)=0;
1504   1        *(Buffer_Write_MF + 6)=0;
1505   1        *(Buffer_Write_MF + 7)=0;
1506   1        
1507   1        if (*(Atributos_Expedidor + Tipo_Tarjeta) == ROTACION)
1508   1        {
1509   2          *(Buffer_Write_MF + 8)  = Tipo_Vehiculo;
1510   2          *(Buffer_Write_MF + 9)  = (Dir_board())- 0x30;
1511   2          *(Buffer_Write_MF +10) = APB_INT;
1512   2        }
1513   1        
1514   1        /*mensual*/
1515   1        else
1516   1        {
1517   2          
1518   2          *(Buffer_Write_MF + 8)  = (*(Atributos_Expedidor + Horario) << 4) | (*(Atributos_Expedidor + Type_Vehicu
             -lo));
1519   2          *(Buffer_Write_MF + 9)  =  (*(Atributos_Expedidor + Pico_Placa) << 4)| (Dir_board())- 0x30;
1520   2          
1521   2          if (*(Atributos_Expedidor + Apb)== APB_NO)
1522   2           {
1523   3              *(Buffer_Write_MF +10) =APB_NO;
1524   3            }
1525   2          else 
1526   2          {
1527   3            *(Buffer_Write_MF +10) =APB_INT;
1528   3          }
1529   2        }
1530   1        /*fecha de salida maxima*/
1531   1        *(Buffer_Write_MF +11)=0;
1532   1        *(Buffer_Write_MF +12)=0;
1533   1        *(Buffer_Write_MF +13)=0;
1534   1        *(Buffer_Write_MF +14)=0;
1535   1        *(Buffer_Write_MF +15)=0;
1536   1      }
1537          void Armar_Trama_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1538          {
1539   1        /*graba serie de Ticket*/
1540   1        strcpy(Buffer_Write_MF, Lee_No_Ticket());
1541   1      }
1542          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor(unsigned char *Atributos_Expedidor,unsigned char *longit
             -ud_trama_pto_paralelo)
1543          {
1544   1        static unsigned char buffer[28];
1545   1        unsigned char ticket[11];
1546   1        unsigned char j;
1547   1        /*la trama esta compuesta de
1548   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1549   1      
1550   1        buffer[0]=STX;
1551   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR;
1552   1        buffer[2]=NULL;
1553   1        strcpy(ticket, Lee_No_Ticket());
1554   1        strcat(buffer , ticket);
1555   1        j=strlen(buffer);
1556   1        
1557   1        buffer[j++]= '-';
1558   1        /*leo fecha de entrada*/
1559   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_year))   + 0x30;
1560   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_month))  + 0x30;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 27  

1561   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_day))    + 0x30;
1562   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_hour))   + 0x30;
1563   1        buffer[j++]= bcd_hex(*(Atributos_Expedidor +  DateTime_minutes))+ 0x30;
1564   1        buffer[j++]= '-';
1565   1        
1566   1        //Block_read_Clock_Hex(buffer+j);         //leo la fecha de entrada
1567   1        //buffer[j]=buffer[j]+0x030;              /*año de entrada*/
1568   1        //buffer[j+1]=buffer[j+1]+0x030;          /*mes de entrada*/
1569   1        //buffer[j+2]=buffer[j+2]+0x030;          /*dia de entrada*/
1570   1        //buffer[j+3]=buffer[j+3]+0x030;          /*hora de entrada*/
1571   1        //buffer[j+4]=buffer[j+4]+0x030;          /*minutos de entrada*/
1572   1        //buffer[j+5]= '-';
1573   1        /*placa*/
1574   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1575   1        {   
1576   2          if (placa_ready != False)
1577   2          {
1578   3            buffer[j++]= placa[0];
1579   3            buffer[j++]= placa[1];
1580   3            buffer[j++]= placa[2];
1581   3            buffer[j++]= placa[3];
1582   3            buffer[j++]= placa[4];
1583   3            buffer[j++]= placa[5];
1584   3            buffer[j++]= NULL;
1585   3          }
1586   2          else
1587   2          {
1588   3            buffer[j++]= ' ';
1589   3            buffer[j++]= NULL;
1590   3          }
1591   2        }
1592   1        else 
1593   1        {
1594   2          buffer[j++]= ' ';
1595   2          buffer[j++]=NULL;
1596   2        }
1597   1        j=strlen(buffer);
1598   1        buffer[j]= ETX;
1599   1        *longitud_trama_pto_paralelo=j+1;
1600   1        
1601   1        return buffer;
1602   1      }
1603          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor,unsigned char
             - *longitud_trama_pto_paralelo)
1604          {
1605   1        static unsigned char buffer[28];
1606   1      
1607   1        /*la trama esta compuesta de
1608   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1609   1      
1610   1        buffer[0]=STX;
1611   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
1612   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
1613   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
1614   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
1615   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
1616   1        
1617   1        /*leo fecha de entrada*/
1618   1        
1619   1        buffer[6]= bcd_hex(*(Atributos_Expedidor +  DateTime_year))   + 0x30;
1620   1        buffer[7]= bcd_hex(*(Atributos_Expedidor +  DateTime_month))  + 0x30;
1621   1        buffer[8]= bcd_hex(*(Atributos_Expedidor +  DateTime_day))    + 0x30;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 28  

1622   1        buffer[9]= bcd_hex(*(Atributos_Expedidor +  DateTime_hour))   + 0x30;
1623   1        buffer[10]= bcd_hex(*(Atributos_Expedidor + DateTime_minutes))+ 0x30;
1624   1        
1625   1      //  Block_read_Clock_Hex(buffer+6);         //leo la fecha de entrada
1626   1      //  buffer[6]=buffer[6]+0x030;              /*año de entrada*/
1627   1      //  buffer[7]=buffer[7]+0x030;          /*mes de entrada*/
1628   1      //  buffer[8]=buffer[8]+0x030;          /*dia de entrada*/
1629   1      //  buffer[9]=buffer[9]+0x030;          /*hora de entrada*/
1630   1      //  buffer[10]=buffer[10]+0x030;          /*minutos de entrada*/
1631   1      
1632   1        /*placa*/
1633   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1634   1        {   
1635   2          
1636   2            buffer[11]= placa[0];
1637   2            buffer[12]= placa[1];
1638   2            buffer[13]= placa[2];
1639   2            buffer[14]= placa[3];
1640   2            buffer[15]= placa[4];
1641   2            buffer[16]= placa[5];
1642   2      
1643   2        }
1644   1      
1645   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1646   1        {
1647   2          buffer[17]= 'C';
1648   2        }
1649   1        else
1650   1        {
1651   2          buffer[17]= 'M';
1652   2        }
1653   1        
1654   1        buffer[18]= ETX;
1655   1        buffer[19]= NULL;
1656   1        *longitud_trama_pto_paralelo=19;
1657   1        return buffer;
1658   1      }
1659          unsigned char *Armar_Trama_Monitor(unsigned char *Atributos_Expedidor)
1660          {
1661   1        static unsigned char buffer[24];
1662   1        unsigned char ticket[11];
1663   1        unsigned char j;
1664   1        /*la trama esta compuesta de
1665   1        STX,address_board,CMD,Tipo_Vehiculo,NoTICKET,:,fecha int añomesdishoraminuto,:,ETX*/
1666   1        Debug_Tibbo=False;
1667   1        buffer[0]=STX;
1668   1        buffer[1]=Dir_Board_Monitor();
1669   1        buffer[2]=CMD_MONITOR_EXPEDIDOR;
1670   1        if(Tipo_Vehiculo == AUTOMOVIL)
1671   1          {
1672   2            buffer[3]= 'C';
1673   2          }
1674   1        else
1675   1          {
1676   2            buffer[3]= 'M';
1677   2          }
1678   1          
1679   1          /*ticket*/
1680   1          if(MenSual !=  True)
1681   1          {
1682   2          buffer[4]=NULL;
1683   2          strcpy(ticket, Lee_No_Ticket());
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 29  

1684   2          strcat(buffer , ticket);
1685   2          }
1686   1          else
1687   1          {
1688   2            ByteHex_Decimal(buffer+4,*(Atributos_Expedidor + Uid_2));
1689   2            j=strlen(buffer);
1690   2            buffer[j]= ' ';
1691   2            buffer[j+1]= NULL;
1692   2            j=strlen(buffer);
1693   2            Two_ByteHex_Decimal(buffer+j,*(Atributos_Expedidor + Uid_1),*(Atributos_Expedidor + Uid_0));
1694   2            
1695   2          }
1696   1          j=strlen(buffer);
1697   1          buffer[j++]=':';
1698   1          /*fecha de entrada*/
1699   1          /*parte alta del año*/
1700   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_year))  & 0xf0) >> 4)    | 0x30;
1701   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_year))  & 0x0f)          | 0x30;
1702   1        
1703   1          /* parte alta mes*/
1704   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_month))  & 0xf0) >> 4)   | 0x30;
1705   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_month))  & 0x0f)         | 0x30;
1706   1          
1707   1          /*parte alta dia*/
1708   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_day))  & 0xf0) >> 4)     | 0x30;
1709   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_day))  & 0x0f)           | 0x30;  
1710   1          
1711   1          /*parte alta horas*/
1712   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_hour))  & 0xf0) >> 4)    | 0x30;
1713   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_hour))  & 0x0f)          | 0x30;    
1714   1          
1715   1          /*parte alta minutos*/
1716   1          buffer[j++]= (((*(Atributos_Expedidor +  DateTime_minutes))  & 0xf0) >> 4) | 0x30;
1717   1          buffer[j++]= ((*(Atributos_Expedidor +   DateTime_minutes))  & 0x0f)       | 0x30;  
1718   1          buffer[j++]=NULL;
1719   1          
1720   1          //Block_read_clock_ascii(buffer+j+1);     //leo la fecha de entrada
1721   1          j=strlen(buffer);
1722   1        
1723   1          buffer[j]= ':';
1724   1          buffer[j+1]=ETX;
1725   1          buffer[j+2]=NULL;
1726   1          Debug_Tibbo=True;
1727   1        return buffer;
1728   1      }
1729          void Armar_Trama_Placa(unsigned char *Buffer_Write_MF)
1730          {
1731   1        unsigned char j;
1732   1        unsigned char len_placa;
1733   1        len_placa = strlen(placa);
1734   1          for(j=0; j<len_placa;j++)
1735   1          {
1736   2          *(Buffer_Write_MF +j)=placa[j];
1737   2          }
1738   1            for (j=len_placa; j<16; j++)            
1739   1          {
1740   2            *(Buffer_Write_MF +j)=0x00;
1741   2          }
1742   1      }
1743          unsigned char Load_Secuencia_Expedidor(unsigned char *Secuencia_Expedidor,unsigned const  estadoactivo,uns
             -igned const estadoactual,unsigned const estadofuturo)
1744          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 30  

1745   1        *(Secuencia_Expedidor + EstadoPasado ) = estadoactivo ;
1746   1        *(Secuencia_Expedidor + EstadoActual ) = estadoactual;
1747   1        *(Secuencia_Expedidor + EstadoFuturo ) = estadofuturo;
1748   1        return estadoactual;
1749   1      }
1750          unsigned char Disparo_Lock_Entrada_Vehiculo(unsigned char *Nombre_Mensual)
1751          {
1752   1        unsigned char Estado_expedidor;
1753   1        static unsigned char take_card=6;
1754   1        
1755   1        
1756   1        Debug_txt_Tibbo((unsigned char *) "TAKE CARD\r\n");
1757   1        
1758   1        //PantallaLCD(RETIRE_TARJETA);
1759   1        
1760   1        if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                   // CANAL LIBRE    no tiene tarjetas 
             -en el mecanismo
1761   1          {
1762   2            
1763   2            Debug_txt_Tibbo((unsigned char *) "TAREA_OPEN_BARRERA\r\n");
1764   2              
1765   2            take_card=6;
1766   2            lock=ON;
1767   2            send_portERR(BIENVENIDO);
1768   2            send_portERR(AUDIO_ENTRADA);  
1769   2            PantallaLCD_LINEA_2(BIENVENIDO,Nombre_Mensual);
1770   2            Estado_expedidor=SEQ_PTO_PARALELO;
1771   2            
1772   2            
1773   2          }
1774   1        else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                      //  se detecta la tarjeta en la b
             -oca TARJETA EN BEZZEL
1775   1        {
1776   2          if(Valida_Sensor1_Auto()!= False)
1777   2          {
1778   3            if(take_card >= 6)
1779   3                  { PantallaLCD(RETIRE_TARJETA);
1780   4                    take_card=0;
1781   4                  }
1782   3                  else
1783   3                   {
1784   4                     take_card++;
1785   4                       
1786   4                   }
1787   3            
1788   3            ValTimeOutCom=TIME_PULSADOR;
1789   3            Estado_expedidor=SEQ_DETAIL_CARD;
1790   3            
1791   3          }
1792   2          else
1793   2          {
1794   3            Estado_expedidor=SEQ_CAPTURE_CARD;
1795   3          }
1796   2        
1797   2        }
1798   1        
1799   1          
1800   1        
1801   1        
1802   1        return Estado_expedidor;
1803   1      }
1804          unsigned char Send_Pto_Paralelo(unsigned char *Atributos_Expedidor)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 31  

1805          {
1806   1        unsigned char *Trama_Expedidor ;
1807   1        unsigned char leng_trama_pto;
1808   1        if(MenSual == True)
1809   1        {
1810   2        Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor,&leng_trama_pto );
1811   2        }
1812   1        else 
1813   1        {
1814   2          Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor(Atributos_Expedidor,&leng_trama_pto);
1815   2          Incremente_Ticket();
1816   2        }
1817   1        
1818   1        send_port(Trama_Expedidor,leng_trama_pto);  
1819   1        Debug_txt_Tibbo((unsigned char *) "Trama_pto_paralelo: ");
1820   1        DebugBufferMF(Trama_Expedidor,leng_trama_pto,SIN_MSJ  );
1821   1        
1822   1        
1823   1        
1824   1        clear_placa();
1825   1        ValTimeOutCom=TIME_WAIT ;
1826   1        Timer_wait=0;
1827   1        PULSADOR_BOTTON = 0;
1828   1        return SEQ_ESPERA_VEHICULO_ENTRE;
1829   1      }
1830          
1831          /*------------------------------------------------------------------------------
1832          ------------------------------------------------------------------------------*/
1833          unsigned char Entrega_Card_Captura()
1834          {
1835   1        unsigned char Estado_expedidor;
1836   1        
1837   1          
1838   1        Debug_txt_Tibbo((unsigned char *) "ESPERA VEHICULO ENTRE\r\n"); 
1839   1        sel_Sensor2();                                //garantiso q la barrera se encuentre en posicion baja  
1840   1        if ((DataIn==0))        
1841   1        {  
1842   2          if (ValidaSensor()==0)
1843   2          {
1844   3            lock=OFF;
1845   3            pto_paraleo=False;
1846   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo Entrando OFF_BARRERA\r\n");
1847   3            Estado_expedidor=SEQ_INICIO;
1848   3          }
1849   2          
1850   2        }
1851   1        else
1852   1        {
1853   2            if(Valida_Sensor1_Auto()!= False)
1854   2            {
1855   3            /*presencia vehicular*/
1856   3              Estado_expedidor=SEQ_ESPERA_VEHICULO_ENTRE;//SEQ_INICIO;//
1857   3              
1858   3              if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1859   3              {
1860   4                  if (Timer_wait >= 5)
1861   4               {
1862   5                 pto_paraleo=False;
1863   5                 Debug_txt_Tibbo((unsigned char *) "Vehiculo TIEMPO OFF_BARRERA\r\n");
1864   5                
1865   5                 lock=OFF;
1866   5                 Estado_expedidor=SEQ_INICIO;;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 32  

1867   5               }
1868   4              else if (Timer_wait <= 4)
1869   4               {
1870   5                ValTimeOutCom=TIME_WAIT ;
1871   5               }
1872   4             }
1873   3              
1874   3            }
1875   2            else
1876   2            {
1877   3            pto_paraleo=False;
1878   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo NO LOOP OFF_BARRERA\r\n");
1879   3            lock=OFF;
1880   3            Estado_expedidor=SEQ_INICIO;
1881   3            }
1882   2        } 
1883   1       
1884   1        return Estado_expedidor;
1885   1      }
1886          unsigned char Wait_Placa(unsigned char *Atributos_Expedidor, unsigned char *Buffer_Write_MF)
1887          {
1888   1        unsigned char Estado_expedidor;
1889   1        
1890   1          Debug_txt_Tibbo((unsigned char *) "Wait_Placa");
1891   1        /*espera la llega de placa o cancel*/
1892   1        while ((ValTimeOutCom != 1) && (ValTimeOutCom <= TIME_WAIT) && (placa_ready == False))
1893   1        {
1894   2          if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
1895   2              {
1896   3                
1897   3                Rx_Monitor();
1898   3              }
1899   2        }
1900   1          /*llego Cancel o placa*/
1901   1          if(placa_ready!=False)
1902   1            {
1903   2              Estado_expedidor = Respuesta_Placa_Cancel(Atributos_Expedidor,Buffer_Write_MF);
1904   2            }
1905   1            else
1906   1              /*no llego placa o cancel*/
1907   1            {
1908   2                Estado_expedidor=SEQ_WAIT_PLACA;
1909   2             if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1910   2             {  
1911   3              if (Timer_wait >= 5)
1912   3               {
1913   4                 strcpy (placa,"NOPLATE");
1914   4                 Estado_expedidor=SEQ_SECOND_PASSWORD;        //SEQ_FRONT_CARD;
1915   4               }
1916   3              else if (Timer_wait <= 4)
1917   3               {
1918   4                ValTimeOutCom=TIME_WAIT ;
1919   4               }
1920   3             }
1921   2            }
1922   1        return Estado_expedidor;
1923   1      }
1924          unsigned char Valida_Vehiculo_Card_Mensual(unsigned char *Atributos_Expedidor)
1925          {
1926   1        unsigned char Estado_expedidor;
1927   1        
1928   1          Debug_txt_Tibbo((unsigned char *) "VEHICULO MENSUAL TARJETA: ");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 33  

1929   1          if(*(Atributos_Expedidor + Type_Vehiculo  ) == False)
1930   1           {
1931   2            Debug_txt_Tibbo((unsigned char *) "(0) CARRO");
1932   2           }
1933   1          else
1934   1           {
1935   2            Debug_txt_Tibbo((unsigned char *) "(1) MOTO");
1936   2           }
1937   1                            
1938   1          Debug_txt_Tibbo((unsigned char *) "\r\n");
1939   1        if ((rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL)) != True) 
1940   1        {
1941   2          if  (*(Atributos_Expedidor + Type_Vehiculo  ) == Tipo_Vehiculo )          
1942   2          {
1943   3           Debug_txt_Tibbo((unsigned char *) "COINCIDE CARD CON LOOK\r\n ");
1944   3            Estado_expedidor = True ;
1945   3          }
1946   2          
1947   2          else
1948   2          {
1949   3            send_portERR(PRMR_ERROR_TIPO_VEHICULO); 
1950   3            Debug_txt_Tibbo((unsigned char *) "TIPO DE VEHICULO NO CORRESPONDE\r\n ");
1951   3            Estado_expedidor = False; 
1952   3          }
1953   2        } 
1954   1        else 
1955   1        {
1956   2            Debug_txt_Tibbo((unsigned char *) "NO INTERESA COINCIDENCIA CARD CON LOOK\r\n ");
1957   2            Estado_expedidor = True ;
1958   2        }
1959   1          return Estado_expedidor;
1960   1      }
1961          unsigned char Tarjeta_Mensual(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1962          {
1963   1        unsigned char Estado_expedidor;
1964   1      //  unsigned char fecha_asii[7];
1965   1        
1966   1        /*cheque la fecha de expiracion del mensual*/
1967   1        if (Horarios(Atributos_Expedidor) == True)
1968   1        {
1969   2         if ( check_fechaOut(Atributos_Expedidor+Expira_ano) == True )
1970   2            {
1971   3              /*valida el vehiculo en el loop y en la card*/
1972   3              if( Valida_Vehiculo_Card_Mensual(Atributos_Expedidor) == False)
1973   3              {
1974   4              Estado_expedidor = Captura_Expulsa();   
1975   4              }
1976   3              else
1977   3              {
1978   4                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1979   4                *(Atributos_Expedidor + Sector) = Sector_1;
1980   4                *(Atributos_Expedidor + Bloque) = Bloque_2;
1981   4                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1982   4                Estado_expedidor=SEQ_WRITE_SECTOR_BLOQUE;
1983   4              }
1984   3            }
1985   2            else 
1986   2            {
1987   3              send_portERR(PRMR_TARJETA_VENCIDA); 
1988   3                  
1989   3              PantallaLCD(TARJETA_VENCIDA);
1990   3              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 34  

1991   3              Estado_expedidor = SEQ_EXPULSAR_CARD;
1992   3            }
1993   2        }
1994   1        else
1995   1        {
1996   2          
1997   2          Estado_expedidor = SEQ_EXPULSAR_CARD;
1998   2        }
1999   1        return Estado_expedidor;
2000   1      }
2001          unsigned char Tarjeta_Rotacion(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
2002          {
2003   1              *(Atributos_Expedidor + Sector) = Sector_1;
2004   1                *(Atributos_Expedidor + Bloque) = Bloque_2;
2005   1                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
2006   1                return  SEQ_WRITE_SECTOR_BLOQUE;
2007   1        
2008   1        
2009   1      }
2010          unsigned char Valida_Tipo_Tarjeta(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
2011          {
2012   1        unsigned char Estado_expedidor;
2013   1        if(*(Atributos_Expedidor + Tipo_Tarjeta) ==  MENSUALIDAD)
2014   1        {
2015   2          Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
2016   2          if(MenSual ==  True)
2017   2          {
2018   3          
2019   3          /*APB Habilitado por software*/
2020   3          
2021   3            if( (rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL) == APB_HABILITADO_SOFT) )
2022   3            {
2023   4              /*APB por Card*/
2024   4           
2025   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO))       
2026   4              {
2027   5                Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
2028   5      
2029   5              }
2030   4              else
2031   4              {
2032   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK MENSUAL \r\n");
2033   5                send_portERR(PRMR_SIN_SALIDA);
2034   5                Estado_expedidor = Captura_Expulsa(); 
2035   5              } 
2036   4            }
2037   3          
2038   3          else
2039   3          {
2040   4            Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO MENSUAL \r\n");
2041   4          
2042   4           Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
2043   4          }
2044   3        }
2045   2        else
2046   2         {
2047   3          send_portERR(PRMR_NO_CARD_MENSUAL);
2048   3          PantallaLCD(NO_CARD_MENSUAL);     
2049   3          Estado_expedidor = Captura_Expulsa(); 
2050   3         } 
2051   2       }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 35  

2052   1        else if (*(Atributos_Expedidor + Tipo_Tarjeta) ==  ROTACION)
2053   1        {
2054   2          
2055   2            Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n ");
2056   2          if(MenSual != True)
2057   2          {
2058   3            if ( (rd_eeprom(0xa8,EE_HABILITA_APB))!= APB_INHABILITADO_SOFT)
2059   3            {
2060   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO) )
2061   4                                    
2062   4              {
2063   5                Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
2064   5              }
2065   4              else
2066   4              {
2067   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK ROTACION \r\n");
2068   5                send_portERR(PRMR_SIN_SALIDA);
2069   5                PantallaLCD(SIN_SALIDA);
2070   5                Estado_expedidor = Captura_Expulsa();
2071   5              }
2072   4            }
2073   3            else
2074   3            {
2075   4              Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO ROTACION \r\n");
2076   4              Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
2077   4            } 
2078   3          }
2079   2          else
2080   2          {
2081   3            /*tarjeta por insercion por boca */ 
2082   3            send_portERR(PRMR_NO_CARD_MENSUAL);
2083   3            PantallaLCD(NO_CARD_MENSUAL);     
2084   3            Estado_expedidor = SEQ_EXPULSAR_CARD;       //Captura_Expulsa();    
2085   3          }
2086   2        }
2087   1        else
2088   1        {
2089   2          Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n ");
2090   2          send_portERR(PRMR_NO_ROTACION);
2091   2          
2092   2          Estado_expedidor = Captura_Expulsa();   
2093   2        }
2094   1        
2095   1        return Estado_expedidor;
2096   1      }
2097          /*
2098          unsigned char Festivos()
2099          {
2100            
2101            unsigned char dia_semana,day, month, year,DiaFestivo=0;
2102          
2103            
2104            dia_semana=bcd_hex(lee_clk(RDIA_SEMANA));
2105            day = bcd_hex(lee_clk(RDIA));
2106            month = bcd_hex(lee_clk(RMES));
2107            year = bcd_hex(lee_clk(RANO));
2108            
2109            if (year==20)
2110            {
2111              if (((month==1)&&(day==1))||((month==1)&&(day==6))||((month==3)&&(day==23))||((month==4)&&(day==9))||((m
             -onth==4)&&(day==10))||((month==5)&&(day==1))||((month==5)&&(day==25))||((month==6)&&(day==3)))  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 36  

2112              {
2113                DiaFestivo = True;
2114                }
2115              else if (((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==17))||((month==10)&&(day==1
             -2))||((month==11)&&(day==2))||((month==11)&&(day==16))||((month==12)&&(day==8))||((month==12)&&(day==25)))
2116              {
2117                DiaFestivo = True;
2118              }
2119          
2120            }
2121            else if (year==21)
2122            {
2123              if (((month==1)&&(day==1))||((month==1)&&(day==11))||((month==3)&&(day==22))||((month==4)&&(day==1))||((
             -month==4)&&(day==2))||((month==5)&&(day==1))||((month==5)&&(day==17))||((month==6)&&(day==7))||((month==6)&&(day==14))) 
2124              {
2125                DiaFestivo = True;
2126                }
2127              else if (((month==7)&&(day==5))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==16)
             -)||((month==10)&&(day==18))||((month==11)&&(day==1))||((month==11)&&(day==15))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
2128              {
2129                DiaFestivo = True;
2130              }
2131          
2132            }
2133            else if (year==22)
2134            {
2135              if (((month==1)&&(day==1))||((month==1)&&(day==10))||((month==3)&&(day==21))||((month==4)&&(day==14))||(
             -(month==4)&&(day==15))||((month==5)&&(day==1))||((month==5)&&(day==30))||((month==6)&&(day==20))||((month==6)&&(day==27)
             -))  
2136              {
2137                DiaFestivo = True;
2138                }
2139              else if (((month==7)&&(day==4))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==15)
             -)||((month==10)&&(day==17))||((month==11)&&(day==7))||((month==11)&&(day==14))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
2140              {
2141                DiaFestivo = True;
2142              }
2143          
2144            
2145            
2146            }
2147            if ((dia_semana == Sabado)||(dia_semana == Domingo)||(DiaFestivo == True))
2148            {
2149              DiaFestivo = True;
2150            }
2151            else
2152            {
2153              DiaFestivo = False;
2154            }
2155            return DiaFestivo;
2156          }
2157          */
2158          /*
2159          unsigned char Dia_Pico_Placa(unsigned char * Atributos_Expedidor)
2160          {
2161            unsigned char Par_Impar;
2162            unsigned char dato;
2163            
2164            if( Festivos() == False)
2165            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 37  

2166            dato=lee_clk(RDIA);
2167          
2168              if((dato % 2 == False) && (*(Atributos_Expedidor + Pico_Placa)  == True))
2169              {
2170              
2171              /*es par*/
2172          /*
2173              Par_Impar = True;
2174              
2175              }
2176              else
2177              {
2178              /*es impar */
2179              /*
2180              Par_Impar = False;
2181              }
2182            }
2183            else
2184            {
2185              Par_Impar = True;
2186            }
2187            return Par_Impar;
2188          }
2189          */
2190          unsigned char Horarios(unsigned char * Atributos_Expedidor)
2191          {
2192   1        unsigned char Estado_Horario;
2193   1        
2194   1        unsigned char Addr_horarios [11];
2195   1        unsigned char dia_semana,EE_dia_semana;
2196   1        unsigned int addr;
2197   1        if (*(Atributos_Expedidor + Horario) != False )
2198   1        {
2199   2          /*se Lee la direccion del horario*/
2200   2          strcpy (Addr_horarios,(Addr_Horarios()));
2201   2          
2202   2          addr= Addr_horarios[(*(Atributos_Expedidor + Horario)) -1] ;
2203   2          
2204   2           /*leemos si esta habilitado*/
2205   2          
2206   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
2207   2          {
2208   3            /*miramos si el dia de la semana esta habilitado*/
2209   3            dia_semana = lee_clk(RDIA_SEMANA);
2210   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
2211   3            Debug_chr_Tibbo(dia_semana);
2212   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
2213   3            
2214   3          
2215   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
2216   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
2217   3            Debug_chr_Tibbo(EE_dia_semana);
2218   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
2219   3          
2220   3            if ( EE_dia_semana == dia_semana)
2221   3            {
2222   4              /*miramos si esta en el rango del horario*/
2223   4              Estado_Horario = Bloque_Horario(addr);
2224   4            }
2225   3            else
2226   3            {
2227   4      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 38  

2228   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
2229   4              Estado_Horario= False;
2230   4            }
2231   3          }
2232   2          else 
2233   2          {
2234   3            
2235   3            Estado_Horario= False;
2236   3            PantallaLCD(HORARIO_NO_PROG);
2237   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
2238   3            
2239   3          }
2240   2          
2241   2        }
2242   1        else
2243   1        {
2244   2          Estado_Horario = True;
2245   2        
2246   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
2247   2        }
2248   1        return Estado_Horario;
2249   1      }
2250          unsigned int Hora_Maxima(unsigned int addr)
2251          {
2252   1        unsigned char Hora_High,  Minuto_High;
2253   1        unsigned char HoraIni , MinutoIni; 
2254   1        unsigned int  Hora_Prog;
2255   1        
2256   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
2257   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
2258   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
2259   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
2260   1         Debug_chr_Tibbo(HoraIni);
2261   1         Debug_chr_Tibbo(MinutoIni);
2262   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
2263   1        
2264   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
2265   1      }
2266          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
2267          {
2268   1        unsigned char Estado_Horario; 
2269   1        
2270   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
2271   1        {
2272   2          
2273   2          /*hasta la hora que puede ingresar el vehiculo */
2274   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
2275   2          Hora_Prog = Hora_Maxima(addr+4);
2276   2      
2277   2        
2278   2          if( HoraNow <= Hora_Prog)
2279   2          {
2280   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2281   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
2282   3            Estado_Horario = True;
2283   3          }
2284   2          else
2285   2          {
2286   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2287   3            //PantallaLCD(MENSUAL_FUERA_HORARIO);
2288   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
2289   3            Estado_Horario = False;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 39  

2290   3          }
2291   2          
2292   2        }
2293   1        else
2294   1        {
2295   2              //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2296   2              //PantallaLCD(MENSUAL_FUERA_HORARIO);
2297   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
2298   2              Estado_Horario = False;
2299   2            
2300   2        }
2301   1        return Estado_Horario;
2302   1      }
2303          
2304          unsigned Bloque_Horario(unsigned int addr)
2305          {
2306   1        unsigned char Estado_Horario; 
2307   1        unsigned int HoraNow, Hora_Prog;
2308   1        
2309   1        /*la hora del momento de entrada del vehiculo*/
2310   1        
2311   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
2312   1        Debug_chr_Tibbo(lee_clk(RHORA));
2313   1        Debug_chr_Tibbo(lee_clk(RMIN));
2314   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
2315   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
2316   1        
2317   1        /* desde la hora en que puede ingresar vehiculo */
2318   1        
2319   1        
2320   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
2321   1        Hora_Prog = Hora_Maxima(addr);
2322   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
2323   1        if(Estado_Horario == False )
2324   1        {
2325   2          
2326   2            
2327   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
2328   2            {
2329   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
2330   3              Hora_Prog = Hora_Maxima(addr+10);
2331   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
2332   3            }
2333   2            else
2334   2            {
2335   3              send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2336   3              PantallaLCD(MENSUAL_FUERA_HORARIO);
2337   3              Estado_Horario = False;
2338   3            }
2339   2        }
2340   1      
2341   1      return Estado_Horario;
2342   1      }
2343          
2344          /*------------------------------------------------------------------------------
2345          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
2346          
2347          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
2348          ------------------------------------------------------------------------------*/
2349          
2350          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 40  

2351          unsigned char  Secuencia_inicio_expedidor(void)
2352          {
2353   1        char temp;
2354   1        switch (Estado)
2355   1        {
2356   2          case INICIA_LINTECH:
2357   2      
2358   2                
2359   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
2360   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
2361   2              
2362   2            
2363   2            return (Estado);
2364   2          break;
2365   2      
2366   2      
2367   2      /*------------------------------------------------------------------------------
2368   2      Envia la primera trama de inicializacion del transporte sin movimiento
2369   2            (0) LA RESPUESTA ES OK
2370   2            (1) NO RESPONDE EL PTO SERIE
2371   2            (2) NO RECIBIDO LA TRAMA 
2372   2            (3) ERROR DE TRAMA CMD (N)
2373   2      ------------------------------------------------------------------------------*/
2374   2            
2375   2          case SEQ_CAPTURE_DATOS_INI:
2376   2      
2377   2            if((temp=Trama_Validacion_P_N())!=0)
2378   2          {
2379   3            if(temp==2)
2380   3            {
2381   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
2382   4            } 
2383   3            else if (temp==3)
2384   3            {
2385   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
2386   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2387   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2388   4            }
2389   3            else
2390   3            {
2391   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2392   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
2393   4            }
2394   3          }
2395   2          else
2396   2          {
2397   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
2398   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2399   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
2400   3          }     
2401   2          return (Estado);
2402   2          break;
2403   2            
2404   2      /*------------------------------------------------------------------------------
2405   2      Envia el cmd de grabar claves a la eeprom del transporte 
2406   2      ------------------------------------------------------------------------------*/
2407   2            
2408   2            case GRABA_EEPROM:
2409   2              
2410   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
2411   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 41  

             -e
2412   2            
2413   2            
2414   2      
2415   2            return (Estado);
2416   2              break;
2417   2        
2418   2      /*------------------------------------------------------------------------------
2419   2      se analiza la respuesta 
2420   2            (0) LA RESPUESTA ES OK
2421   2            (1) NO RESPONDE EL PTO SERIE
2422   2            (2) NO RECIBIDO LA TRAMA 
2423   2            (3) ERROR DE TRAMA CMD (N)
2424   2      ------------------------------------------------------------------------------*/
2425   2            
2426   2          case SEQ_CAPTURA_OK_EEPROM:
2427   2          
2428   2          if((temp=Trama_Validacion_P_N())!=0)
2429   2          {
2430   3            if(temp==2)
2431   3            {
2432   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
2433   4            }
2434   3            else if (temp==3)
2435   3            {
2436   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
2437   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2438   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2439   4            }     
2440   3            else
2441   3            {
2442   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2443   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
2444   4            }       
2445   3          }
2446   2          else
2447   2          {
2448   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
2449   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2450   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
2451   3          }     
2452   2      
2453   2          return (Estado);
2454   2          break;
2455   2      
2456   2      /*------------------------------------------------------------------------------
2457   2      Fin de la secuencia de comandos con exito 
2458   2      ------------------------------------------------------------------------------*/    
2459   2            
2460   2              case FIN_OK:
2461   2      
2462   2              return (Estado);
2463   2          break;
2464   2            
2465   2                
2466   2              default:
2467   2              return Estado=INICIA_LINTECH; 
2468   2              break;
2469   2        }
2470   1      }
2471          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 42  

2472          /*------------------------------------------------------------------------------
2473          Prosedimiento  q hace paso a paso la secuencia de la MF
2474          atributos
2475          ValTimeOutCom = tiempo que  espera para recibir datos pto serie
2476          Tarjeta_on = detecto vehiculo en loop y tiene tarjeta en boca
2477          g_cEstadoComSeqMF = nos dice en el estado que nos encontramos dentro del seguimiento
2478          ------------------------------------------------------------------------------*/
2479          
2480          unsigned char SecuenciaExpedidorMF( unsigned char EstadoActivo)
2481          {
2482   1        static unsigned char Buffer_Write_MF[17];
2483   1        static unsigned char Atributos_Expedidor[20];
2484   1        static unsigned char Secuencia_Expedidor[4];
2485   1        static unsigned char Nombre_Mensual[17];
2486   1        
2487   1        
2488   1        
2489   1        switch (EstadoActivo)
2490   1        {
2491   2      //***********************************************************************************************
2492   2          
2493   2          case SEQ_INICIO:
2494   2      
2495   2            if ((buffer_ready == True)|| (ValTimeOutCom > TIME_PULSADOR ))        /*TIME_CARD*/
2496   2            {
2497   3              
2498   3              
2499   3              lock=OFF;                                                                                   /*rele de disparo a la barrera*/
2500   3              Atascado_GP0_PIN_3 = OFF;                                                                          /*activo el rele de reset del verificad
             -or logica negativa*/    
2501   3              Check_Status(SENSOR_NORMAL);                                                              /* se pregunta al transporte en q estado es
             -tan las TI*/
2502   3              EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_
             -TRANSPORTE);
2503   3              Secuencia_Expedidor [ TareadelCmd  ] = TAREA_PRESENCIA_VEHICULAR;
2504   3            }else
2505   2              {
2506   3              if (rx_ip==False)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
2507   3                {
2508   4                 Rx_Monitor();
2509   4                }
2510   3              }
2511   2            
2512   2            break;
2513   2          case  SEQ_CMD_ACEPTADO:
2514   2          /*cmd comun para todos*/
2515   2            EstadoActivo=rta_cmd_transporte(Secuencia_Expedidor);
2516   2            break;
2517   2          case SEQ_MOVER_CARD_RF:
2518   2            Mov_Card(MovPos_RF);
2519   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_TIPO_CARD);
2520   2            break;
2521   2          case SEQ_CARD_INSERCION_ON:
2522   2            Card_Insercion(Habilita); 
2523   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2524   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_MENSUAL;
2525   2            break;
2526   2          case SEQ_TIPO_CARD:
2527   2            Aut_Card_check_Status();
2528   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 43  

2529   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_TARJETA;
2530   2            break;
2531   2          case SEQ_LOAD_PASSWORD:
2532   2            LoadVerify_EEprom();
2533   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECTOR
             -_BLOQUE);
2534   2            Atributos_Expedidor [ Sector ]    = Sector_1;
2535   2            Atributos_Expedidor [ Bloque ]    = Bloque_1;
2536   2            break;
2537   2          case SEQ_READ_SECTOR_BLOQUE:
2538   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
2539   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2540   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
2541   2            break;
2542   2          case SEQ_WRITE_SECTOR_BLOQUE:
2543   2            WR_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ],Buffer_Write_MF);
2544   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2545   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_WRITE_TARJETA_SECTOR_BLOQUE;
2546   2            break;
2547   2          case SEQ_CAPTURE_CARD:
2548   2            Mov_Card(MovPos_Capture);
2549   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);     
             -//SEQ_INICIOSEQ_MOVER_CARD_RF
2550   2            break;
2551   2          case SEQ_CARD_INSERCION_OFF:
2552   2            Card_Insercion(Inhabilita);
2553   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_EXPULSAR_CA
             -RD);
2554   2            break;
2555   2          case SEQ_EXPULSAR_CARD:
2556   2            Mov_Card(MovPos_Front);
2557   2            MenSual = False;
2558   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);    
2559   2            break;
2560   2          case SEQ_FRONT_CARD:
2561   2            Mov_Card(MovPos_Front);
2562   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_DETAIL_CAR
             -D);    
2563   2            break;
2564   2          case SEQ_DETAIL_CARD:
2565   2            if ((buffer_ready ==True)|| (ValTimeOutCom > TIME_PULSADOR))
2566   2            {
2567   3            Check_Status(SENSOR_DETAIL);    
2568   3            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);    
2569   3            Secuencia_Expedidor[TareadelCmd ] = TAREA_OPEN_BARRERA;
2570   3            }
2571   2            break;
2572   2          case SEQ_DETAIL_CARD_TRAMPA:
2573   2            if ((buffer_ready == True)|| (ValTimeOutCom > TIME_WAIT))
2574   2            {
2575   3            Check_Status(SENSOR_DETAIL);    
2576   3            EstadoActivo=Analiza_card_mount_rf();   
2577   3            }
2578   2            break;
2579   2          case SEQ_LOAD_EEPROM:
2580   2            Dwload_EEprom();
2581   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECT
             -OR_BLOQUE);  
2582   2            break;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 44  

2583   2          case SEQ_ESPERA_VEHICULO_ENTRE:
2584   2            MenSual = False;
2585   2            EstadoActivo = Entrega_Card_Captura();
2586   2            break;
2587   2          case SEQ_PTO_PARALELO:
2588   2            EstadoActivo = Send_Pto_Paralelo(Atributos_Expedidor);
2589   2            break;
2590   2          case SEQ_WAIT_PLACA:
2591   2            EstadoActivo = Wait_Placa(Atributos_Expedidor,Buffer_Write_MF); //Secuencia_Expedidor,EstadoActivo
2592   2            break;
2593   2          case SEQ_UID: 
2594   2            Unique_Identifier_UID();
2595   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);    
2596   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_UID ;
2597   2            break;
2598   2          case SEQ_LPR:
2599   2            EstadoActivo = Pregunta_Lpr(Atributos_Expedidor);
2600   2            break;
2601   2          case SEQ_PLACA:
2602   2            pto_paraleo=True;
2603   2            EstadoActivo = Pregunta_Placa ();
2604   2            break;
2605   2          case SEQ_TIPO_TARJETAS:
2606   2            EstadoActivo = Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);;
2607   2            break;
2608   2          case SEQ_CAPTURE_CARD_LOOP:
2609   2            
2610   2            
2611   2              Mov_Card(MovPos_Capture);
2612   2              EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUEST
             -A_TRANSPORTE);     //SEQ_INICIOSEQ_MOVER_CARD_RF TAREA_PRESENCIA_ROTACION
2613   2              Secuencia_Expedidor[TareadelCmd ] = TAREA_PRESENCIA_ROTACION;
2614   2            
2615   2            break;
2616   2          case SEQ_POWER_OFF:
2617   2            Power_off();
2618   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_UID);
2619   2            break;
2620   2          case SEQ_POWER_ON:
2621   2            Power_off();
2622   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_LOAD_PASS
             -WORD);
2623   2            break;
2624   2          case SEQ_SECOND_PASSWORD:
2625   2            Clave_Seguridad_S2();
2626   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);
2627   2            Secuencia_Expedidor [TareadelCmd]  = TAREA_WRITE_PLACA_CARD;
2628   2            break;
2629   2          case SEQ_REELER_CARD_SECTOR1_BLOQUE1:
2630   2            
2631   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
2632   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2633   2            EstadoActivo = Responde_ReeLectura_Tarjeta_Sector1_Bloque2(Buffer_Write_MF,Atributos_Expedidor);
2634   2            break;
2635   2      /*------------------------------------------------------------------------------
2636   2          Tareas especificas de cada paso
2637   2      ------------------------------------------------------------------------------*/      
2638   2          case SEQ_RESPUESTA_TRANSPORTE:
2639   2            ValTimeOutCom=TIME_WAIT;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 45  

2640   2            if (Secuencia_Expedidor [TareadelCmd]==TAREA_PRESENCIA_VEHICULAR)
2641   2            {
2642   3            EstadoActivo=Responde_Estado_Sensores_Transporte(); 
2643   3              ValTimeOutCom=TIME_PULSADOR;
2644   3            
2645   3            }
2646   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_TIPO_TARJETA)
2647   2                {
2648   3                  
2649   3                  EstadoActivo=Responde_Tipo_Tarjeta();
2650   3                }
2651   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_LECTURA_TARJETA_SECTOR_BLOQUE)
2652   2                {
2653   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2654   3                  {
2655   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque1 (Atributos_Expedidor);
2656   4                  }
2657   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2658   3                  {
2659   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque0 (Nombre_Mensual);
2660   4                  }
2661   3                  else
2662   3                  {
2663   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque2(Atributos_Expedidor);
2664   4                  }
2665   3                }
2666   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_WRITE_TARJETA_SECTOR_BLOQUE)
2667   2                { 
2668   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_2))
2669   3                  { 
2670   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor,Buffer_Write_MF);
2671   4                  }
2672   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_2)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2673   3                  {
2674   4                    EstadoActivo=Responde_Write_Tarjeta_Sector2_Bloque0(Buffer_Write_MF);
2675   4                  }
2676   3                    else if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2677   3                  {
2678   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque1(Buffer_Write_MF);
2679   4                  }
2680   3                  else
2681   3                  {
2682   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque0 (Buffer_Write_MF);
2683   4                  }
2684   3                }
2685   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_OPEN_BARRERA)
2686   2                {   
2687   3                  EstadoActivo = Disparo_Lock_Entrada_Vehiculo(Nombre_Mensual);
2688   3                }
2689   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_WRITE_PLACA_CARD)
2690   2                {   
2691   3                  EstadoActivo = Respuesta_Segunda_clave(Atributos_Expedidor,Buffer_Write_MF);
2692   3                }
2693   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_TIPO_MENSUAL) 
2694   2                {
2695   3                  EstadoActivo = Analiza_Presencia_Mensual();
2696   3                }
2697   2                
2698   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_UID ) 
2699   2                {
2700   3                  EstadoActivo = Analiza_Uid_Card(Atributos_Expedidor);
2701   3                } 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       07/30/2021 10:52:53 PAGE 46  

2702   2      
2703   2      
2704   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_PRESENCIA_ROTACION  ) 
2705   2                {
2706   3                  EstadoActivo = Analiza_Presencia_rotacion();
2707   3                }   
2708   2            else
2709   2                {
2710   3                  Debug_txt_Tibbo((unsigned char *) "TAREA_3\r\n");
2711   3                }
2712   2            break;
2713   2          default:
2714   2          EstadoActivo = SEQ_INICIO;  
2715   2          break;  
2716   2            
2717   2        } 
2718   1        return EstadoActivo;
2719   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   9382    ----
   CONSTANT SIZE    =   2268    ----
   XDATA SIZE       =    145     273
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
