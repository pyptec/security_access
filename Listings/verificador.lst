C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          
  12          
  13          extern void send_portERR(unsigned char cod_err);
  14          
  15          extern char check_fechaOut(char *buffer);
  16          
  17          
  18          extern void PantallaLCD(unsigned char cod_msg);
  19          //extern void Trama_pto_Paralelo_C_s(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  20          extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  21          //extern void Trama_pto_Paralelo(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd
             -);
  22          //extern void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char c
             -md);
  23          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  24          //extern void Trama_pto_Paralelo_new(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char
             - cmd);
  25          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  26          
  27          extern void Cmd_Lpr_Int();
  28          extern void Delay_10ms(unsigned int cnt);
  29          /*funciones prototipo string */
  30          extern char  *strcat  (char *s1, const char *s2);
  31          extern char  *strcpy  (char *s1, const char *s2);
  32          extern unsigned int strlen  (const char *);
  33          /*funciones prototipo de EEprom*/
  34          extern unsigned char *Lee_No_Ticket();
  35          void Incremente_Ticket();
  36          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  37          /*funciones prototipo del transporte MODULO io_sensores*/
  38          extern unsigned char  ValidaSensoresPaso(void);
  39          extern unsigned char Dir_board();
  40          extern void sel_Pulsa(void);
  41          /*funciones prototipo del transporte MODULO TIBBO*/
  42          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  43          extern void Debug_txt_Tibbo(unsigned char * str);
  44          extern void Debug_chr_Tibbo(unsigned char Dat);
  45          extern void Debug_HexDec(unsigned char xfc);
  46          /*funciones prototipo del transporte MODULO LINTECH*/
  47          extern void Aut_Card_check_Status(void);
  48          extern void Check_Status(unsigned char Detalle);
  49          extern void Dwload_EEprom (void);
  50          extern void Mov_Card(unsigned char Posicion);
  51          extern void Card_Insercion(char Tipo);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 2   

  52          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  53          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);  
  54          extern void LoadVerify_EEprom(void);
  55          /*funcion prototipo pto paralelo*/
  56          void  send_port(unsigned char *buffer_port, unsigned char length_char);
  57          /*io sensores */
  58          
  59          sbit DataIn = P1^1;         //  dato de las entradas    
  60          sbit sel_A = P3^5;          //Pulsador                        *
  61          sbit sel_B = P3^6;          //Entrada Sensor 2                    *
  62          sbit sel_C = P3^7;          //Entrada Sensor 1                    *
  63          
  64          sbit lock = P1^7;           //Relevo  
  65          sbit Rele_Atasco = P0^3;        //Rele de on/off del verificador o transporte
  66          sbit led_err_imp = P0^2;      //Error   
  67          /*variables externas*/
  68          
  69          extern unsigned char g_cEstadoComSoft;
  70          extern unsigned char ValTimeOutCom;
  71          extern unsigned char g_cContByteRx;
  72          extern unsigned char xdata Buffer_Rta_Lintech[];
  73          extern int ID_CLIENTE;
  74          extern int COD_PARK;
  75          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
  76          extern unsigned char Timer_wait;
  77          extern unsigned int  SIN_COBRO;
  78          extern unsigned char  Tarjeta_on;
  79          extern unsigned char cnt__ask_off;
  80          extern  unsigned char Tipo_Vehiculo;
  81                                                              /*variable q define expedicion de tarjetas 1= automatico 0= a boton configurable
             - en eeprom*/
  82          /*externo bit*/
  83          
  84          extern bit aSk;
  85          extern bit buffer_ready;
  86          extern unsigned char USE_LPR;
  87          
  88          /*----------------------------------------------------------------------------
  89          Definiciones de sequencias de verificador y expedidor
  90          ------------------------------------------------------------------------------*/
  91          
  92          #define SEQ_INICIO                      0X00  
  93          #define SEQ_RESPUESTA_TRANSPORTE        0X01
  94          #define SEQ_CMD_ACEPTADO                0x02
  95          #define SEQ_MOVER_CARD_RF               0x03
  96          #define SEQ_CARD_INSERCION_ON           0x04
  97          #define SEQ_TIPO_CARD                   0X05
  98          #define SEQ_LOAD_PASSWORD               0X06
  99          #define SEQ_READ_SECTOR_BLOQUE          0X07
 100          #define SEQ_WRITE_SECTOR_BLOQUE         0X08
 101          #define SEQ_CAPTURE_CARD                0X09
 102          #define SEQ_CARD_INSERCION_OFF          0x0a
 103          #define SEQ_EXPULSAR_CARD               0x0b
 104          #define SEQ_LOAD_EEPROM                 0x0c
 105          
 106          /*----------------------------------------------------------------------------
 107          Definiciones de sequencias de tareas del verificador y expedidor
 108          ------------------------------------------------------------------------------*/
 109          #define TAREA_PRESENCIA_VEHICULAR             0X00  
 110          #define TAREA_TIPO_TARJETA                    0X01
 111          #define TAREA_LECTURA_TARJETA_SECTOR_BLOQUE   0x02
 112          #define TAREA_WRITE_TARJETA_SECTOR_BLOQUE     0X03
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 3   

 113          #define TAREA_OPEN_BARRERA                    0X04
 114          
 115          /*NO USADOS EN EL MOMENTO*/
 116          
 117          //#define SEQ_RTA_CARD_POS1     0x19  /*no usada temporal tomar decision de borrar*/
 118          //#define SEQ_CHECK_STATUS      0X13
 119          
 120          //#define SEQ_REQUEST           0x15
 121          //#define SEQ_RD_S1B0           0x16
 122          //#define SEQ_RD_S1B0_EJECT     0x17
 123          //#define SEQ_CARD_INSERCION    0X18
 124          
 125          //#define SEQ_EXPULSAR_TARJ     0x20
 126          //#define SEQ_EXPULSAR_CHECK    0x21
 127          //#define SEQ_EXPULSAR          0x22
 128          //#define SEQ_EXPULSAR_FROM     0x23
 129          
 130          /*----------------------------------------------------------------------------
 131           definiciones de lintech en la inicializacion de expedidor o verificador
 132          ------------------------------------------------------------------------------*/
 133          
 134          #define INICIA_LINTECH          0x30
 135          #define SEQ_CAPTURE_DATOS_INI   0x31
 136          #define GRABA_EEPROM            0x32
 137          #define SEQ_CAPTURA_OK_EEPROM   0X33
 138          #define FIN_OK                  0x00
 139          
 140          
 141          #define True                    0x01
 142          #define False                   0x00
 143          /*----------------------------------------------------------------------------
 144           Definicion de datos asociados al buffer de resetcion del dato del trnasporte 
 145          
 146          ------------------------------------------------------------------------------*/
 147          
 148          
 149          #define ON    1
 150          #define OFF   0
 151          /*----------------------------------------------------------------------------
 152           ERRORES pto serie 
 153          
 154          ------------------------------------------------------------------------------*/
 155          #define REENVIA_TRAMA     0
 156          #define ESPERA_MAS_TIEMPO 1
 157          /*----------------------------------------------------------------------------
 158           definiciones de lintech en la inicializacion de expedidor o verificador
 159           funcion usada en lintech que me debuelve la respuesta de comunicacion del expedidor
 160           o verificador Trama_Validacion_P_N()
 161          RSPT_TRP_OK             (0) respuesta_transporte_oksignifica que la trama es valida y continua en el proceso
 162          NO_RSPD_TRP_PTO_COM     (1) no_responde_trasnporte_pto_com se cumple el tiempo de espera
 163          ESPR_RSPT_TRP_TRAMA     (2)Espera_respuesta_transporte_trama
 164          ERROR_TRP_TRAMA         (3) error_transpote_trama
 165          ------------------------------------------------------------------------------*/
 166          #define   RSPT_TRP_OK           0
 167          #define   NO_RSPD_TRP_PTO_COM   1
 168          #define   ESPR_RSPT_TRP_TRAMA   2
 169          #define   ERROR_TRP_TRAMA       3
 170          
 171          
 172          /*----------------------------------------------------------------------------
 173           definiciones de lintech en el comando Check_Status
 174          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 4   

 175          
 176          #define SENSOR_DETAIL       0x31
 177          #define SENSOR_NORMAL       0x30
 178          
 179          /*------------------------------------------------------------------------------
 180           definiciones de lintech en el comando Card_Insercion
 181          ------------------------------------------------------------------------------*/
 182          
 183          #define Habilita        0x30
 184          #define Inhabilita      0x31
 185          
 186          /*------------------------------------------------------------------------------
 187          Definicion de Lintech en el comando Inicializa
 188          ------------------------------------------------------------------------------*/
 189          
 190          #define TO_FRONT        '0'
 191          #define CAPTURE_BOX     '1'
 192          #define SIN_MOVIMIENTO  '3'
 193          
 194          /*------------------------------------------------------------------------------
 195          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 196          MovPos_Front        '0'   -> mueve  tarjeta al frente pero no la suelta
 197          MovPos_IC           '1'   ->mueve la tarjeta en posicion de read/write IC
 198          MovPos_RF           '2'   ->mueve tarjeta a RF card read/write
 199          MovPos_Capture      '3'   ->captura la tarjeta
 200          MovPos_EjectFront   '9'   ->lanza la tarjeta del mecanismo
 201          
 202          ------------------------------------------------------------------------------*/
 203          
 204          #define   MovPos_Front        '0'   
 205          #define   MovPos_IC           '1'
 206          #define   MovPos_RF           '2'
 207          #define   MovPos_Capture      '3'
 208          #define   MovPos_EjectFront   '9'
 209          
 210          /*------------------------------------------------------------------------------
 211          Definicion de la trama Lintech de las respuestas de los cmd
 212          ------------------------------------------------------------------------------*/
 213          
 214          #define Pos_Length          3
 215          #define Pos_TipoResp        4
 216          #define Pos_St0             7
 217          #define Pos_St1             8
 218          #define Pos_St2             9
 219          #define Pos_IniDatMF        0x0a
 220          #define Card_type_H         0x0a
 221          #define Card_type_L         0x0b
 222          /*------------------------------------------------------------------------------
 223          Definicion del estado de st0,st1,st2 de la trama Lintech 
 224          NO_CARDS_IN_MCNSM -> No tiene tarjetas en el mecanismo      sto=0
 225          CARD_IN_MOUTH     -> hay una tarjeta dentro del bessel      st0=1
 226          CARD_OK_READ_RF   -> Tarjeta en posicion para leer/escribir dentro del mecanismo st0=2
 227          NO_HAVE_CARDS     -> no tiene tarjetas en el deposito st1=0
 228          LOW_NIVEL_CARDS   -> nivel bajo de tarjetas en el deposito  st1=1
 229          FULL_CARD         -> Deposito de tarjetas esta lleno        st1=2
 230          ------------------------------------------------------------------------------*/
 231          
 232          
 233          #define NO_CARDS_IN_MCNSM   '0'
 234          #define CARD_IN_MOUTH       '1'
 235          #define CARD_OK_READ_RF     '2'
 236          #define NO_HAVE_CARDS       '0'
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 5   

 237          #define LOW_NIVEL_CARDS     '1'
 238          #define FULL_CARD           '2'
 239          /*----------------------------------------------------------------------------
 240          Comprobacion automatica del tipo de tarjeta 
 241          checking RF card type
 242          Card_type_H   Card_type_L  explicacion
 243              0             0           tarjeta desconocida
 244              1             0           MF50
 245              1             1           MF70
 246              1             2           MF_UL
 247              2             0           TYPE_A_CPU
 248          ------------------------------------------------------------------------------*/
 249          #define MF50_HIGH             '1'
 250          #define MF50_LOW              '0'
 251          
 252          /*----------------------------------------------------------------------------
 253          definicion de recepcion serial 
 254          ------------------------------------------------------------------------------*/
 255          
 256          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 257          
 258          /*----------------------------------------------------------------------------
 259          tiempo de delay entre funciones
 260          ------------------------------------------------------------------------------*/
 261          
 262          #define   TIME_CARD         100   //50
 263          
 264          
 265          /*----------------------------------------------------------------------------
 266          definicion de datos de trama lintech
 267          ------------------------------------------------------------------------------*/
 268          
 269          //#define   ETX               03
 270          #define   STX_LINTECH       0xf2
 271          
 272          /*----------------------------------------------------------------------------
 273          msj de lcd tarjeta y lcd serie
 274          ------------------------------------------------------------------------------*/
 275          
 276          #define ERROR_LOOP              0XE0
 277          #define TARJETA_INVALIDA        0XE1
 278          #define TARJETA_SIN_FORMATO     0xDF
 279          #define ERROR_COD_PARK          0XE5
 280          #define SIN_INGRESO             0XE6
 281          #define SIN_PAGO                0XE7
 282          #define EXCEDE_GRACIA           0XE8
 283          #define GRACIAS                 0XFF
 284          
 285          #define NO_CARD                 0xfa  
 286          #define LOW_CARD                0x01
 287          #define ATASCADO                0x02
 288          #define AUDIO_ENTRADA     0XA0
 289          #define AUDIO_CAJA        0XA1
 290          #define AUDIO_GRACIAS     0XA2
 291          /*----------------------------------------------------------------------------
 292          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 293          ------------------------------------------------------------------------------*/
 294          
 295          #define   ENVIADOS          0X0
 296          #define   RESPUESTA         0X01
 297          
 298          /*----------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 6   

 299          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 300          (0) si el dato es cero esta inactiva
 301          (1) activa o ROTACION
 302          (2) mensualidad
 303          ------------------------------------------------------------------------------*/
 304          enum Tipos_MF_TIPO_TARJETA{
 305            INACTIVA,         
 306            ROTACION,           
 307            MENSUALIDAD       
 308          };
 309          /*----------------------------------------------------------------------------
 310          posicion de  MF  bloque 1 sector 1
 311          (0) tipo de tarjeta 
 312          (01) el id del cliente
 313          (03)codigo del parqueadero  
 314          ------------------------------------------------------------------------------*/
 315          #define   MF_TIPO_TARJETA   0X00
 316          #define   MF_ID_CLIENTE     0x01
 317          #define   MF_COD_PARK       0x03
 318          
 319          /*----------------------------------------------------------------------------
 320          posicion de  MF bloque 2 sector 1
 321          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 322          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 323          ------------------------------------------------------------------------------*/
 324          
 325          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 326          
 327          
 328          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 329                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
 330          #define   MF_LSB            0x06
 331          
 332          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 333          
 334          #define   MF_IN_PAGO        0x09
 335          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 336          
 337          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 338          enum Estados_Expedidor{
 339           EstadoActual,
 340           EstadoPasado,
 341           EstadoFuturo,
 342           TareadelCmd  
 343          };
 344          enum expedidor {
 345           Sector,        
 346           Bloque,        
 347           Tipo_Tarjeta,  
 348           Apb,
 349           
 350          };
 351          /*tipos de APB antipassback*/
 352          enum Tipos_MF_APB{
 353            
 354            APB_INICIADO,       
 355            APB_INT,              
 356            APB_OUT,              
 357            APB_NO              
 358          };
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 7   

 359          /*tipo de vehiculo*/
 360          /*Sectores y bloques de Mf*/
 361          enum MF_Sector_Bloque{
 362            Sector_0,
 363            Sector_1,
 364            Bloque_0 = 0,
 365            Bloque_1 = 1,
 366            Bloque_2 = 2
 367          };
 368          /*comandos pto paralelo*/
 369          enum CMD_Trama_Pto_Paralelo{
 370            STX=02,
 371            CMD_PTO_PARALELO_EXPEDIDOR='a',
 372            ETX= 03,
 373            NULL=0
 374          };
 375          enum EE_AntiPassBack{
 376            APB_INHABILITADO_SOFT
 377          };  
 378          
 379          #define AUTOMOVIL           0X00
 380          #define MOTO                0X01
 381          
 382          /*DATOS DE CONFIGURACION EEPROM*/
 383          #define EE_USE_LPR              0x000A
 384          #define EE_CARD_AUTOMATIC_BOTON 0x000f
 385          #define EE_HABILITA_APB         0x0010
 386          /*----------------------------------------------------------------------------
 387          Definicion de varaibles globales del objeto
 388          ------------------------------------------------------------------------------*/
 389          
 390          static unsigned char Estado=INICIA_LINTECH;
 391          
 392          
 393          
 394          /*------------------------------------------------------------------------------
 395          funcion que valida la trama del verificador o transporte lintech
 396          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 397          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 398          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 399          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 400          
 401          
 402          ------------------------------------------------------------------------------*/
 403          
 404          char Trama_Validacion_P_N()
 405          {
 406   1        char Trama_Validacion_P_N=ESPR_RSPT_TRP_TRAMA;                                /*espera respuesta del transporte*/
 407   1        
 408   1            if ((ValTimeOutCom==1)||(buffer_ready==1))
 409   1            {
 410   2              if (buffer_ready==1)
 411   2              {
 412   3                buffer_ready=0;
 413   3                  
 414   3              
 415   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 416   3                {
 417   4                          
 418   4                  Trama_Validacion_P_N=RSPT_TRP_OK;                                       /*trama ok*/
 419   4                    
 420   4                }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 8   

 421   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 422   3                {
 423   4                  
 424   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;                                 /*error de trama*/
 425   4                  
 426   4                }
 427   3                else
 428   3                {
 429   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
 430   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;   
 431   4                  
 432   4                }
 433   3              }
 434   2              else
 435   2              {
 436   3                          
 437   3                Trama_Validacion_P_N=NO_RSPD_TRP_PTO_COM;                                 /*pto serie no responde */
 438   3                                                  
 439   3              }
 440   2      
 441   2            }
 442   1            
 443   1        return Trama_Validacion_P_N;
 444   1      }
 445          /*------------------------------------------------------------------------------
 446          funcion de error de respuesta pto serie
 447          
 448          variable en uart. cnt__ask_off=cuenta los numeros de error pto serie y reset de transporte 
 449          se limpia cuando llega la respuesta del transporte. 
 450          Rele_Atasco = es un I/O del Mc que activa / inhabilita el rele
 451          ON    (1) esta activo 
 452          OFF   (0) inhactivo 
 453          REENVIA_TRAMA   1
 454          ESPERA_MAS_TIEMPO 0
 455          cnt_espera_ask_on= cuenta el tiempo de ASK que esta activo,sin que le llegue
 456                             la trama completa, al  5 tiempos borra el ask y retrasmite el cmd
 457          
 458          error_rx_pto= (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 459                      = (1)= REENVIA_TRAMA reenvia la trama al transporte
 460          
 461          cnt__ask_off= varible global esta definida en pto serie y es un contador , que 
 462          se limpia cada vez que la trama a llegado completa y validada
 463          
 464          aSk= significa que llego al pto serie el 06 = ask donde el transporte dice que a recibido el cmd
 465          esta ejecutando y nos enviara la respuesta,necesita tiempo esta bit esta definino en el modulo uart es glo
             -bal
 466          
 467          ------------------------------------------------------------------------------*/
 468          unsigned char error_rx_pto(void)
 469          {
 470   1      
 471   1      static unsigned cnt_espera_ask_on=0;
 472   1      unsigned char error_rx_pto=ESPERA_MAS_TIEMPO;
 473   1      
 474   1          
 475   1                
 476   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 477   1            Debug_chr_Tibbo (cnt__ask_off); 
 478   1            Debug_chr_Tibbo (cnt_espera_ask_on);
 479   1            Debug_chr_Tibbo (error_rx_pto);
 480   1            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 9   

 481   1            if (aSk==OFF)
 482   1            
 483   1            { 
 484   2                cnt__ask_off++;                                                                   /*cuento el error*/                                                               
 485   2              if(cnt__ask_off>=10)
 486   2              {                                                                                   /*no contesta debe reset el transporte*/
 487   3                Rele_Atasco=ON;                                                                   /*off el rele de reset del verificador*/    
 488   3                Delay_10ms(110);
 489   3                cnt__ask_off=0;                                                                   /*limpio ls errores*/
 490   3                cnt_espera_ask_on=0;
 491   3                error_rx_pto=ESPERA_MAS_TIEMPO;                                                   /**/
 492   3                Rele_Atasco=OFF;  
 493   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 494   3                ValTimeOutCom=TIME_CARD;
 495   3              }
 496   2              else;
 497   2              {
 498   3                error_rx_pto=REENVIA_TRAMA;                                                       /*1 reenvia trama*/
 499   3                ValTimeOutCom=TIME_CARD;
 500   3              }
 501   2            }                                                                                     /*aSk esta activo */
 502   1            else
 503   1            {
 504   2                cnt_espera_ask_on++;                                                              /*cuento n tiempos de ask para recibir el total de
             - la trama*/
 505   2              if(cnt_espera_ask_on>=3)
 506   2              {
 507   3                cnt__ask_off=0;                                                                   /*paso tiempo de espera y no se completo la trama 
 508   3                                                                                                  limpio los reg y reenvio la trama y ask=off*/
 509   3                cnt_espera_ask_on=0;
 510   3                error_rx_pto=REENVIA_TRAMA;
 511   3                aSk=OFF;
 512   3                ValTimeOutCom=TIME_CARD;
 513   3              }
 514   2              else
 515   2              {
 516   3                cnt__ask_off=0;                                                                   /*damos tiempo de espera de la trama del transporte*
             -/
 517   3                error_rx_pto=ESPERA_MAS_TIEMPO;;
 518   3                ValTimeOutCom=TIME_CARD;
 519   3              }
 520   2            }
 521   1              return (error_rx_pto);
 522   1      }
 523          /*------------------------------------------------------------------------------
 524          Funcion de respuesta a los cmd del transporte
 525          Retorna rta_cmd_transporte el estado en que queda
 526          Recibe tres datos unos es el 
 527          Estado_futuro= significa que la respuesta fue ok
 528          Estado_Error= en caso de que aya un error a que estado envia el codigo
 529          Estado_Actua= No ha llegado la respuesta y sigue en el mismo estado
 530          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 531          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 532          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 533          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 534          
 535          (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 536          (1)= REENVIA_TRAMA reenvia la trama al transporte
 537          ------------------------------------------------------------------------------*/
 538          unsigned char   rta_cmd_transporte(unsigned char Estado_futuro, unsigned char Estado_Error, unsigned Estad
             -o_Actual)
 539          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 10  

 540   1        unsigned char temp;
 541   1        unsigned char EstadoComSeqMF;
 542   1        
 543   1            
 544   1      if((temp=Trama_Validacion_P_N())!=RSPT_TRP_OK )
 545   1          {
 546   2            if(temp==ESPR_RSPT_TRP_TRAMA)                                                         /*no he recibido respuesta espero*/
 547   2            {
 548   3            EstadoComSeqMF=Estado_Actual;                                                     /*SEQ_RTA_CARD_POSno ha respondido*/
 549   3            } 
 550   2            else if (temp==ERROR_TRP_TRAMA)
 551   2            {
 552   3            Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR\r\n\r\n");                     /* trama no valida respuesta inco
             -rrecta falla en la escritura */
 553   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 554   3            EstadoComSeqMF=Estado_Error;                                                        /*SEQ_INICIO (3) Trama invalida cmd (N)reenvio 
             -cmd*/  
 555   3            }     
 556   2            else
 557   2            {
 558   3            /*Dispensador No Responde PTO SERIE ...*/
 559   3          
 560   3              if(temp=error_rx_pto()==ESPERA_MAS_TIEMPO)
 561   3              {
 562   4                EstadoComSeqMF=Estado_Actual;
 563   4              }                                                                                     /*SEQ_RTA_CARD_POS;*/
 564   3              else                                                                                  //(temp=error_rx_pto()==REENVIA_TRAMA)
 565   3              {
 566   4                EstadoComSeqMF=Estado_Error;                                                    /*SEQ_INICIO*/
 567   4              }                                                 
 568   3            }       
 569   2          }
 570   1          else
 571   1          {
 572   2            
 573   2            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);
 574   2            EstadoComSeqMF=Estado_futuro;
 575   2          }
 576   1        return EstadoComSeqMF;
 577   1      }
 578          
 579          unsigned char Ingreso_Vehiculo(void)
 580            {
 581   1          unsigned char CardAutomatic;  
 582   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 583   1          {
 584   2            CardAutomatic=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);  
 585   2            
 586   2            if (CardAutomatic==True)                                                    //se pregunta si expide la tarjeta automatica o por p
             -resionar el boton
 587   2              {
 588   3                Debug_txt_Tibbo((unsigned char *) "Tarjeta: Automatico\r\n");               //expide tarjetas automatico con
             - presencia
 589   3                //Mov_Card(MovPos_RF);                                                    // muevo la tarjeta hasta el lector de rf
 590   3                Estado=SEQ_MOVER_CARD_RF;//SEQ_RTA_SEL_STACKER;                                             // valido el cmd enviado al ve
             -rificador
 591   3               }
 592   2               else
 593   2                  {
 594   3                    sel_Pulsa();                                                          //se valida el pulsador en hardware
 595   3                    if (DataIn!=True)       
 596   3                      {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 11  

 597   4                        Debug_txt_Tibbo((unsigned char *) "Pulsador Activo\r\n");             //el pulsador fue presionado
 598   4                        //Mov_Card(MovPos_RF);                                              //muevo tarjeta hasta el lector de RF
 599   4                        Estado=SEQ_MOVER_CARD_RF;//SEQ_RTA_SEL_STACKER;                                       //valido el cmd enviado al ver
             -ificador
 600   4                      }
 601   3                    else
 602   3                        {
 603   4                          Estado=SEQ_RESPUESTA_TRANSPORTE;
 604   4                        }
 605   3                  
 606   3                  } 
 607   2          }
 608   1          else
 609   1              { 
 610   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 611   2                Estado=SEQ_INICIO;  
 612   2              }
 613   1        return Estado;
 614   1      }
 615           
 616          unsigned char Responde_Estado_Sensores_Transporte()
 617          {
 618   1        unsigned char Estado_expedidor;
 619   1            Debug_txt_Tibbo((unsigned char *) "TAREA_PRESENCIA_VEHICULAR\r\n");                         // trama valida Habilit
             -ado 
 620   1            //Debug_txt_Tibbo((unsigned char *) "Respuesta comando Check_Status \r\n"); 
 621   1            //DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            //imprimo la trama recibida
 622   1            if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                   // CANAL LIBRE    no tiene tarjeta
             -s en el mecanismo
 623   1            {
 624   2                
 625   2              if  ((Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS)||(Buffer_Rta_Lintech[Pos_St1]==FULL_CARD  ))  //  se
             - detecta la tarjeta en la boca TARJETA EN BEZZEL
 626   2              {
 627   3                if (Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS  )                                         // nivel de tarjetas
 628   3                  {
 629   4                    Debug_txt_Tibbo((unsigned char *) "Nivel bajo de tarjetas\r\n");        // nivel bajo de tarjetas 
 630   4                    send_portERR(LOW_CARD);                                                     //envio msj al primario
 631   4                    PantallaLCD('a');                                                           //envio msj por la raspberry nivel bajo de tarjetas
 632   4                      Estado_expedidor=Ingreso_Vehiculo();        
 633   4                   }
 634   3                   else
 635   3                      {
 636   4                        /*respuesta ok*/
 637   4                       Estado_expedidor=Ingreso_Vehiculo();
 638   4                      
 639   4                      }
 640   3              } 
 641   2              else 
 642   2                  {
 643   3                    /*dispensador no posee tarjetas*/
 644   3                    Debug_txt_Tibbo((unsigned char *) "Dispensador SIN TARJETAS...\r\n"); 
 645   3                    //msj a tibbo de no card  msj por diseñar 
 646   3                    send_portERR(NO_CARD);                                                      // se envia msj al uC principal, visualiza en el l
             -cd que no hay tarjetas
 647   3                    Estado_expedidor=SEQ_INICIO;                                                //inicio el loop
 648   3                   }
 649   2            }
 650   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                      //  se detecta la tarjeta en la
             - boca TARJETA EN BEZZEL
 651   1                  {
 652   2                    /*hay una tarjeta en la boca del verificador */
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 12  

 653   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                      //se envia msj al debuger q 
             -hay tarjeta en la boca
 654   2                    //Card_Insercion(Habilita);                                                     //se habilita recepcion de tarjetas por boca
 655   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;                                           //se trabaja mensual        
 656   2                  }
 657   1                  else
 658   1                      {
 659   2                        Estado_expedidor=SEQ_INICIO;  
 660   2                      }
 661   1        return Estado_expedidor;  
 662   1      }
 663          
 664          /*------------------------------------------------------------------------------
 665          Funcion que nos dice el tipo de tarjeta que tiene en el mecanismo
 666          Comprobacion automatica del tipo de tarjeta 
 667          checking RF card type
 668          Card_type_H   Card_type_L  explicacion
 669              0             0           tarjeta desconocida
 670              1             0           MF50
 671              1             1           MF70
 672              1             2           MF_UL
 673              2             0           TYPE_A_CPU
 674          
 675          #define MF50_HIGH             '1'
 676          #define MF50_LOW              '0'
 677          ------------------------------------------------------------------------------*/
 678          unsigned char Responde_Tipo_Tarjeta()
 679            {
 680   1          unsigned char Estado_expedidor;
 681   1            Debug_txt_Tibbo((unsigned char *) "TAREA_TIPO DE TARJETA\r\n");                         // trama valida Habilitado 
 682   1            
 683   1        if (Buffer_Rta_Lintech[Card_type_H]==MF50_HIGH)                                                 /* pregunto si la tarjeta en el t
             -ransporte es MF 50 */
 684   1          {
 685   2          if (Buffer_Rta_Lintech[Card_type_L]==MF50_LOW)  
 686   2            {
 687   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n");             /* trama valida son MF50*/
 688   3              Estado_expedidor=SEQ_LOAD_PASSWORD; 
 689   3                                                                                      
 690   3            }
 691   2            else
 692   2              {
 693   3                Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");         /* trama no valida */
 694   3                send_portERR(0xA2);                                                             /*error audio*/ 
 695   3                send_portERR(0XE1);                                                             /*envio msj principal tarjeta invalidad*/
 696   3                PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la raspbe
             -rry*/
 697   3                Estado_expedidor=SEQ_CAPTURE_CARD;                                        
 698   3                                                            
 699   3                         
 700   3              }
 701   2          }
 702   1          else 
 703   1            {
 704   2              Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");           /* trama no valida */
 705   2              send_portERR(0xA2);                                                             /*error audio*/ 
 706   2              send_portERR(0xe1);                                                     //la tarjeta no es valida 
 707   2              PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la raspb
             -erry*/
 708   2              Estado_expedidor=SEQ_CAPTURE_CARD;
 709   2              //g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* capturo la respuesta y regreso a cheq
             -uear verificador*/       
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 13  

 710   2            }
 711   1                    
 712   1          return Estado_expedidor;                                                                                                  /*respuesta ok inicia revisando
             - sensores*/
 713   1        } 
 714          
 715          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
 716          {
 717   1        unsigned char temp;
 718   1        unsigned char Estado_expedidor;
 719   1        unsigned char buffer_S1_B1[17];
 720   1        
 721   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE1\r\n");   
 722   1                                        
 723   1                                      
 724   1            
 725   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 726   1            {
 727   2              
 728   2                for (temp=0; temp<16; ++temp)
 729   2                {
 730   3                  buffer_S1_B1 [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de
             - MF en un arreglo*/
 731   3                 
 732   3                }
 733   2                
 734   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b1\r\n");
 735   2                DebugBufferMF(buffer_S1_B1,16,RESPUESTA);
 736   2                /*Compara  MF_ID_CLIENTE y MF_COD_PARK con el codigo del parqueadero ID_CLIENTE  COD_PARK*/
 737   2                if (((buffer_S1_B1 [ MF_ID_CLIENTE])==ID_CLIENTE)&&((buffer_S1_B1 [ MF_COD_PARK] )==COD_PARK)||((ID_C
             -LIENTE==0)&&(COD_PARK==0)))   
 738   2                {
 739   3                    
 740   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");                // posicion 1
 741   3                  Debug_HexDec((buffer_S1_B1 [ MF_ID_CLIENTE]));
 742   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 743   3                  
 744   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");                   // posicion 3
 745   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
 746   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
 747   3      
 748   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
 749   3                  Debug_chr_Tibbo((buffer_S1_B1 [MF_TIPO_TARJETA]));
 750   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
 751   3                  
 752   3                  *(Atributos_Expedidor + Tipo_Tarjeta)=buffer_S1_B1 [MF_TIPO_TARJETA];
 753   3                  
 754   3                  if  (buffer_S1_B1 [ MF_TIPO_TARJETA]==ROTACION)         
 755   3                  {
 756   4                    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n ");
 757   4                    *(Atributos_Expedidor + Sector) = Sector_1;
 758   4                    *(Atributos_Expedidor + Bloque) = Bloque_2;
 759   4                                                                                      
 760   4                    Estado_expedidor=SEQ_READ_SECTOR_BLOQUE;
 761   4                    
 762   4                  }
 763   3                  else 
 764   3                  {
 765   4                    Debug_txt_Tibbo((unsigned char *) "ERROR TARJETA INVALIDA\r\n");
 766   4                    send_portERR(0xe1);
 767   4                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 14  

 768   4                    Estado_expedidor=SEQ_CAPTURE_CARD;                                              /* expulso la tarjeta */    
 769   4                  }
 770   3                }
 771   2                else
 772   2                {
 773   3                  Debug_txt_Tibbo((unsigned char *) "ERROR COD PARK\r\n");
 774   3                  send_portERR(0XE5);
 775   3                  PantallaLCD(ERROR_COD_PARK);                                                        /*envio el msj por la pantalla lcd o la rasp
             -berry*/
 776   3                  Estado_expedidor=SEQ_CAPTURE_CARD;                                                /* codigo de parqueo erro expulso la tarje
             -ta */    
 777   3                }
 778   2            }
 779   1            else
 780   1            {
 781   2              Debug_txt_Tibbo((unsigned char *) "TARJETA SIN FORMATO\r\n");
 782   2              send_portERR(0XDF);
 783   2              PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la r
             -aspberry*/
 784   2              Estado_expedidor=SEQ_LOAD_EEPROM;
 785   2            }
 786   1            
 787   1        return Estado_expedidor;
 788   1      } 
 789          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor,unsigned char *
             -Buffer_Write_MF)
 790          {
 791   1        unsigned char temp;
 792   1        unsigned char Estado_expedidor;
 793   1        unsigned char buffer_S1_B2[17]; 
 794   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");   
 795   1            
 796   1            Estado_expedidor=SEQ_CAPTURE_CARD;                          
 797   1            
 798   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
 799   1            {
 800   2              
 801   2                for (temp=0; temp<16; ++temp)
 802   2                {
 803   3                  buffer_S1_B2 [temp] =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion d
             -e MF en un arreglo*/
 804   3                }
 805   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b2\r\n");
 806   2                DebugBufferMF(buffer_S1_B2,16,RESPUESTA);
 807   2            
 808   2                Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK:");
 809   2                Debug_chr_Tibbo(buffer_S1_B2 [MF_APB]);
 810   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
 811   2              
 812   2                /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 813   2                *(Atributos_Expedidor + Apb)=   buffer_S1_B2 [MF_APB];
 814   2                
 815   2              
 816   2                if(((buffer_S1_B2 [ MF_APB ])==APB_OUT)||((buffer_S1_B2 [ MF_APB])==APB_INICIADO) || (rd_eeprom(0xa8,
             -EE_HABILITA_APB)==APB_INHABILITADO_SOFT) )                              
 817   2                { 
 818   3                *(Atributos_Expedidor + Sector) = Sector_1;
 819   3                *(Atributos_Expedidor + Bloque) = Bloque_2;
 820   3                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
 821   3                Estado_expedidor=SEQ_WRITE_SECTOR_BLOQUE;
 822   3              
 823   3                }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 15  

 824   2                else if((buffer_S1_B2 [ MF_APB ])==APB_INT)
 825   2                { 
 826   3                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK \r\n");
 827   3                
 828   3                }
 829   2                else
 830   2                {
 831   3                  Debug_txt_Tibbo((unsigned char *) "ERROR: NO ANTIPASSBACK \r\n");
 832   3                }
 833   2        
 834   2            }
 835   1          return Estado_expedidor;  
 836   1      }
 837          unsigned char Responde_Write_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buf
             -fer_Write_MF)
 838          {
 839   1        
 840   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE2\r\n"); 
 841   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b2\r\n");
 842   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
 843   1        
 844   1        *(Atributos_Expedidor + Sector) = Sector_1;
 845   1        *(Atributos_Expedidor + Bloque) = Bloque_0;
 846   1        Armar_Trama_Tarjeta_Sector1_Bloque0(Buffer_Write_MF);
 847   1        return SEQ_WRITE_SECTOR_BLOQUE;
 848   1      }
 849          unsigned char Responde_Write_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
 850          {
 851   1        unsigned char *Trama_Expedidor;
 852   1        
 853   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE0\r\n"); 
 854   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b0\r\n");
 855   1        DebugBufferMF(Buffer_Write_MF,16,ENVIADOS);
 856   1        Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor();
 857   1        
 858   1        send_port(Trama_Expedidor,strlen(Trama_Expedidor)); 
 859   1        Incremente_Ticket();
 860   1        Debug_txt_Tibbo((unsigned char *) "Trama_pto_paralelo\r\n");
 861   1        DebugBufferMF(Trama_Expedidor,strlen(Trama_Expedidor),ENVIADOS);
 862   1        return SEQ_EXPULSAR_CARD;
 863   1      }
 864          void  Armar_Trama_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_M
             -F)
 865          {
 866   1        
 867   1        /*fecha de ingreso se lee año,mes,dia,hora y minutos*/
 868   1        Block_read_Clock_Hex(Buffer_Write_MF);
 869   1        /*descuentos los borro*/
 870   1        *(Buffer_Write_MF +5)=0;
 871   1        *(Buffer_Write_MF +6)=0;
 872   1        *(Buffer_Write_MF +7)=0;
 873   1        if (*(Atributos_Expedidor + Tipo_Tarjeta)==ROTACION)
 874   1        {
 875   2          *(Buffer_Write_MF +8)  =Tipo_Vehiculo;//20
 876   2          *(Buffer_Write_MF +9)  =0x0f & Dir_board();
 877   2          *(Buffer_Write_MF +10) =APB_INT;
 878   2        }
 879   1        /*mensual*/
 880   1        else
 881   1        {
 882   2          if (*(Atributos_Expedidor + Apb)== APB_NO)
 883   2           {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 16  

 884   3              *(Buffer_Write_MF +10) =APB_NO;
 885   3            }
 886   2          else 
 887   2          {
 888   3            *(Buffer_Write_MF +10) =APB_INT;
 889   3          }
 890   2        }
 891   1        /*fecha de salida maxima*/
 892   1        *(Buffer_Write_MF +11)=0;
 893   1        *(Buffer_Write_MF +12)=0;
 894   1        *(Buffer_Write_MF +13)=0;
 895   1        *(Buffer_Write_MF +14)=0;
 896   1        *(Buffer_Write_MF +15)=0;
 897   1      }
 898          void Armar_Trama_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
 899          {
 900   1        /*graba serie de Ticket*/
 901   1        strcpy(Buffer_Write_MF, Lee_No_Ticket());
 902   1      }
 903          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor()
 904          {
 905   1        static unsigned char buffer[24];
 906   1      
 907   1        /*la trama esta compuesta de
 908   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
 909   1      
 910   1        buffer[0]=STX;
 911   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR;
 912   1        buffer[2]=NULL;
 913   1        strcat(buffer , Lee_No_Ticket());
 914   1        buffer[12]= '-';
 915   1        Block_read_Clock_Hex(buffer+13);          //leo la fecha de entrada
 916   1        buffer[13]=buffer[14]+0x030;          /*año de entrada*/
 917   1        buffer[14]=buffer[15]+0x030;          /*mes de entrada*/
 918   1        buffer[15]=buffer[16]+0x030;          /*dia de entrada*/
 919   1        buffer[16]=buffer[17]+0x030;          /*hora de entrada*/
 920   1        buffer[17]=buffer[18]+0x030;          /*minutos de entrada*/
 921   1        buffer[18]= '-';
 922   1        /*placa*/
 923   1        if (rd_eeprom(0xa8,EE_USE_LPR)!=0)
 924   1        {   
 925   2        
 926   2        buffer[19]= ' ';
 927   2        
 928   2        }
 929   1        else 
 930   1        {
 931   2          buffer[19]= ' ';
 932   2        }
 933   1        buffer[20]= ETX;
 934   1        buffer[21]= NULL;
 935   1        return buffer;
 936   1      }
 937          
 938          /*------------------------------------------------------------------------------
 939          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
 940          
 941          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
 942          ------------------------------------------------------------------------------*/
 943          
 944          unsigned char  Secuencia_inicio_expedidor(void)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 17  

 945          {
 946   1        char temp;
 947   1        switch (Estado)
 948   1        {
 949   2          case INICIA_LINTECH:
 950   2      
 951   2                
 952   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
 953   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
 954   2              
 955   2            
 956   2            return (Estado);
 957   2          break;
 958   2      
 959   2      
 960   2      /*------------------------------------------------------------------------------
 961   2      Envia la primera trama de inicializacion del transporte sin movimiento
 962   2            (0) LA RESPUESTA ES OK
 963   2            (1) NO RESPONDE EL PTO SERIE
 964   2            (2) NO RECIBIDO LA TRAMA 
 965   2            (3) ERROR DE TRAMA CMD (N)
 966   2      ------------------------------------------------------------------------------*/
 967   2            
 968   2          case SEQ_CAPTURE_DATOS_INI:
 969   2      
 970   2            if((temp=Trama_Validacion_P_N())!=0)
 971   2          {
 972   3            if(temp==2)
 973   3            {
 974   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
 975   4            } 
 976   3            else if (temp==3)
 977   3            {
 978   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
 979   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 980   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 981   4            }
 982   3            else
 983   3            {
 984   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 985   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
 986   4            }
 987   3          }
 988   2          else
 989   2          {
 990   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
 991   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 992   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
 993   3          }     
 994   2          return (Estado);
 995   2          break;
 996   2            
 997   2      /*------------------------------------------------------------------------------
 998   2      Envia el cmd de grabar claves a la eeprom del transporte 
 999   2      ------------------------------------------------------------------------------*/
1000   2            
1001   2            case GRABA_EEPROM:
1002   2              
1003   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
1004   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 18  

1005   2            
1006   2            
1007   2      
1008   2            return (Estado);
1009   2              break;
1010   2        
1011   2      /*------------------------------------------------------------------------------
1012   2      se analiza la respuesta 
1013   2            (0) LA RESPUESTA ES OK
1014   2            (1) NO RESPONDE EL PTO SERIE
1015   2            (2) NO RECIBIDO LA TRAMA 
1016   2            (3) ERROR DE TRAMA CMD (N)
1017   2      ------------------------------------------------------------------------------*/
1018   2            
1019   2          case SEQ_CAPTURA_OK_EEPROM:
1020   2          
1021   2          if((temp=Trama_Validacion_P_N())!=0)
1022   2          {
1023   3            if(temp==2)
1024   3            {
1025   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
1026   4            }
1027   3            else if (temp==3)
1028   3            {
1029   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
1030   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
1031   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
1032   4            }     
1033   3            else
1034   3            {
1035   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
1036   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
1037   4            }       
1038   3          }
1039   2          else
1040   2          {
1041   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
1042   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1043   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
1044   3          }     
1045   2      
1046   2          return (Estado);
1047   2          break;
1048   2      
1049   2      /*------------------------------------------------------------------------------
1050   2      Fin de la secuencia de comandos con exito 
1051   2      ------------------------------------------------------------------------------*/    
1052   2            
1053   2              case FIN_OK:
1054   2      
1055   2              return (Estado);
1056   2          break;
1057   2            
1058   2                
1059   2              default:
1060   2              return Estado=INICIA_LINTECH; 
1061   2              break;
1062   2        }
1063   1      }
1064          
1065          /*------------------------------------------------------------------------------
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 19  

1066          Prosedimiento  q hace paso a paso la secuencia de la MF
1067          atributos
1068          ValTimeOutCom = tiempo que  espera para recibir datos pto serie
1069          Tarjeta_on = detecto vehiculo en loop y tiene tarjeta en boca
1070          g_cEstadoComSeqMF = nos dice en el estado que nos encontramos dentro del seguimiento
1071          ------------------------------------------------------------------------------*/
1072          
1073          unsigned char SecuenciaExpedidorMF(unsigned char EstadoActivo)
1074          {
1075   1        static unsigned char Buffer_Write_MF[17];
1076   1        static unsigned char Atributos_Expedidor[4];
1077   1        //static unsigned char Estados_Expedidor[5];
1078   1      
1079   1        static unsigned char EstadoActual;
1080   1        static unsigned char EstadoPasado;
1081   1        static unsigned char EstadoFuturo;
1082   1        static unsigned char TareadelCmd;
1083   1      
1084   1        switch (EstadoActivo)
1085   1        {
1086   2      //***********************************************************************************************
1087   2          
1088   2          case SEQ_INICIO:
1089   2      
1090   2            if (ValTimeOutCom==1)
1091   2            {
1092   3              Rele_Atasco=OFF;                                                                    /*activo el rele de reset del verificador logica neg
             -ativa*/    
1093   3              Check_Status(SENSOR_NORMAL);                                                              /* se pregunta al transporte en q estado es
             -tan las TI*/
1094   3            //  Atributos_Expedidor [ EstadoPasado ] =Atributos_Expedidor [ EstadoActivo ];
1095   3              EstadoPasado=EstadoActivo;
1096   3            //  Atributos_Expedidor [ EstadoActual ]=SEQ_CMD_ACEPTADO;
1097   3              EstadoActual=EstadoActivo=SEQ_CMD_ACEPTADO; 
1098   3              // entra a validar la respuesta del transporte
1099   3              //Atributos_Expedidor [ EstadoFuturo ]=SEQ_RESPUESTA_TRANSPORTE;
1100   3              EstadoFuturo=SEQ_RESPUESTA_TRANSPORTE;
1101   3            //  Atributos_Expedidor [ TareadelCmd ]=TAREA_PRESENCIA_VEHICULAR;
1102   3              TareadelCmd=TAREA_PRESENCIA_VEHICULAR;
1103   3            }
1104   2       
1105   2          break;
1106   2          
1107   2          case  SEQ_CMD_ACEPTADO:
1108   2            EstadoActivo=rta_cmd_transporte(EstadoFuturo,EstadoPasado,EstadoActual);
1109   2            
1110   2          break;
1111   2      
1112   2      /*------------------------------------------------------------------------------
1113   2      vengo de seq_inicio donde preguntamos en el estado q se encuentra las tarjetas
1114   2            en esta caso:
1115   2            Analizo la trama y valido
1116   2            
1117   2      RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
1118   2      NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
1119   2      ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
1120   2      ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
1121   2      
1122   2      si la trama es correcta validamos si hay tarjetas en el expedidor
1123   2      Buffer_Rta_Lintech[Pos_St0]=='0'  el canal esta libre no tiene tarjeta  
1124   2      (Buffer_Rta_Lintech[Pos_St1]=='1') (1)nivel bajo de tarjetas (x)tarjetas ok     
1125   2      (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 20  

1126   2      (1)= REENVIA_TRAMA reenvia la trama al transporte
1127   2        
1128   2            
1129   2      
1130   2      ------------------------------------------------------------------------------*/      
1131   2          
1132   2            
1133   2          case SEQ_RESPUESTA_TRANSPORTE:
1134   2            
1135   2            if (TareadelCmd==TAREA_PRESENCIA_VEHICULAR)
1136   2            {
1137   3            EstadoActivo=Responde_Estado_Sensores_Transporte(); 
1138   3            
1139   3            }
1140   2            else if (TareadelCmd==TAREA_TIPO_TARJETA)
1141   2                {
1142   3                  
1143   3                  EstadoActivo=Responde_Tipo_Tarjeta();
1144   3                }
1145   2            else if (TareadelCmd==TAREA_LECTURA_TARJETA_SECTOR_BLOQUE)
1146   2                {
1147   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
1148   3                  {
1149   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque1 (Atributos_Expedidor);
1150   4                  }
1151   3                  else
1152   3                  {
1153   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1154   4                  }
1155   3                }
1156   2            else if (TareadelCmd==TAREA_WRITE_TARJETA_SECTOR_BLOQUE)
1157   2                { 
1158   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_2))
1159   3                  { 
1160   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor,Buffer_Write_MF);
1161   4                  }
1162   3                  else
1163   3                  {
1164   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque0 (Buffer_Write_MF);
1165   4                  }
1166   3                }
1167   2              else if (TareadelCmd==TAREA_OPEN_BARRERA)
1168   2                {   
1169   3                }
1170   2              else
1171   2                {
1172   3                  Debug_txt_Tibbo((unsigned char *) "TAREA_3\r\n");
1173   3                }
1174   2            break;
1175   2          case SEQ_MOVER_CARD_RF:
1176   2            Mov_Card(MovPos_RF);
1177   2            EstadoPasado=EstadoActivo;
1178   2            EstadoActual=EstadoActivo=SEQ_CMD_ACEPTADO;                                                 // entra a validar la respuesta del
             - transporte
1179   2            EstadoFuturo=SEQ_TIPO_CARD;
1180   2            
1181   2          
1182   2          break;
1183   2          case SEQ_CARD_INSERCION_ON:
1184   2            Card_Insercion(Habilita); 
1185   2            EstadoPasado=EstadoActivo;
1186   2            EstadoActual=EstadoActivo=SEQ_RESPUESTA_TRANSPORTE;                                                 // entra a validar la respu
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 21  

             -esta del transporte
1187   2            EstadoFuturo=SEQ_TIPO_CARD;
1188   2            TareadelCmd=TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
1189   2          break;
1190   2          case SEQ_TIPO_CARD:
1191   2            Aut_Card_check_Status();
1192   2            EstadoPasado=EstadoActivo;
1193   2            EstadoActual=EstadoActivo=SEQ_CMD_ACEPTADO;                                                 // entra a validar la respuesta del
             - transporte
1194   2            EstadoFuturo=SEQ_RESPUESTA_TRANSPORTE;;
1195   2            TareadelCmd=TAREA_TIPO_TARJETA;
1196   2          break;
1197   2          
1198   2          case SEQ_LOAD_PASSWORD:
1199   2            LoadVerify_EEprom();
1200   2            EstadoPasado=EstadoActivo;
1201   2            EstadoActual=EstadoActivo=SEQ_CMD_ACEPTADO;                                                 // entra a validar la respuesta del
             - transporte
1202   2            Atributos_Expedidor [ Sector ] = Sector_1;
1203   2            Atributos_Expedidor [ Bloque ] = Bloque_1;
1204   2          
1205   2            EstadoFuturo=SEQ_READ_SECTOR_BLOQUE;                //nueva secuencia
1206   2          break;
1207   2          case SEQ_READ_SECTOR_BLOQUE:
1208   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
1209   2            EstadoPasado=EstadoActivo;
1210   2            EstadoActual=EstadoActivo=SEQ_CMD_ACEPTADO;                                                 // entra a validar la respuesta del
             - transporte
1211   2            EstadoFuturo=SEQ_RESPUESTA_TRANSPORTE;;
1212   2            TareadelCmd=TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
1213   2          break;
1214   2          case SEQ_WRITE_SECTOR_BLOQUE:
1215   2            WR_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ],Buffer_Write_MF);
1216   2            EstadoPasado=EstadoActivo;
1217   2            EstadoActual=EstadoActivo=SEQ_CMD_ACEPTADO;                                                 // entra a validar la respuesta del
             - transporte
1218   2            EstadoFuturo=SEQ_RESPUESTA_TRANSPORTE;
1219   2            TareadelCmd=TAREA_WRITE_TARJETA_SECTOR_BLOQUE;
1220   2          break;
1221   2          case SEQ_CAPTURE_CARD:
1222   2            Mov_Card(MovPos_Capture); 
1223   2            EstadoPasado=EstadoActivo;
1224   2            EstadoActual=EstadoActivo=SEQ_CMD_ACEPTADO;                                                 // entra a validar la respuesta del
             - transporte
1225   2            EstadoFuturo=SEQ_INICIO;
1226   2          break;
1227   2          case SEQ_CARD_INSERCION_OFF:
1228   2            Card_Insercion(Inhabilita);
1229   2          break;
1230   2          case SEQ_EXPULSAR_CARD:
1231   2            Mov_Card(MovPos_EjectFront);
1232   2            EstadoPasado=EstadoActivo;
1233   2            EstadoActual=EstadoActivo=SEQ_CMD_ACEPTADO;                                                 // entra a validar la respuesta del
             - transporte
1234   2            EstadoFuturo=SEQ_RESPUESTA_TRANSPORTE;;
1235   2            TareadelCmd=TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
1236   2          break;
1237   2          case SEQ_LOAD_EEPROM:
1238   2            Dwload_EEprom();
1239   2            EstadoPasado=EstadoActivo;
1240   2            EstadoActual=EstadoActivo=SEQ_CMD_ACEPTADO;                                                 // entra a validar la respuesta del
             - transporte
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 22  

1241   2            EstadoFuturo=SEQ_READ_SECTOR_BLOQUE;
1242   2          break;
1243   2      /*-----------------------------------------------------
1244   2      respuesta ok hacemos la validacion de los niveles de tarjetas 
1245   2      NO_CARDS_IN_MCNSM -> No tiene tarjetas en el mecanismo      sto=0
1246   2      CARD_IN_MOUTH     -> hay una tarjeta dentro del bessel      st0=1
1247   2      CARD_OK_READ_RF   -> Tarjeta en posicion para leer/escribir dentro del mecanismo st0=2
1248   2      NO_HAVE_CARDS     -> no tiene tarjetas en el deposito st1=0
1249   2      LOW_NIVEL_CARDS   -> nivel bajo de tarjetas en el deposito  st1=1
1250   2      FULL_CARD         -> Deposito de tarjetas esta lleno        st1=2
1251   2      -------------------------------------------------------------   */
1252   2        /*  else
1253   2          {
1254   2          Responde_Estado_Sensores_Transporte()
1255   2          {
1256   2            Debug_txt_Tibbo((unsigned char *) "RTA_CARD_POS OK\r\n\r\n");                         // trama valida Habilitado 
1257   2            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            //imprimo la trama recibida
1258   2              if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                 // CANAL LIBRE    no tiene tarjetas
             - en el mecanismo
1259   2              {
1260   2                
1261   2                  if  ((Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS)||(Buffer_Rta_Lintech[Pos_St1]==FULL_CARD  ))  /*  
             -se detecta la tarjeta en la boca TARJETA EN BEZZEL
1262   2                  {
1263   2                    if (Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS  )                                         // nivel de tarjetas
1264   2                    {
1265   2                      Debug_txt_Tibbo((unsigned char *) "Nivel bajo de tarjetas\r\n\r\n");        // nivel bajo de tarjetas 
1266   2                      send_portERR(LOW_CARD);                                                     //envio msj al primario
1267   2                      PantallaLCD('a');                                                           //envio msj por la raspberry nivel bajo de tarjetas
1268   2                      //msj           
1269   2                     }
1270   2                     else
1271   2                     {
1272   2                      /*respuesta ok*/
1273   2      /*funcion q valide los sensores y verifique si expide tarjetas automatica o por boton 
1274   2                                                                                                      */                
1275   2          /*            if((sen_on_off=ValidaSensoresPaso())!=0)                                    // valido los sensores
1276   2                      {
1277   2                          if (CardAutomatic==1)                                                   //se pregunta si expide la tarjeta automatica o p
             -or presionar el boton
1278   2                          {
1279   2      
1280   2                            Debug_txt_Tibbo((unsigned char *) "Tarjeta: Automatico");             //expide tarjetas automatico co
             -n presencia
1281   2                            Mov_Card(MovPos_RF);                                                  // muevo la tarjeta hasta el lector de rf
1282   2                            g_cEstadoComSeqMF=SEQ_RTA_SEL_STACKER;                                // valido el cmd enviado al verificador
1283   2                              
1284   2                          }
1285   2                          else
1286   2                          {
1287   2                            sel_Pulsa();                                                          //se valida el pulsador en hardware
1288   2                              if ((DataIn==0))        
1289   2                              {
1290   2                                                    
1291   2                                Debug_txt_Tibbo((unsigned char *) "Pulsador Activo");             //el pulsador fue presionado
1292   2                                Mov_Card(MovPos_RF);                                              //muevo tarjeta hasta el lector de RF
1293   2                                g_cEstadoComSeqMF=SEQ_RTA_SEL_STACKER;                            //valido el cmd enviado al verificador
1294   2                              }
1295   2                              else
1296   2                              {
1297   2                                g_cEstadoComSeqMF=SEQ_RTA_CARD_SENSOR;
1298   2                              }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/21/2020 14:05:11 PAGE 23  

1299   2                  
1300   2                          } 
1301   2                      }
1302   2                    
1303   2                      else
1304   2                      { 
1305   2                        /*no hay vehiculo en los sensores se hace el loop otra vez */
1306   2        /*                g_cEstadoComSeqMF=SEQ_INICIO; 
1307   2                      }
1308   2                    }
1309   2                   }  
1310   2                   else 
1311   2                   {
1312   2                     /*dispensador no posee tarjetas*/
1313   2        /*            Debug_txt_Tibbo((unsigned char *) "Dispensador SIN TARJETAS..."); 
1314   2                    //msj a tibbo de no card  msj por diseñar 
1315   2                    send_portERR(NO_CARD);                                                      // se envia msj al uC principal, visualiza en el l
             -cd que no hay tarjetas
1316   2                    g_cEstadoComSeqMF=SEQ_INICIO;                                               //inicio el loop
1317   2                   }
1318   2              }
1319   2              else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                      //  se detecta la tarjeta en l
             -a boca TARJETA EN BEZZEL
1320   2              {
1321   2                /*hay una tarjeta en la boca del verificador */
1322   2      /*          Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca");                      //se envia msj al debuger q hay 
             -tarjeta en la boca
1323   2                Card_Insercion(Habilita);                                                     //se habilita recepcion de tarjetas por boca
1324   2                g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;                                            //se trabaja mensual        
1325   2              }
1326   2          }*/ 
1327   2        //  break;
1328   2      
1329   2        
1330   2      /*------------------------------------------------------------------------------
1331   2      expulsa la tarjeta por que no pertenece a MF50
1332   2      ------------------------------------------------------------------------------*/      
1333   2          
1334   2              default:
1335   2              EstadoActivo=SEQ_INICIO;  
1336   2              break;  
1337   2            
1338   2        } 
1339   1        return EstadoActivo;
1340   1      }
1341          
1342          
1343            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2861    ----
   CONSTANT SIZE    =    873    ----
   XDATA SIZE       =     52      77
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
