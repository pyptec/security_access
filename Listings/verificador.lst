C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\Objects\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\
                    -Listings\verificador.lst) TABS(2) OBJECT(.\Objects\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          
  12          
  13          extern void send_portERR(unsigned char cod_err);
  14          
  15          
  16          
  17          
  18          extern void PantallaLCD(unsigned char cod_msg);
  19          extern void PantallaLCD_LINEA_2(unsigned char cod_msg, unsigned char *buffer);
  20          
  21          //extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          
  23          
  24          /*funciones prototipo de clock*/
  25          
  26          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  27          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  28          void Block_read_clock_ascii(unsigned char *datos_clock);
  29          void ByteHex_Decimal(unsigned char *buffer,unsigned char valorhex);
  30          void Two_ByteHex_Decimal(unsigned char *buffer,unsigned char id_h,unsigned char id_l);
  31          extern char check_fechaOut(char *buffer);
  32          extern char lee_clk (unsigned char dir_clk);
  33          extern unsigned char bcd_hex (unsigned char l_data);
  34          extern void hex_ascii(unsigned char * datos,unsigned char * fecha_asii);
  35          
  36          extern void Cmd_Lpr_Int();
  37          extern void Delay_10ms(unsigned int cnt);
  38          
  39          /*funciones prototipo string */
  40          
  41          extern char  *strcat  (char *s1, const char *s2);
  42          extern char  *strcpy  (char *s1, const char *s2);
  43          extern unsigned int strlen  (const char *);
  44          extern char   strcmp  (const char *s1, const char *s2);
  45          
  46          /*funciones prototipo de EEprom*/
  47          
  48          extern unsigned char *Lee_No_Ticket();
  49          void Incremente_Ticket();
  50          extern unsigned char rd_eeprom (unsigned char control,unsigned int Dir); 
  51          
  52          /*funciones prototipo del transporte MODULO io_sensores*/
  53          
  54          extern unsigned char  ValidaSensoresPaso(void);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 2   

  55          unsigned char Valida_Sensor1_Auto();
  56          extern unsigned char Dir_board();
  57          extern void sel_Pulsa(void);
  58          void sel_Sensor2(void);
  59          char ValidaSensor(void);
  60          unsigned char Dir_Board_Monitor();
  61          extern void Botton ();
  62          
  63          /*funciones prototipo del transporte MODULO TIBBO*/
  64          
  65          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  66          extern void Debug_txt_Tibbo(unsigned char * str);
  67          extern void Debug_chr_Tibbo(unsigned char Dat);
  68          extern void Debug_HexDec(unsigned char xfc);
  69          
  70          /*funciones prototipo del transporte MODULO LINTECH*/
  71          
  72          extern void Aut_Card_check_Status(void);
  73          extern void Check_Status(unsigned char Detalle);
  74          extern void Dwload_EEprom (void);
  75          extern void Mov_Card(unsigned char Posicion);
  76          extern void Card_Insercion(char Tipo);
  77          extern void RD_MF(unsigned char Sector, unsigned char Bloque);
  78          extern void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer);  
  79          extern void LoadVerify_EEprom(void);
  80          extern void Clave_Seguridad_S2(void);
  81          extern void Unique_Identifier_UID(void);
  82          extern void Power_off(void);
  83          
  84          /*funcion prototipo monitor*/
  85          
  86          extern void clear_placa();
  87          extern void Rx_Monitor();
  88          
  89          /*funcion prototipo pto paralelo*/
  90          
  91          void  send_port(unsigned char *buffer_port, unsigned char length_char);
  92          
  93          /*funcion prototipo programacion*/
  94          extern unsigned char *Addr_Horarios();
  95          
  96          extern int    atoi (const char *s1);
  97          /*io sensores */
  98          
  99          sbit DataIn = P1^1;         //  dato de las entradas    
 100          sbit sel_A = P3^5;          //Pulsador                        *
 101          sbit sel_B = P3^6;          //Entrada Sensor 2                    *
 102          sbit sel_C = P3^7;          //Entrada Sensor 1                    *
 103          
 104          sbit lock = P1^7;           //Relevo  
 105          sbit Atascado_GP0_PIN_3 = P0^3;       //Rele de on/off del verificador o transporte
 106          sbit led_err_imp = P0^2;      //Error   
 107          
 108          /*pines de ip tibbo*/
 109          
 110          sbit rx_ip = P0^0;    
 111          /*variables externas*/
 112          
 113          extern unsigned char g_cEstadoComSoft;
 114          extern unsigned char ValTimeOutCom;
 115          extern unsigned char g_cContByteRx;
 116          extern unsigned char xdata Buffer_Rta_Lintech[];
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 3   

 117          
 118          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
 119          extern unsigned char Timer_wait;
 120          extern unsigned int  SIN_COBRO;
 121          extern unsigned char  Tarjeta_on;
 122          extern unsigned char cnt__ask_off;
 123          extern  unsigned char Tipo_Vehiculo;
 124          extern  unsigned char  Debug_Tibbo;                                                   /*variable q define expedicion de tarjetas 1=
             - automatico 0= a boton configurable en eeprom*/
 125          extern idata unsigned char placa[];
 126          
 127          /*externo bit*/
 128          
 129          extern bit aSk;
 130          extern bit buffer_ready;
 131          extern bit placa_ready;
 132          extern bit    PULSADOR_BOTTON;
 133          extern bit pto_paraleo;
 134          
 135          /*----------------------------------------------------------------------------
 136          Definiciones de sequencias de verificador y expedidor
 137          ------------------------------------------------------------------------------*/
 138          
 139          #define SEQ_INICIO                      0X00  
 140          #define SEQ_RESPUESTA_TRANSPORTE        0X01
 141          #define SEQ_CMD_ACEPTADO                0x02
 142          #define SEQ_MOVER_CARD_RF               0x03
 143          #define SEQ_CARD_INSERCION_ON           0x04
 144          #define SEQ_TIPO_CARD                   0X05
 145          #define SEQ_LOAD_PASSWORD               0X06
 146          #define SEQ_READ_SECTOR_BLOQUE          0X07
 147          #define SEQ_WRITE_SECTOR_BLOQUE         0X08
 148          #define SEQ_CAPTURE_CARD                0X09
 149          #define SEQ_CARD_INSERCION_OFF          0x0a
 150          #define SEQ_EXPULSAR_CARD               0x0b
 151          #define SEQ_LOAD_EEPROM                 0x0c
 152          #define SEQ_FRONT_CARD                  0x0d
 153          #define SEQ_ESPERA_VEHICULO_ENTRE       0x0e
 154          #define SEQ_DETAIL_CARD                 0x0f
 155          #define SEQ_PTO_PARALELO                0x10
 156          #define SEQ_WAIT_PLACA                  0x11
 157          #define SEQ_UID                         0X12
 158          #define SEQ_LPR                         0X13  
 159          #define SEQ_TIPO_TARJETAS               0X14
 160          #define SEQ_CAPTURE_CARD_LOOP           0X15
 161          #define SEQ_POWER_OFF                   0X16
 162          #define SEQ_POWER_ON                    0X17
 163          #define SEQ_SECOND_PASSWORD             0X18
 164          #define SEQ_PLACA                       0X19
 165          #define SEQ_DETAIL_CARD_TRAMPA          0X1A
 166          
 167          /*----------------------------------------------------------------------------
 168          Definiciones de sequencias de tareas del verificador y expedidor
 169          ------------------------------------------------------------------------------*/
 170          #define TAREA_PRESENCIA_VEHICULAR             0X00  
 171          #define TAREA_TIPO_TARJETA                    0X01
 172          #define TAREA_LECTURA_TARJETA_SECTOR_BLOQUE   0x02
 173          #define TAREA_WRITE_TARJETA_SECTOR_BLOQUE     0X03
 174          #define TAREA_OPEN_BARRERA                    0X04
 175          #define TAREA_WRITE_PLACA_CARD                0x05
 176          #define TAREA_TIPO_MENSUAL                    0x06
 177          #define TAREA_UID                             0X07
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 4   

 178          #define TAREA_PRESENCIA_ROTACION              0X08
 179          /*----------------------------------------------------------------------------
 180           definiciones de lintech en la inicializacion de expedidor o verificador
 181          ------------------------------------------------------------------------------*/
 182          
 183          #define INICIA_LINTECH          0x30
 184          #define SEQ_CAPTURE_DATOS_INI   0x31
 185          #define GRABA_EEPROM            0x32
 186          #define SEQ_CAPTURA_OK_EEPROM   0X33
 187          #define FIN_OK                  0x00
 188          
 189          
 190          #define True                    0x01
 191          #define False                   0x00
 192          /*----------------------------------------------------------------------------
 193           Definicion de datos asociados al buffer de resetcion del dato del trnasporte 
 194          
 195          ------------------------------------------------------------------------------*/
 196          
 197          
 198          #define ON    1
 199          #define OFF   0
 200          /*----------------------------------------------------------------------------
 201           ERRORES pto serie 
 202          
 203          ------------------------------------------------------------------------------*/
 204          #define REENVIA_TRAMA     0
 205          #define ESPERA_MAS_TIEMPO 1
 206          /*----------------------------------------------------------------------------
 207           definiciones de lintech en la inicializacion de expedidor o verificador
 208           funcion usada en lintech que me debuelve la respuesta de comunicacion del expedidor
 209           o verificador Trama_Validacion_P_N()
 210          RSPT_TRP_OK             (0) respuesta_transporte_oksignifica que la trama es valida y continua en el proceso
 211          NO_RSPD_TRP_PTO_COM     (1) no_responde_trasnporte_pto_com se cumple el tiempo de espera
 212          ESPR_RSPT_TRP_TRAMA     (2)Espera_respuesta_transporte_trama
 213          ERROR_TRP_TRAMA         (3) error_transpote_trama
 214          ------------------------------------------------------------------------------*/
 215          #define   RSPT_TRP_OK           0
 216          #define   NO_RSPD_TRP_PTO_COM   1
 217          #define   ESPR_RSPT_TRP_TRAMA   2
 218          #define   ERROR_TRP_TRAMA       3
 219          
 220          
 221          /*----------------------------------------------------------------------------
 222           definiciones de lintech en el comando Check_Status
 223          ------------------------------------------------------------------------------*/
 224          
 225          #define SENSOR_DETAIL       0x31
 226          #define SENSOR_NORMAL       0x30
 227          
 228          /*------------------------------------------------------------------------------
 229           definiciones de lintech en el comando Card_Insercion
 230          ------------------------------------------------------------------------------*/
 231          
 232          #define Habilita        0x30
 233          #define Inhabilita      0x31
 234          
 235          /*------------------------------------------------------------------------------
 236          Definicion de Lintech en el comando Inicializa
 237          ------------------------------------------------------------------------------*/
 238          
 239          #define TO_FRONT        '0'
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 5   

 240          #define CAPTURE_BOX     '1'
 241          #define SIN_MOVIMIENTO  '3'
 242          
 243          /*------------------------------------------------------------------------------
 244          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 245          MovPos_Front        '0'   -> mueve  tarjeta al frente pero no la suelta
 246          MovPos_IC           '1'   ->mueve la tarjeta en posicion de read/write IC
 247          MovPos_RF           '2'   ->mueve tarjeta a RF card read/write
 248          MovPos_Capture      '3'   ->captura la tarjeta
 249          MovPos_EjectFront   '9'   ->lanza la tarjeta del mecanismo
 250          
 251          ------------------------------------------------------------------------------*/
 252          
 253          #define   MovPos_Front        '0'   
 254          #define   MovPos_IC           '1'
 255          #define   MovPos_RF           '2'
 256          #define   MovPos_Capture      '3'
 257          #define   MovPos_EjectFront   '9'
 258          
 259          /*------------------------------------------------------------------------------
 260          Definicion de la trama Lintech de las respuestas de los cmd
 261          ------------------------------------------------------------------------------*/
 262          
 263          #define Pos_Length          3
 264          #define Pos_TipoResp        4
 265          #define Pos_St0             7
 266          #define Pos_St1             8
 267          #define Pos_St2             9
 268          #define Pos_IniDatMF        0x0a
 269          #define Card_type_H         0x0a
 270          #define Card_type_L         0x0b
 271          #define Rtype               0x0A
 272          /*------------------------------------------------------------------------------
 273          Definicion del estado de st0,st1,st2 de la trama Lintech 
 274          NO_CARDS_IN_MCNSM -> No tiene tarjetas en el mecanismo      sto=0
 275          CARD_IN_MOUTH     -> hay una tarjeta dentro del bessel      st0=1
 276          CARD_OK_READ_RF   -> Tarjeta en posicion para leer/escribir dentro del mecanismo st0=2
 277          NO_HAVE_CARDS     -> no tiene tarjetas en el deposito st1=0
 278          LOW_NIVEL_CARDS   -> nivel bajo de tarjetas en el deposito  st1=1
 279          FULL_CARD         -> Deposito de tarjetas esta lleno        st1=2
 280          ------------------------------------------------------------------------------*/
 281          
 282          
 283          #define NO_CARDS_IN_MCNSM   '0'
 284          #define CARD_IN_MOUTH       '1'
 285          #define CARD_OK_READ_RF     '2'
 286          #define NO_HAVE_CARDS       '0'
 287          #define LOW_NIVEL_CARDS     '1'
 288          #define FULL_CARD           '2'
 289          /*----------------------------------------------------------------------------
 290          Comprobacion automatica del tipo de tarjeta 
 291          checking RF card type
 292          Card_type_H   Card_type_L  explicacion
 293              0             0           tarjeta desconocida
 294              1             0           MF50
 295              1             1           MF70
 296              1             2           MF_UL
 297              2             0           TYPE_A_CPU
 298          ------------------------------------------------------------------------------*/
 299          #define MF50_HIGH             '1'
 300          #define MF50_LOW              '0'
 301          #define MF70                  '1'
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 6   

 302          #define OPERATE_FAIL          0X6F
 303          
 304          /*----------------------------------------------------------------------------
 305          definicion de recepcion serial 
 306          ------------------------------------------------------------------------------*/
 307          
 308          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 309          
 310          /*----------------------------------------------------------------------------
 311          tiempo de delay entre funciones
 312          ------------------------------------------------------------------------------*/
 313          
 314          #define   TIME_CARD         100   //50
 315          #define   TIME_WAIT         18
 316          #define   TIME_PULSADOR     5
 317          
 318          /*----------------------------------------------------------------------------
 319          definicion de datos de trama lintech
 320          ------------------------------------------------------------------------------*/
 321          
 322          
 323          #define   STX_LINTECH       0xf2
 324          
 325          /*----------------------------------------------------------------------------
 326          msj de lcd tarjeta y lcd serie
 327          ------------------------------------------------------------------------------*/
 328          /*Los cmd PRMR son enviados por el primario*/
 329          #define PRMR_ERROR_LOOP         0XE0
 330          #define ERROR_LOOP              170
 331          #define PRMR_ERROR_COD_PARK     0XE5
 332          #define ERROR_COD_PARK          171
 333          #define PRMR_TARJETA_INVALIDA   0XE1
 334          #define PULSE_BOTON             172
 335          #define PRMR_TARJETA_SIN_FORMATO  0xDF
 336          #define TARJETA_SIN_FORMATO       173
 337          
 338          #define PRMR_NO_CARD_MENSUAL          0XFC
 339          #define NO_CARD_MENSUAL         176
 340          #define TARJETA_INVALIDA        177
 341          
 342          #define PRMR_NO_ROTACION              0XFD
 343          
 344          #define PRMR_SIN_SALIDA             0XE9
 345          #define SIN_SALIDA              178
 346          #define REGISTRA_INGRESO        179
 347          
 348          #define PRMR_TARJETA_VENCIDA          0XEC
 349          #define TARJETA_VENCIDA         180
 350          #define PRMR_ERROR_TIPO_VEHICULO      0XF8
 351          #define PRMR_MENSUAL_FUERA_HORARIO    0Xb5
 352          #define MENSUAL_FUERA_HORARIO   181
 353          #define ERROR_MF1               0XE2
 354          #define HORARIO_NO_PROG         182
 355          
 356          
 357          
 358          #define BIENVENIDO              0XFE
 359          #define NO_CARD                 0xFA  
 360          
 361          #define RETIRE_TARJETA          0XA1
 362          
 363          #define LOW_CARD                0x01
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 7   

 364          
 365          #define AUDIO_ENTRADA     0XA0
 366          #define AUDIO_CAJA        0XA1
 367          #define AUDIO_GRACIAS     0XA2
 368          /*----------------------------------------------------------------------------
 369          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 370          ------------------------------------------------------------------------------*/
 371          
 372          #define   ENVIADOS          0X0
 373          #define   RESPUESTA         0X01
 374          #define   SIN_MSJ           0X02
 375          /*
 376          definicion  de daos del reloj
 377                    */
 378          
 379          #define RDIA            0x87
 380          #define RMES            0x89
 381          #define RANO            0x8D
 382          #define RDIA_SEMANA     0x8B
 383          #define RHORA           0x85
 384          #define RMIN            0x83
 385          #define Sabado          7
 386          #define Domingo         1
 387          /*----------------------------------------------------------------------------
 388          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 389          (0) si el dato es cero esta inactiva
 390          (1) activa o ROTACION
 391          (2) mensualidad
 392          ------------------------------------------------------------------------------*/
 393          enum Tipos_MF_TIPO_TARJETA{
 394            INACTIVA,         
 395            ROTACION,           
 396            MENSUALIDAD,
 397            PREPAGO,
 398            CORTESIA,
 399            LOCATARIO,
 400            TARJETA_PERDIDA = 0X10,
 401            INHABILITADA = 0X11
 402          };
 403          /*----------------------------------------------------------------------------
 404          posicion de  MF  bloque 1 sector 1
 405          (0) tipo de tarjeta 
 406          (01) el id del cliente
 407          (03)codigo del parqueadero  
 408          ------------------------------------------------------------------------------*/
 409          #define   MF_TIPO_TARJETA   0X00
 410          #define   MF_COD_PARK       0x01      //MF_ID_CLIENTE
 411          #define   MF_ID_CLIENTE     0x03      //MF_COD_PARK
 412          
 413          /*----------------------------------------------------------------------------
 414          posicion de  MF bloque 2 sector 1
 415          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 416          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 417          ------------------------------------------------------------------------------*/
 418          
 419          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 420          
 421          
 422          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 423                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 8   

 424          #define   MF_LSB            0x06
 425          
 426          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 427          
 428          #define   MF_IN_PAGO        0x09
 429          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 430          
 431          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 432          
 433          #define   MF_MENSUAL_ANO      0X05
 434          #define   MF_MENSUAL_MES      0X06
 435          #define   MF_MENSUAL_DIA      0X07
 436          
 437          #define   MF_UID_0      0X04
 438          #define   MF_UID_1      0X05
 439          #define   MF_UID_2      0X06
 440          #define   MF_UID_3      0X07
 441          
 442          #define   MF_EXPIRA_ANO     0X08
 443          #define   MF_EXPIRA_MES     0X09
 444          #define   MF_EXPIRA_DIA     0X0A
 445          
 446          #define   HABILITA_ADDR     15
 447          #define   Segundo_Tiempo    16
 448          
 449          enum Hora_Minutos_addr{
 450            Hora_High_addr_Desde = 7, Hora_Low_addr_Desde = 8, Minutos_High_addr_Desde = 9, Minutos_Low_addr_Desde = 
             -10,
 451            Hora_High_addr_Hasta = 11, Hora_Low_addr_Hasta = 12, Minutos_High_addr_Hasta = 13, Minutos_Low_addr_Hasta
             - = 14
 452          };
 453          
 454          enum Estados_Expedidor{
 455           EstadoActual,
 456           EstadoPasado,
 457           EstadoFuturo,
 458           TareadelCmd  
 459          };
 460          enum expedidor {
 461           Sector,        
 462           Bloque,        
 463           Tipo_Tarjeta,
 464           Apb,
 465           Horario,
 466           Pico_Placa,
 467           Type_Vehiculo,
 468           Uid_0,
 469           Uid_1,
 470           Uid_2,
 471           Uid_3,
 472           Expira_ano,
 473           Expira_mes,
 474           Expira_dia
 475           
 476          };
 477          /*tipos de APB antipassback*/
 478          enum Tipos_MF_APB{
 479            
 480            APB_INICIADO,       
 481            APB_INT,              
 482            APB_OUT,              
 483            APB_NO              
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 9   

 484          };
 485          /*tipo de vehiculo*/
 486          /*Sectores y bloques de Mf*/
 487          enum MF_Sector_Bloque{
 488            Sector_0,
 489            Sector_1,
 490            Sector_2,
 491            Bloque_0 = 0,
 492            Bloque_1 = 1,
 493            Bloque_2 = 2
 494          };
 495          /*comandos pto paralelo*/
 496          enum CMD_Trama_Pto_Paralelo{
 497            STX=02,
 498            CMD_PTO_PARALELO_EXPEDIDOR='a',
 499            ETX= 03,
 500            NULL=0,
 501            CMD_MONITOR_EXPEDIDOR='E',
 502            CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL='M'
 503          };
 504          enum EE_AntiPassBack{
 505            APB_INHABILITADO_SOFT,
 506            APB_HABILITADO_SOFT
 507          };  
 508          enum Tipos_Vehiculos{
 509              AUTOMOVIL,          
 510              MOTO,
 511              BICICLETA
 512          };  
 513          
 514          /*DATOS DE CONFIGURACION EEPROM*/
 515          #define EE_ID_CLIENTE           0x0000
 516          #define EE_ID_PARK              0x0002
 517          #define EE_DEBUG                0x0008
 518          #define EE_USE_LPR              0x000A
 519          #define EE_CARD_AUTOMATIC_BOTON 0x000f
 520          #define EE_HABILITA_APB         0x0010
 521          #define EE_PLACA                0X0011
 522          #define EE_VALIDA_TIPO_VEHICULO_MENSUAL 0X0014
 523          #define EE_HABILITA_APB_MENSUAL 0X0015
 524          
 525          /*----------------------------------------------------------------------------
 526          Definicion de varaibles globales del objeto
 527          ------------------------------------------------------------------------------*/
 528          
 529          static unsigned char Estado=INICIA_LINTECH;
 530          bit MenSual = False;
 531          /*------------------------------------------------------------------------------
 532          
 533          ------------------------------------------------------------------------------*/
 534          unsigned char Captura_Expulsa()
 535          {
 536   1        unsigned char Estado_expedidor;
 537   1        
 538   1        
 539   1        if(MenSual !=  True)
 540   1        {
 541   2          Estado_expedidor=SEQ_CAPTURE_CARD_LOOP; //SEQ_CAPTURE_CARD;                                       
 542   2        }
 543   1        else
 544   1        {
 545   2        
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 10  

 546   2        Estado_expedidor = SEQ_EXPULSAR_CARD;//SEQ_CARD_INSERCION_OFF;  
 547   2        } 
 548   1      
 549   1      
 550   1      return  Estado_expedidor;
 551   1      }
 552          /*------------------------------------------------------------------------------
 553          funcion que valida la trama del verificador o transporte lintech
 554          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 555          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 556          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 557          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 558          
 559          
 560          ------------------------------------------------------------------------------*/
 561          
 562          char Trama_Validacion_P_N()
 563          {
 564   1        char Trama_Validacion_P_N=ESPR_RSPT_TRP_TRAMA;                                /*espera respuesta del transporte*/
 565   1            
 566   1            if ((ValTimeOutCom==1)||(buffer_ready==1)|| (ValTimeOutCom > TIME_CARD) )
 567   1            {
 568   2              if (buffer_ready==1)
 569   2              {
 570   3                buffer_ready=0;
 571   3                  
 572   3              
 573   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 574   3                {
 575   4                          
 576   4                  Trama_Validacion_P_N=RSPT_TRP_OK;                                       /*trama ok*/
 577   4                    
 578   4                }
 579   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 580   3                {
 581   4                  
 582   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;                                 /*error de trama*/
 583   4                  
 584   4                }
 585   3                else
 586   3                {
 587   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
 588   4                  Trama_Validacion_P_N=ERROR_TRP_TRAMA  ;   
 589   4                  
 590   4                }
 591   3              }
 592   2              else
 593   2              {
 594   3                          
 595   3                Trama_Validacion_P_N=NO_RSPD_TRP_PTO_COM;                                 /*pto serie no responde */
 596   3                                                  
 597   3              }
 598   2      
 599   2            }
 600   1            
 601   1        return Trama_Validacion_P_N;
 602   1      }
 603          /*------------------------------------------------------------------------------
 604          funcion de error de respuesta pto serie
 605          
 606          variable en uart. cnt__ask_off=cuenta los numeros de error pto serie y reset de transporte 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 11  

 607          se limpia cuando llega la respuesta del transporte. 
 608          Rele_Atasco = es un I/O del Mc que activa / inhabilita el rele
 609          ON    (1) esta activo 
 610          OFF   (0) inhactivo 
 611          REENVIA_TRAMA   1
 612          ESPERA_MAS_TIEMPO 0
 613          cnt_espera_ask_on= cuenta el tiempo de ASK que esta activo,sin que le llegue
 614                             la trama completa, al  5 tiempos borra el ask y retrasmite el cmd
 615          
 616          error_rx_pto= (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 617                      = (1)= REENVIA_TRAMA reenvia la trama al transporte
 618          
 619          cnt__ask_off= varible global esta definida en pto serie y es un contador , que 
 620          se limpia cada vez que la trama a llegado completa y validada
 621          
 622          aSk= significa que llego al pto serie el 06 = ask donde el transporte dice que a recibido el cmd
 623          esta ejecutando y nos enviara la respuesta,necesita tiempo esta bit esta definino en el modulo uart es glo
             -bal
 624          
 625          ------------------------------------------------------------------------------*/
 626          unsigned char error_rx_pto(void)
 627          {
 628   1      
 629   1      static unsigned cnt_espera_ask_on=0;
 630   1      unsigned char error_rx_pto=ESPERA_MAS_TIEMPO;
 631   1      
 632   1          
 633   1                
 634   1            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...");
 635   1            Debug_chr_Tibbo (cnt__ask_off); 
 636   1            Debug_chr_Tibbo (cnt_espera_ask_on);
 637   1            Debug_chr_Tibbo (error_rx_pto);
 638   1            Debug_txt_Tibbo((unsigned char *) "\r\n");
 639   1            if (aSk==OFF)
 640   1            
 641   1            { 
 642   2                cnt__ask_off++;                                                                   /*cuento el error*/                                                               
 643   2              if(cnt__ask_off>=10)
 644   2              { 
 645   3                Debug_txt_Tibbo((unsigned char *) "ATASCADO RESET\r\n");                                                                      /*no conte
             -sta debe reset el transporte*/
 646   3                Atascado_GP0_PIN_3 = ON;                                                                    /*off el rele de reset del verificador*/    
 647   3                Delay_10ms(110);
 648   3                cnt__ask_off=0;                                                                   /*limpio ls errores*/
 649   3                cnt_espera_ask_on=0;
 650   3                error_rx_pto=ESPERA_MAS_TIEMPO;                                                   /**/
 651   3                Atascado_GP0_PIN_3 = OFF; 
 652   3                Delay_10ms(110);                                                                  /*On el rele de reset del verificador*/   
 653   3                ValTimeOutCom=TIME_CARD;
 654   3              }
 655   2              else;
 656   2              {
 657   3                error_rx_pto=REENVIA_TRAMA;                                                       /*1 reenvia trama*/
 658   3                ValTimeOutCom=TIME_CARD;
 659   3              }
 660   2            }                                                                                     /*aSk esta activo */
 661   1            else
 662   1            {
 663   2                cnt_espera_ask_on++;                                                              /*cuento n tiempos de ask para recibir el total de
             - la trama*/
 664   2              if(cnt_espera_ask_on>=1)
 665   2              {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 12  

 666   3                cnt__ask_off=0;                                                                   /*paso tiempo de espera y no se completo la trama 
 667   3                                                                                                  limpio los reg y reenvio la trama y ask=off*/
 668   3                cnt_espera_ask_on=0;
 669   3                error_rx_pto=REENVIA_TRAMA;
 670   3                aSk=OFF;
 671   3                ValTimeOutCom=TIME_CARD;
 672   3              }
 673   2              else
 674   2              {
 675   3                cnt__ask_off=0;                                                                   /*damos tiempo de espera de la trama del transporte*
             -/
 676   3                error_rx_pto=ESPERA_MAS_TIEMPO;;
 677   3                ValTimeOutCom=TIME_CARD;
 678   3              }
 679   2            }
 680   1              return (error_rx_pto);
 681   1      }
 682          /*------------------------------------------------------------------------------
 683          Funcion de respuesta a los cmd del transporte
 684          Retorna rta_cmd_transporte el estado en que queda
 685          Recibe tres datos unos es el 
 686          Estado_futuro= significa que la respuesta fue ok
 687          Estado_Error= en caso de que aya un error a que estado envia el codigo
 688          Estado_Actua= No ha llegado la respuesta y sigue en el mismo estado
 689          RSPT_TRP_OK           (0) significa que la trama es valida y sigue en el proceso
 690          NO_RSPD_TRP_PTO_COM   (1) falla en la respuesta por pto serie o trama invalida  
 691          ESPR_RSPT_TRP_TRAMA   (2) no ha recibido la trama del verificador o transporte  
 692          ERROR_TRP_TRAMA       (3) ERROR DE TRAMA CMD (N)
 693          
 694          (0)= ESPERA_MAS_TIEMPO nos da mas tiempo para esperar la trama,
 695          (1)= REENVIA_TRAMA reenvia la trama al transporte
 696          ------------------------------------------------------------------------------*/
 697          unsigned char   rta_cmd_transporte(unsigned char *secuencia_Expedidor )
 698          {
 699   1        unsigned char temp;
 700   1        unsigned char EstadoComSeqMF;
 701   1        
 702   1        
 703   1            
 704   1      if((temp=Trama_Validacion_P_N())!=RSPT_TRP_OK )
 705   1          {
 706   2            if(temp==ESPR_RSPT_TRP_TRAMA)                                                         /*no he recibido respuesta espero*/
 707   2            {
 708   3            EstadoComSeqMF= *(secuencia_Expedidor + EstadoActual);                              /*SEQ_RTA_CARD_POSno ha respon
             -dido*/
 709   3            } 
 710   2            else if (temp==ERROR_TRP_TRAMA)
 711   2            {
 712   3            Debug_txt_Tibbo((unsigned char *) "RTA_CMD_ERROR\r\n");                     /* trama no valida respuesta incorrec
             -ta falla en la escritura */
 713   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 714   3            EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado); 
 715   3            //EstadoComSeqMF=SEQ_INICIO ;                                                           /// (3) Trama invalida cmd (N)reenvio cmd*/ 
 716   3            }     
 717   2            else
 718   2            {
 719   3            /*Dispensador No Responde PTO SERIE ...*/
 720   3          
 721   3              if(temp=error_rx_pto()==ESPERA_MAS_TIEMPO)
 722   3              {
 723   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoActual); 
 724   4              }                                                                                     /*SEQ_RTA_CARD_POS;*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 13  

 725   3              else                                                                                  //(temp=error_rx_pto()==REENVIA_TRAMA)
 726   3              {
 727   4                EstadoComSeqMF=*(secuencia_Expedidor + EstadoPasado);                                                     /*SEQ_INICIO*/
 728   4              }                                                 
 729   3            }       
 730   2          }
 731   1          else
 732   1          {
 733   2            
 734   2            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);
 735   2            EstadoComSeqMF=*(secuencia_Expedidor + EstadoFuturo); 
 736   2          }
 737   1        return EstadoComSeqMF;
 738   1      }
 739          
 740          /*------------------------------------------------------------------------------
 741          ------------------------------------------------------------------------------*/
 742          unsigned char Analiza_Presencia_Mensual()
 743          {
 744   1        unsigned char Estado_expedidor;
 745   1        
 746   1        
 747   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 748   1          {
 749   2            MenSual = True;
 750   2            Estado_expedidor = SEQ_TIPO_CARD;                 //SEQ_UID
 751   2          }
 752   1        else
 753   1          { 
 754   2            
 755   2              send_portERR(PRMR_ERROR_LOOP);
 756   2              PantallaLCD(ERROR_LOOP);
 757   2              Estado_expedidor = SEQ_DETAIL_CARD_TRAMPA;
 758   2          }
 759   1        return Estado_expedidor;
 760   1      }
 761          unsigned char Analiza_card_mount_rf()
 762          {
 763   1      unsigned char Estado_expedidor;
 764   1        ValTimeOutCom=TIME_WAIT;
 765   1           if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta en l
             -a boca TARJETA EN BEZZEL
 766   1              {
 767   2                    /*hay una tarjeta en la boca del verificador */
 768   2                    Debug_txt_Tibbo((unsigned char *) "Analiza_card_mount\r\n");                                //se envia msj al debug
             -er q hay tarjeta en la boca
 769   2                                                                                                                //se habilita recepcion de tarjetas por boca
 770   2                    Estado_expedidor = SEQ_CARD_INSERCION_ON;                                                     //se trabaja mensual        
 771   2              }
 772   1              else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
 773   1                  
 774   1              {
 775   2                    Debug_txt_Tibbo((unsigned char *)"Analiza_card_rf\r\n");
 776   2                    Estado_expedidor=SEQ_EXPULSAR_CARD;
 777   2              }
 778   1              
 779   1      
 780   1        return Estado_expedidor;
 781   1      }
 782          unsigned char Analiza_Presencia_rotacion()
 783          {
 784   1        unsigned char Estado_expedidor;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 14  

 785   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 786   1          {
 787   2            
 788   2            Estado_expedidor = SEQ_MOVER_CARD_RF;                 //SEQ_UID
 789   2          }
 790   1        else
 791   1          { 
 792   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 793   2              send_portERR(PRMR_ERROR_LOOP);
 794   2              PantallaLCD(ERROR_LOOP);
 795   2              Estado_expedidor = SEQ_INICIO;  //SEQ_EXPULSAR_CARD;
 796   2                    
 797   2          }
 798   1        return Estado_expedidor;
 799   1      }
 800          /*------------------------------------------------------------------------------
 801          Funcion numero unico de identificacion
 802          ------------------------------------------------------------------------------*/
 803          unsigned char Analiza_Uid_Card(unsigned char *Atributos_Expedidor )
 804          {
 805   1        unsigned char Estado_expedidor;
 806   1        unsigned char temp;
 807   1        unsigned char buffer_UID[17];
 808   1          if (Buffer_Rta_Lintech[Pos_Length] >= 0x0f)
 809   1            {
 810   2              
 811   2                for (temp=0; temp<16; ++temp)
 812   2                {
 813   3                  buffer_UID [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de M
             -F en un arreglo*/
 814   3                 
 815   3                }
 816   2                
 817   2                Debug_txt_Tibbo((unsigned char *) "buffer_UID\r\n");
 818   2                DebugBufferMF(buffer_UID,16,RESPUESTA);
 819   2                
 820   2        
 821   2                Debug_txt_Tibbo((unsigned char *) "UID_CARD :");  
 822   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_0]));  
 823   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_1]));  
 824   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_2]));  
 825   2                Debug_chr_Tibbo((buffer_UID [ MF_UID_3]));
 826   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
 827   2                
 828   2              *(Atributos_Expedidor + Uid_0) = buffer_UID [MF_UID_0];   
 829   2              *(Atributos_Expedidor + Uid_1) = buffer_UID [MF_UID_1];     
 830   2              *(Atributos_Expedidor + Uid_2) = buffer_UID [MF_UID_2];     
 831   2              *(Atributos_Expedidor + Uid_3) = buffer_UID [MF_UID_3]; 
 832   2              Estado_expedidor=SEQ_LPR;                                         ///SEQ_LOAD_PASSWORD;                                                       //SEQ_T
             -IPO_CARD;
 833   2            }   
 834   1            else
 835   1            {
 836   2              Estado_expedidor=SEQ_POWER_OFF;
 837   2            } 
 838   1            return Estado_expedidor;
 839   1      }
 840          /*------------------------------------------------------------------------------
 841          Se analiza si expulsa la tarjeta por boton o automatica
 842          ------------------------------------------------------------------------------*/
 843          unsigned char Ingreso_Vehiculo(void)
 844            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 15  

 845   1          unsigned char CardAutomatic;  
 846   1          static unsigned char pulseboton=24;
 847   1          
 848   1        
 849   1        if((ValidaSensoresPaso())!=False)                                               // valido los sensor de piso
 850   1          {
 851   2            CardAutomatic=rd_eeprom(0xa8,EE_CARD_AUTOMATIC_BOTON);  
 852   2            
 853   2            if (CardAutomatic==True)                                                    //se pregunta si expide la tarjeta automatica o por p
             -resionar el boton
 854   2              {
 855   3                Debug_txt_Tibbo((unsigned char *) "Tarjeta: Automatico\r\n");           //expide tarjetas automatico con p
             -resencia
 856   3                                                                                        // muevo la tarjeta hasta el lector de rf
 857   3                Estado=SEQ_MOVER_CARD_RF;                                               // valido el cmd enviado al verificador
 858   3               }
 859   2            else
 860   2              {   
 861   3            /*solo sale el msj pulse el boton una vez cada 24 veces */          
 862   3                  if(pulseboton >= 24)
 863   3                  { PantallaLCD(PULSE_BOTON); 
 864   4                    pulseboton=0;
 865   4                  }
 866   3                  else
 867   3                   {
 868   4                     pulseboton++;
 869   4                  
 870   4                   
 871   4                   }
 872   3                   Botton ();
 873   3                   if(PULSADOR_BOTTON == True)
 874   3                   {
 875   4                     PULSADOR_BOTTON = 0;
 876   4                     pulseboton=0;                                                                //muevo tarjeta hasta el lector de RF
 877   4                     Estado=SEQ_MOVER_CARD_RF;
 878   4                   }
 879   3                   else
 880   3                   {
 881   4                    Estado=SEQ_INICIO; 
 882   4                   }
 883   3                
 884   3                  
 885   3              } 
 886   2          }
 887   1          else
 888   1              { 
 889   2                /*no hay vehiculo en los sensores se hace el loop otra vez */
 890   2                Estado=SEQ_INICIO;  
 891   2              }
 892   1        return Estado;
 893   1      }
 894           
 895          /*------------------------------------------------------------------------------
 896          Se pregunta por el estado del expedidor si hay tarjetas y presencia para expulsar tarjeta
 897          o si hay tarjeta en la boca o rf para entrar en mensuales
 898          ------------------------------------------------------------------------------*/
 899          
 900          unsigned char Responde_Estado_Sensores_Transporte()
 901          {
 902   1        unsigned char Estado_expedidor;
 903   1          
 904   1            Debug_txt_Tibbo((unsigned char *) "TAREA_PRESENCIA_VEHICULAR\r\n");                                 // trama valida Hab
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 16  

             -ilitado 
 905   1          
 906   1            if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                                 // CANAL LIBRE    no tiene 
             -tarjetas en el mecanismo
 907   1            {
 908   2                
 909   2              if  ((Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS)||(Buffer_Rta_Lintech[Pos_St1]==FULL_CARD  ))  //  se
             - detecta la tarjeta en la boca TARJETA EN BEZZEL
 910   2              {
 911   3                if (Buffer_Rta_Lintech[Pos_St1]==LOW_NIVEL_CARDS  )                                             // nivel de tarjetas
 912   3                  {
 913   4                    Debug_txt_Tibbo((unsigned char *) "Nivel bajo de tarjetas\r\n");                            // nivel bajo de tarj
             -etas 
 914   4                    send_portERR(LOW_CARD);                                                                     //envio msj al primario
 915   4                  //  PantallaLCD(LOW_CARD);                                                                            //envio msj por la raspberry nivel ba
             -jo de tarjetas
 916   4                    Estado_expedidor=Ingreso_Vehiculo();        
 917   4                   }
 918   3                   else
 919   3                      {
 920   4                        /*respuesta ok*/
 921   4                       Estado_expedidor=Ingreso_Vehiculo();
 922   4                      
 923   4                      }
 924   3              } 
 925   2              else 
 926   2                  {
 927   3                    /*dispensador no posee tarjetas*/
 928   3                    Debug_txt_Tibbo((unsigned char *) "Dispensador SIN TARJETAS...\r\n"); 
 929   3                    
 930   3                    send_portERR(NO_CARD);  
 931   3                                                                          // se envia msj al uC principal, visualiza en el lcd que no hay tarjetas
 932   3                  //  PantallaLCD(NO_CARD);   
 933   3                    Estado_expedidor=SEQ_INICIO;                                                                //inicio el loop
 934   3                   }
 935   2            }
 936   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
 937   1              {
 938   2                    /*hay una tarjeta en la boca del verificador */
 939   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n");                                //se envia msj al debug
             -er q hay tarjeta en la boca
 940   2                                                                                                                //se habilita recepcion de tarjetas por boca
 941   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;                                                     //se trabaja mensual        
 942   2              }
 943   1            else if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF )  
 944   1                  
 945   1              {
 946   2                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en RF\r\n");
 947   2                    Estado_expedidor=SEQ_CARD_INSERCION_ON;
 948   2              }
 949   1            else
 950   1              {
 951   2                Estado_expedidor=SEQ_INICIO;  
 952   2              }
 953   1        return Estado_expedidor;  
 954   1      }
 955          
 956          /*------------------------------------------------------------------------------
 957          Funcion que nos dice el tipo de tarjeta que tiene en el mecanismo
 958          Comprobacion automatica del tipo de tarjeta 
 959          checking RF card type
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 17  

 960          Card_type_H   Card_type_L  explicacion
 961              0             0           tarjeta desconocida
 962              1             0           MF50
 963              1             1           MF70
 964              1             2           MF_UL
 965              2             0           TYPE_A_CPU
 966          
 967          #define MF50_HIGH             '1'
 968          #define MF50_LOW              '0'
 969          ------------------------------------------------------------------------------*/
 970          unsigned char Responde_Tipo_Tarjeta()
 971            {
 972   1          unsigned char Estado_expedidor;
 973   1          
 974   1            Debug_txt_Tibbo((unsigned char *) "TAREA_TIPO DE TARJETA\r\n");                         // trama valida Habilitado 
 975   1            
 976   1        if (Buffer_Rta_Lintech[Card_type_H]==MF50_HIGH)                                             /* pregunto si la tarjeta en el tra
             -nsporte es MF 50 */
 977   1          {
 978   2          if ((Buffer_Rta_Lintech[Card_type_L] == MF50_LOW) || (Buffer_Rta_Lintech[Card_type_L] == MF70)) 
 979   2            {
 980   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n");                         /* trama valida son MF50*/
 981   3              if(MenSual ==  True)
 982   3              {
 983   4              Estado_expedidor = SEQ_UID;                                                             //SEQ_LOAD_PASSWORD;                        
 984   4              }
 985   3              else  
 986   3              {
 987   4                Estado_expedidor = SEQ_LPR;   //SEQ_LOAD_PASSWORD;
 988   4              }         
 989   3            }
 990   2            else
 991   2              {
 992   3                 if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta
             - en la boca TARJETA EN BEZZEL
 993   3                {
 994   4                
 995   4                Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida_1 no es MF50\r\n");           /* trama no valida */
 996   4                      
 997   4                send_portERR(PRMR_TARJETA_INVALIDA);                                                              /*envio msj principal tarjeta inva
             -lidad*/
 998   4                PantallaLCD(TARJETA_INVALIDA);
 999   4                    
1000   4                  Estado_expedidor = Captura_Expulsa(); 
1001   4                
1002   4                } 
1003   3                else  
1004   3                {
1005   4                  MenSual = False;
1006   4                  Estado_expedidor = SEQ_INICIO;    
1007   4                }           
1008   3              }
1009   2          }
1010   1          else 
1011   1            {
1012   2               if (Buffer_Rta_Lintech[Pos_St0]==CARD_OK_READ_RF)                                                //  se detecta la tarjeta 
             -en la boca TARJETA EN BEZZEL
1013   2                {
1014   3                  /*patina el transporte */
1015   3                
1016   3              Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n");           /* trama no valida */
1017   3                      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 18  

1018   3              send_portERR(PRMR_TARJETA_INVALIDA);                                                              //la tarjeta no es valida 
1019   3              PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la raspber
             -ry*/
1020   3                        
1021   3              Estado_expedidor = Captura_Expulsa(); 
1022   3                          
1023   3                  
1024   3                }
1025   2                else  
1026   2                {
1027   3                  MenSual = False;
1028   3                  Estado_expedidor = SEQ_INICIO;    
1029   3                }                     
1030   2            }
1031   1                    
1032   1          return Estado_expedidor;                                                                                                  
1033   1        } 
1034          /*------------------------------------------------------------------------------
1035            Funcion que lee los datos en el Sector 1 Bloque 1
1036            se lee
1037            ID_CLIENTE
1038            COD_PARK
1039            TIPO DE TARJETA
1040            EXPIRA_ANO
1041            EXPIRA_MES
1042            EXPIRA_DIA
1043          ------------------------------------------------------------------------------*/
1044          
1045          unsigned char  Responde_Lectura_Tarjeta_Sector1_Bloque1 (unsigned char *Atributos_Expedidor)
1046          {
1047   1        unsigned char temp;
1048   1        unsigned char Estado_expedidor;
1049   1        unsigned char buffer_S1_B1[17];
1050   1        unsigned char ID_CLIENTE;
1051   1        unsigned char COD_PARK;   
1052   1        static unsigned char falla=0;
1053   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE1\r\n");   
1054   1                                        
1055   1                                      
1056   1            
1057   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1058   1            {
1059   2              
1060   2                for (temp=0; temp<16; ++temp)
1061   2                {
1062   3                  buffer_S1_B1 [temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                            /*almaceno la informacion de
             - MF en un arreglo*/
1063   3                 
1064   3                }
1065   2                
1066   2                
1067   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b1\r\n");
1068   2                DebugBufferMF(buffer_S1_B1,16,RESPUESTA);
1069   2                ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1070   2                COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
1071   2                /*Compara  MF_ID_CLIENTE y MF_COD_PARK con el codigo del parqueadero ID_CLIENTE  COD_PARK*/
1072   2                
1073   2                if (((buffer_S1_B1 [ MF_ID_CLIENTE])==ID_CLIENTE) && ((buffer_S1_B1 [ MF_COD_PARK] ) == COD_PARK)||((
             -ID_CLIENTE==0)&&(COD_PARK==0)))   
1074   2                {
1075   3                    
1076   3                  Debug_txt_Tibbo((unsigned char *) "CARD ID_CLIENTE: ");               
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 19  

1077   3                  Debug_HexDec((buffer_S1_B1 [ MF_ID_CLIENTE]));
1078   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1079   3                  
1080   3                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");                
1081   3                  Debug_HexDec(ID_CLIENTE);
1082   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1083   3                  
1084   3                  Debug_txt_Tibbo((unsigned char *) "CARD COD_PARK:");                    
1085   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1086   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1087   3                  
1088   3                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");                   
1089   3                  Debug_HexDec(buffer_S1_B1 [ MF_COD_PARK]);
1090   3                  Debug_txt_Tibbo((unsigned char *) "\r\n"); 
1091   3      
1092   3                  Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA: ");
1093   3                  Debug_chr_Tibbo(buffer_S1_B1 [MF_TIPO_TARJETA]);
1094   3                  Debug_txt_Tibbo((unsigned char *) "\r\n");
1095   3                  
1096   3                  *(Atributos_Expedidor + Tipo_Tarjeta) = buffer_S1_B1 [MF_TIPO_TARJETA];
1097   3                  /*fecha de vencimiento de mensual o prepago*/
1098   3                  *(Atributos_Expedidor + Expira_ano) = buffer_S1_B1 [MF_EXPIRA_ANO];
1099   3                  *(Atributos_Expedidor + Expira_mes) = buffer_S1_B1 [MF_EXPIRA_MES];
1100   3                  *(Atributos_Expedidor + Expira_dia) = buffer_S1_B1 [MF_EXPIRA_DIA];
1101   3                  
1102   3                  *(Atributos_Expedidor + Sector) = Sector_1;
1103   3                  *(Atributos_Expedidor + Bloque) = Bloque_2;
1104   3                  falla=0;
1105   3                  Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1106   3              
1107   3                }
1108   2                else
1109   2                {
1110   3                  falla=0;
1111   3                  Debug_txt_Tibbo((unsigned char *) "ERROR COD PARK\r\n");
1112   3                  send_portERR(PRMR_ERROR_COD_PARK);
1113   3                  PantallaLCD(ERROR_COD_PARK);                                                        //envio el msj por la pantalla lcd o la rasp
             -berry
1114   3                  Estado_expedidor = Captura_Expulsa();                                                 //   codigo de parqueo erro expulso la 
             -tarjeta     
1115   3                }
1116   2            }
1117   1            else
1118   1            {
1119   2                
1120   2              if ((Buffer_Rta_Lintech[Rtype]) == OPERATE_FAIL)
1121   2              {
1122   3                falla++;
1123   3              }
1124   2               if (falla <= 2)
1125   2                
1126   2              {
1127   3                Debug_txt_Tibbo((unsigned char *) "ERROR OPERATE FAIL\r\n");
1128   3                Estado_expedidor = SEQ_POWER_ON;
1129   3                                    
1130   3              }
1131   2              else
1132   2              {
1133   3                falla=0;
1134   3                Debug_txt_Tibbo((unsigned char *) "TARJETA SIN FORMATO\r\n");
1135   3                send_portERR(PRMR_TARJETA_SIN_FORMATO);
1136   3                PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 20  

             -raspberry*/
1137   3               Estado_expedidor =Captura_Expulsa();   
1138   3              }
1139   2            }
1140   1            
1141   1        return Estado_expedidor;
1142   1      } 
1143          /*------------------------------------------------------------------------------
1144          
1145          ------------------------------------------------------------------------------*/
1146          
1147          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque2 (unsigned char *Atributos_Expedidor)
1148          {
1149   1        unsigned char temp;
1150   1        unsigned char Estado_expedidor;
1151   1        unsigned char buffer_S1_B2[17]; 
1152   1      
1153   1            
1154   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE2\r\n");   
1155   1            
1156   1                              
1157   1            
1158   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1159   1            {
1160   2              
1161   2                for (temp=0; temp<16; ++temp)
1162   2                {
1163   3                  buffer_S1_B2 [temp] =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion d
             -e MF en un arreglo*/
1164   3                }
1165   2                Debug_txt_Tibbo((unsigned char *) "Buffer_s1_b2\r\n");
1166   2                DebugBufferMF(buffer_S1_B2,16,RESPUESTA);
1167   2                
1168   2                      
1169   2                
1170   2                Debug_txt_Tibbo((unsigned char *) "HORARIO:");
1171   2                Debug_chr_Tibbo((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1172   2                *(Atributos_Expedidor + Horario)= ((buffer_S1_B2 [MF_TIPO_VEHICULO] & 0XF0) >> 4);
1173   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1174   2                
1175   2                Debug_txt_Tibbo((unsigned char *) "PICO Y PLACA:");
1176   2                
1177   2                *(Atributos_Expedidor + Pico_Placa)= ((buffer_S1_B2 [MF_IN_PAGO] & 0XF0) >> 4);
1178   2                Debug_chr_Tibbo(*(Atributos_Expedidor + Pico_Placa));
1179   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1180   2                
1181   2            
1182   2                Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK:");
1183   2                Debug_chr_Tibbo(buffer_S1_B2 [MF_APB] );
1184   2                Debug_txt_Tibbo((unsigned char *) "\r\n");
1185   2              
1186   2                /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
1187   2                
1188   2                *(Atributos_Expedidor + Apb)=   buffer_S1_B2 [MF_APB] ;
1189   2                
1190   2                
1191   2                  *(Atributos_Expedidor + Type_Vehiculo ) = buffer_S1_B2 [MF_TIPO_VEHICULO]& 0x0f;
1192   2                  Estado_expedidor =SEQ_TIPO_TARJETAS;    // Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);
1193   2            
1194   2        
1195   2            }
1196   1            else
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 21  

1197   1            {
1198   2              Estado_expedidor = Captura_Expulsa(); //momentario
1199   2            }
1200   1          return Estado_expedidor;  
1201   1      }
1202          
1203          unsigned char Responde_Lectura_Tarjeta_Sector1_Bloque0 (unsigned char *Nombre_Mensual)
1204          {
1205   1        unsigned char temp;
1206   1        unsigned char Estado_expedidor;
1207   1          
1208   1      
1209   1            
1210   1            Debug_txt_Tibbo((unsigned char *) "TAREA_LECTURA_TARJETA_SECTOR1_BLOQUE0\r\n");   
1211   1            
1212   1                              
1213   1            
1214   1            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1215   1            {
1216   2              
1217   2                for (temp=0; temp<16; ++temp)
1218   2                {
1219   3                  *(Nombre_Mensual + temp ) =Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informa
             -cion de MF en un arreglo*/
1220   3                }
1221   2                *(Nombre_Mensual + temp )=NULL;
1222   2                Debug_txt_Tibbo((unsigned char *) "Nombre Mensual:");
1223   2                Debug_txt_Tibbo(Nombre_Mensual );
1224   2                Debug_txt_Tibbo((unsigned char *) "\r\n");      
1225   2                Estado_expedidor = SEQ_PLACA;   //SEQ_TIPO_TARJETAS;                                                // Valida_Tipo_Tarjeta(Atr
             -ibutos_Expedidor,Buffer_Write_MF);
1226   2            
1227   2        
1228   2            }
1229   1            else
1230   1            {
1231   2              Estado_expedidor = Captura_Expulsa(); //momentario
1232   2            }
1233   1          return Estado_expedidor;  
1234   1      }
1235          unsigned char Responde_Write_Tarjeta_Sector1_Bloque1(unsigned char *Buffer_Write_MF)
1236          {
1237   1        unsigned char Estado_expedidor;
1238   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE1\r\n"); 
1239   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b1\r\n");
1240   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1241   1        Estado_expedidor = SEQ_TIPO_CARD;
1242   1        return Estado_expedidor;
1243   1      }
1244          unsigned char Responde_Write_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buf
             -fer_Write_MF)
1245          {
1246   1        unsigned char Estado_expedidor;
1247   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE2\r\n"); 
1248   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b2\r\n");
1249   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1250   1        if(MenSual !=  True)
1251   1        {
1252   2        *(Atributos_Expedidor + Sector) = Sector_1;
1253   2        *(Atributos_Expedidor + Bloque) = Bloque_0;
1254   2        Armar_Trama_Tarjeta_Sector1_Bloque0(Buffer_Write_MF);
1255   2          Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 22  

1256   2        }
1257   1        else
1258   1        {
1259   2          *(Atributos_Expedidor + Sector) = Sector_1;
1260   2          *(Atributos_Expedidor + Bloque) = Bloque_0;
1261   2          Estado_expedidor = SEQ_READ_SECTOR_BLOQUE;
1262   2          
1263   2        }
1264   1        return Estado_expedidor;
1265   1      }
1266          /*----------------------------------------------------------------------------
1267          ----------------------------------------------------------------------------*/
1268          unsigned char Responde_Write_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1269          {
1270   1      
1271   1        Debug_txt_Tibbo((unsigned char *) "TAREA_WRITE_TARJETA_SECTOR1_BLOQUE0\r\n"); 
1272   1        Debug_txt_Tibbo((unsigned char *) "Write_s1_b0\r\n");
1273   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1274   1        
1275   1        return SEQ_PLACA;         //SEQ_LPR
1276   1      }
1277          /*----------------------------------------------------------------------------
1278          ----------------------------------------------------------------------------*/
1279          unsigned char Responde_Write_Tarjeta_Sector2_Bloque0(unsigned char *Buffer_Write_MF)
1280          {
1281   1        
1282   1        Debug_txt_Tibbo((unsigned char *) "PLACA:");  
1283   1        Debug_txt_Tibbo((unsigned char *) placa);
1284   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1285   1        Debug_txt_Tibbo((unsigned char *) "Write_s2_b0\r\n");
1286   1        DebugBufferMF(Buffer_Write_MF,16,ENVIADOS);
1287   1        return SEQ_FRONT_CARD;
1288   1      }
1289          
1290          /*----------------------------------------------------------------------------
1291          ----------------------------------------------------------------------------*/
1292          unsigned char Pregunta_Lpr(unsigned char *Atributos_Expedidor)
1293          {
1294   1        unsigned char Estado_expedidor;
1295   1        Debug_txt_Tibbo((unsigned char *) "PREGUNTA LPR\r\n");
1296   1          if(rd_eeprom(0xa8,EE_USE_LPR)== True)
1297   1             {
1298   2               /*monitor trama*/
1299   2               Debug_txt_Tibbo(Armar_Trama_Monitor(Atributos_Expedidor));
1300   2                if (rd_eeprom(0xa8,EE_DEBUG) == False)
1301   2                 {
1302   3                   Debug_Tibbo=False;
1303   3                 }
1304   2             }
1305   1        
1306   1      
1307   1          Estado_expedidor=SEQ_LOAD_PASSWORD;         //SEQ_TIPO_TARJETAS;
1308   1      
1309   1        return Estado_expedidor;
1310   1      }
1311          unsigned char Pregunta_Placa()
1312          {
1313   1        unsigned char Estado_expedidor;
1314   1        Debug_txt_Tibbo((unsigned char *) "PREGUNTA PLACA\r\n");
1315   1          if (rd_eeprom(0xa8,EE_PLACA)!= False)
1316   1          {
1317   2            /*espero placa*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 23  

1318   2            Estado_expedidor=SEQ_WAIT_PLACA;
1319   2            ValTimeOutCom=TIME_WAIT ;
1320   2            Timer_wait=False;
1321   2          }
1322   1          else 
1323   1          {
1324   2          Estado_expedidor=SEQ_FRONT_CARD;
1325   2          }
1326   1        return Estado_expedidor;
1327   1      }
1328          unsigned char  Respuesta_Segunda_clave(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1329          {
1330   1        
1331   1        Debug_txt_Tibbo((unsigned char *) "TAREA_SEGUNDA CLAVE\r\n"); 
1332   1        DebugBufferMF(Buffer_Write_MF,16,RESPUESTA);
1333   1      
1334   1        
1335   1        *(Atributos_Expedidor + Sector) = Sector_2;
1336   1        *(Atributos_Expedidor + Bloque) = Bloque_0;
1337   1        Armar_Trama_Placa(Buffer_Write_MF);
1338   1          
1339   1        return SEQ_WRITE_SECTOR_BLOQUE;
1340   1      }
1341          unsigned char Respuesta_Placa_Cancel(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_MF)
1342          {
1343   1        unsigned char Estado_expedidor;
1344   1        unsigned char *Cancel="CANCEL";
1345   1        Debug_txt_Tibbo((unsigned char *) "RESPUESTA PLACA O CANCEL = "); 
1346   1        Debug_txt_Tibbo((unsigned char *) placa);
1347   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
1348   1        
1349   1        if(strcmp(placa,Cancel)== 0)
1350   1        {
1351   2          *(Atributos_Expedidor + Sector) = Sector_1;
1352   2          *(Atributos_Expedidor + Bloque) = Bloque_1;
1353   2          Armar_Trama_Tarjeta_Sector1_Bloque1_Camcel(Buffer_Write_MF);
1354   2          Estado_expedidor = SEQ_WRITE_SECTOR_BLOQUE;
1355   2        }
1356   1        else
1357   1        {
1358   2          if(MenSual ==  True)
1359   2          {
1360   3            Estado_expedidor = SEQ_FRONT_CARD;  
1361   3          }
1362   2          else
1363   2          {
1364   3            
1365   3            Estado_expedidor = SEQ_SECOND_PASSWORD;
1366   3          }     
1367   2        } 
1368   1        return Estado_expedidor;
1369   1      }
1370          /*------------------------------------------------------------------------------
1371          ------------------------------------------------------------------------------*/
1372          void  Armar_Trama_Tarjeta_Sector1_Bloque1_Camcel(unsigned char *Buffer_Write_MF)
1373          {
1374   1        unsigned char ID_CLIENTE;
1375   1        unsigned char COD_PARK; 
1376   1          /*cuando se recibe el CAMCEL se bloquea la tarjeta*/
1377   1        clear_placa();
1378   1        ID_CLIENTE=rd_eeprom(0xa8,EE_ID_CLIENTE); 
1379   1        COD_PARK=rd_eeprom(0xa8,EE_ID_PARK);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 24  

1380   1      
1381   1        *(Buffer_Write_MF + MF_TIPO_TARJETA)  = MENSUALIDAD;
1382   1        *(Buffer_Write_MF + MF_COD_PARK)      = COD_PARK; 
1383   1        *(Buffer_Write_MF + MF_COD_PARK+1)    = NULL;
1384   1        *(Buffer_Write_MF + MF_ID_CLIENTE)    = ID_CLIENTE;
1385   1        *(Buffer_Write_MF + MF_ID_CLIENTE+1)  = NULL;
1386   1        *(Buffer_Write_MF + MF_MENSUAL_ANO)   = NULL;
1387   1        *(Buffer_Write_MF + MF_MENSUAL_MES)   = NULL;
1388   1        *(Buffer_Write_MF + MF_MENSUAL_DIA)   = NULL;
1389   1        *(Buffer_Write_MF + MF_EXPIRA_ANO)    = NULL;
1390   1        *(Buffer_Write_MF + MF_EXPIRA_MES)    = NULL;
1391   1        *(Buffer_Write_MF + MF_EXPIRA_DIA)    = NULL;
1392   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+1)  = NULL;
1393   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+2)  = NULL;
1394   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+3)  = NULL;
1395   1        *(Buffer_Write_MF + MF_EXPIRA_DIA+4)  = NULL;
1396   1      }
1397          
1398          /*------------------------------------------------------------------------------
1399          ------------------------------------------------------------------------------*/
1400          
1401          void  Armar_Trama_Tarjeta_Sector1_Bloque2(unsigned char *Atributos_Expedidor,unsigned char *Buffer_Write_M
             -F)
1402          {
1403   1        
1404   1        /*fecha de ingreso se lee año,mes,dia,hora y minutos*/
1405   1        
1406   1        Block_read_Clock_Hex(Buffer_Write_MF);
1407   1        
1408   1        /*descuentos los borro*/
1409   1        
1410   1        *(Buffer_Write_MF + 5)=0;
1411   1        *(Buffer_Write_MF + 6)=0;
1412   1        *(Buffer_Write_MF + 7)=0;
1413   1        
1414   1        if (*(Atributos_Expedidor + Tipo_Tarjeta) == ROTACION)
1415   1        {
1416   2          *(Buffer_Write_MF + 8)  = Tipo_Vehiculo;
1417   2          *(Buffer_Write_MF + 9)  = (Dir_board())- 0x30;
1418   2          *(Buffer_Write_MF +10) = APB_INT;
1419   2        }
1420   1        
1421   1        /*mensual*/
1422   1        else
1423   1        {
1424   2          
1425   2          *(Buffer_Write_MF + 8)  = (*(Atributos_Expedidor + Horario) << 4) | (*(Atributos_Expedidor + Type_Vehicu
             -lo));
1426   2          *(Buffer_Write_MF + 9)  =  (*(Atributos_Expedidor + Pico_Placa) << 4)| (Dir_board())- 0x30;
1427   2          
1428   2          if (*(Atributos_Expedidor + Apb)== APB_NO)
1429   2           {
1430   3              *(Buffer_Write_MF +10) =APB_NO;
1431   3            }
1432   2          else 
1433   2          {
1434   3            *(Buffer_Write_MF +10) =APB_INT;
1435   3          }
1436   2        }
1437   1        /*fecha de salida maxima*/
1438   1        *(Buffer_Write_MF +11)=0;
1439   1        *(Buffer_Write_MF +12)=0;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 25  

1440   1        *(Buffer_Write_MF +13)=0;
1441   1        *(Buffer_Write_MF +14)=0;
1442   1        *(Buffer_Write_MF +15)=0;
1443   1      }
1444          void Armar_Trama_Tarjeta_Sector1_Bloque0(unsigned char *Buffer_Write_MF)
1445          {
1446   1        /*graba serie de Ticket*/
1447   1        strcpy(Buffer_Write_MF, Lee_No_Ticket());
1448   1      }
1449          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor(unsigned char *h)
1450          {
1451   1        static unsigned char buffer[28];
1452   1        unsigned char ticket[11];
1453   1        unsigned char j;
1454   1        /*la trama esta compuesta de
1455   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1456   1      
1457   1        buffer[0]=STX;
1458   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR;
1459   1        buffer[2]=NULL;
1460   1        strcpy(ticket, Lee_No_Ticket());
1461   1        strcat(buffer , ticket);
1462   1        j=strlen(buffer);
1463   1        
1464   1        buffer[j++]= '-';
1465   1        
1466   1        Block_read_Clock_Hex(buffer+j);         //leo la fecha de entrada
1467   1        buffer[j]=buffer[j]+0x030;              /*año de entrada*/
1468   1        buffer[j+1]=buffer[j+1]+0x030;          /*mes de entrada*/
1469   1        buffer[j+2]=buffer[j+2]+0x030;          /*dia de entrada*/
1470   1        buffer[j+3]=buffer[j+3]+0x030;          /*hora de entrada*/
1471   1        buffer[j+4]=buffer[j+4]+0x030;          /*minutos de entrada*/
1472   1        buffer[j+5]= '-';
1473   1        /*placa*/
1474   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1475   1        {   
1476   2          if (placa_ready != False)
1477   2          {
1478   3            buffer[j+6]= placa[0];
1479   3            buffer[j+7]= placa[1];
1480   3            buffer[j+8]= placa[2];
1481   3            buffer[j+9]= placa[3];
1482   3            buffer[j+10]= placa[4];
1483   3            buffer[j+11]= placa[5];
1484   3            buffer[j+12]= NULL;
1485   3          }
1486   2          else
1487   2          {
1488   3            buffer[j+6]= ' ';
1489   3            buffer[j+7]= NULL;
1490   3          }
1491   2        }
1492   1        else 
1493   1        {
1494   2          buffer[j+6]= ' ';
1495   2          buffer[j+7]=NULL;
1496   2        }
1497   1        j=strlen(buffer);
1498   1        buffer[j]= ETX;
1499   1        *h=j+1;
1500   1        
1501   1        return buffer;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 26  

1502   1      }
1503          unsigned char *Armar_Trama_Pto_Paralelo_Expedidor_Mensual(unsigned char *Atributos_Expedidor,unsigned char
             - *j)
1504          {
1505   1        static unsigned char buffer[28];
1506   1      
1507   1        /*la trama esta compuesta de
1508   1        STX,CMD,-,NoTICKET,-,FECHAINT,-,placa,ETX*/
1509   1      
1510   1        buffer[0]=STX;
1511   1        buffer[1]=CMD_PTO_PARALELO_EXPEDIDOR_MENSUAL;
1512   1        buffer[2]=*(Atributos_Expedidor + Uid_0);
1513   1        buffer[3]=*(Atributos_Expedidor + Uid_1);
1514   1        buffer[4]=*(Atributos_Expedidor + Uid_2);
1515   1        buffer[5]=*(Atributos_Expedidor + Uid_3);
1516   1        
1517   1        
1518   1        Block_read_Clock_Hex(buffer+6);         //leo la fecha de entrada
1519   1        buffer[6]=buffer[6]+0x030;              /*año de entrada*/
1520   1        buffer[7]=buffer[7]+0x030;          /*mes de entrada*/
1521   1        buffer[8]=buffer[8]+0x030;          /*dia de entrada*/
1522   1        buffer[9]=buffer[9]+0x030;          /*hora de entrada*/
1523   1        buffer[10]=buffer[10]+0x030;          /*minutos de entrada*/
1524   1      
1525   1        /*placa*/
1526   1        if (rd_eeprom(0xa8,EE_PLACA)!=0)
1527   1        {   
1528   2          
1529   2            buffer[11]= placa[0];
1530   2            buffer[12]= placa[1];
1531   2            buffer[13]= placa[2];
1532   2            buffer[14]= placa[3];
1533   2            buffer[15]= placa[4];
1534   2            buffer[16]= placa[5];
1535   2      
1536   2        }
1537   1      
1538   1        if(*(Atributos_Expedidor + Type_Vehiculo) == AUTOMOVIL )
1539   1        {
1540   2          buffer[17]= 'C';
1541   2        }
1542   1        else
1543   1        {
1544   2          buffer[17]= 'M';
1545   2        }
1546   1        
1547   1        buffer[18]= ETX;
1548   1        buffer[19]= NULL;
1549   1        *j=19;
1550   1        return buffer;
1551   1      }
1552          unsigned char *Armar_Trama_Monitor(unsigned char *Atributos_Expedidor)
1553          {
1554   1        static unsigned char buffer[24];
1555   1        unsigned char ticket[11];
1556   1        unsigned char j;
1557   1        /*la trama esta compuesta de
1558   1        STX,address_board,CMD,Tipo_Vehiculo,NoTICKET,:,fecha int añomesdishoraminuto,:,ETX*/
1559   1        Debug_Tibbo=False;
1560   1        buffer[0]=STX;
1561   1        buffer[1]=Dir_Board_Monitor();
1562   1        buffer[2]=CMD_MONITOR_EXPEDIDOR;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 27  

1563   1        if(Tipo_Vehiculo == AUTOMOVIL)
1564   1          {
1565   2            buffer[3]= 'C';
1566   2          }
1567   1        else
1568   1          {
1569   2            buffer[3]= 'M';
1570   2          }
1571   1          
1572   1          /*ticket*/
1573   1          if(MenSual !=  True)
1574   1          {
1575   2          buffer[4]=NULL;
1576   2          strcpy(ticket, Lee_No_Ticket());
1577   2          strcat(buffer , ticket);
1578   2          }
1579   1          else
1580   1          {
1581   2            ByteHex_Decimal(buffer+4,*(Atributos_Expedidor + Uid_2));
1582   2            j=strlen(buffer);
1583   2            buffer[j]= ' ';
1584   2            buffer[j+1]= NULL;
1585   2            j=strlen(buffer);
1586   2            Two_ByteHex_Decimal(buffer+j,*(Atributos_Expedidor + Uid_1),*(Atributos_Expedidor + Uid_0));
1587   2            
1588   2          }
1589   1          j=strlen(buffer);
1590   1          buffer[j]=':';
1591   1          /*fecha de entrada*/
1592   1          
1593   1          Block_read_clock_ascii(buffer+j+1);     //leo la fecha de entrada
1594   1          j=strlen(buffer);
1595   1        
1596   1          buffer[j]= ':';
1597   1          buffer[j+1]=ETX;
1598   1          buffer[j+2]=NULL;
1599   1          Debug_Tibbo=True;
1600   1        return buffer;
1601   1      }
1602          void Armar_Trama_Placa(unsigned char *Buffer_Write_MF)
1603          {
1604   1        unsigned char j;
1605   1        unsigned char len_placa;
1606   1        len_placa = strlen(placa);
1607   1          for(j=0; j<len_placa;j++)
1608   1          {
1609   2          *(Buffer_Write_MF +j)=placa[j];
1610   2          }
1611   1            for (j=len_placa; j<16; j++)            
1612   1          {
1613   2            *(Buffer_Write_MF +j)=0x00;
1614   2          }
1615   1      }
1616          unsigned char Load_Secuencia_Expedidor(unsigned char *Secuencia_Expedidor,unsigned const  estadoactivo,uns
             -igned const estadoactual,unsigned const estadofuturo)
1617          {
1618   1        *(Secuencia_Expedidor + EstadoPasado ) = estadoactivo ;
1619   1        *(Secuencia_Expedidor + EstadoActual ) = estadoactual;
1620   1        *(Secuencia_Expedidor + EstadoFuturo ) = estadofuturo;
1621   1        return estadoactual;
1622   1      }
1623          unsigned char Disparo_Lock_Entrada_Vehiculo(unsigned char *Nombre_Mensual)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 28  

1624          {
1625   1        unsigned char Estado_expedidor;
1626   1        static unsigned char take_card=6;
1627   1        
1628   1        
1629   1        Debug_txt_Tibbo((unsigned char *) "TAKE CARD\r\n");
1630   1        
1631   1        //PantallaLCD(RETIRE_TARJETA);
1632   1        
1633   1        if (Buffer_Rta_Lintech[Pos_St0]==NO_CARDS_IN_MCNSM)                                   // CANAL LIBRE    no tiene tarjetas 
             -en el mecanismo
1634   1          {
1635   2            
1636   2            Debug_txt_Tibbo((unsigned char *) "TAREA_OPEN_BARRERA\r\n");
1637   2              
1638   2            take_card=6;
1639   2            lock=ON;
1640   2            send_portERR(BIENVENIDO);
1641   2            PantallaLCD_LINEA_2(BIENVENIDO,Nombre_Mensual);
1642   2            Estado_expedidor=SEQ_PTO_PARALELO;
1643   2            
1644   2            
1645   2          }
1646   1        else if (Buffer_Rta_Lintech[Pos_St0]==CARD_IN_MOUTH)                                      //  se detecta la tarjeta en la b
             -oca TARJETA EN BEZZEL
1647   1        {
1648   2          if(Valida_Sensor1_Auto()!= False)
1649   2          {
1650   3            if(take_card >= 6)
1651   3                  { PantallaLCD(RETIRE_TARJETA);
1652   4                    take_card=0;
1653   4                  }
1654   3                  else
1655   3                   {
1656   4                     take_card++;
1657   4                       
1658   4                   }
1659   3            
1660   3            ValTimeOutCom=TIME_PULSADOR;
1661   3            Estado_expedidor=SEQ_DETAIL_CARD;
1662   3            
1663   3          }
1664   2          else
1665   2          {
1666   3            Estado_expedidor=SEQ_CAPTURE_CARD;
1667   3          }
1668   2        
1669   2        }
1670   1        
1671   1          
1672   1        
1673   1        
1674   1        return Estado_expedidor;
1675   1      }
1676          unsigned char Send_Pto_Paralelo(unsigned char *Atributos_Expedidor)
1677          {
1678   1        unsigned char *Trama_Expedidor ;
1679   1        unsigned char leng_trama_pto;
1680   1        if(MenSual == True)
1681   1        {
1682   2        Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor_Mensual(Atributos_Expedidor,&leng_trama_pto );
1683   2        }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 29  

1684   1        else 
1685   1        {
1686   2          Trama_Expedidor=Armar_Trama_Pto_Paralelo_Expedidor(&leng_trama_pto);
1687   2          Incremente_Ticket();
1688   2        }
1689   1        
1690   1        send_port(Trama_Expedidor,leng_trama_pto);  
1691   1        Debug_txt_Tibbo((unsigned char *) "Trama_pto_paralelo: ");
1692   1        DebugBufferMF(Trama_Expedidor,leng_trama_pto,SIN_MSJ  );
1693   1        
1694   1        
1695   1        
1696   1        clear_placa();
1697   1        ValTimeOutCom=TIME_WAIT ;
1698   1        Timer_wait=0;
1699   1        PULSADOR_BOTTON = 0;
1700   1        return SEQ_ESPERA_VEHICULO_ENTRE;
1701   1      }
1702          
1703          /*------------------------------------------------------------------------------
1704          ------------------------------------------------------------------------------*/
1705          unsigned char Entrega_Card_Captura()
1706          {
1707   1        unsigned char Estado_expedidor;
1708   1        
1709   1          
1710   1        Debug_txt_Tibbo((unsigned char *) "ESPERA VEHICULO ENTRE\r\n"); 
1711   1        sel_Sensor2();                                //garantiso q la barrera se encuentre en posicion baja  
1712   1        if ((DataIn==0))        
1713   1        {  
1714   2          if (ValidaSensor()==0)
1715   2          {
1716   3            lock=OFF;
1717   3            pto_paraleo=False;
1718   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo Entrando OFF_BARRERA\r\n");
1719   3            Estado_expedidor=SEQ_INICIO;
1720   3          }
1721   2          
1722   2        }
1723   1        else
1724   1        {
1725   2            if(Valida_Sensor1_Auto()!= False)
1726   2            {
1727   3            /*presencia vehicular*/
1728   3              Estado_expedidor=SEQ_ESPERA_VEHICULO_ENTRE;//SEQ_INICIO;//
1729   3              
1730   3              if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1731   3              {
1732   4                  if (Timer_wait >= 5)
1733   4               {
1734   5                 pto_paraleo=False;
1735   5                 Debug_txt_Tibbo((unsigned char *) "Vehiculo TIEMPO OFF_BARRERA\r\n");
1736   5                
1737   5                 lock=OFF;
1738   5                 Estado_expedidor=SEQ_INICIO;;
1739   5               }
1740   4              else if (Timer_wait <= 4)
1741   4               {
1742   5                ValTimeOutCom=TIME_WAIT ;
1743   5               }
1744   4             }
1745   3              
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 30  

1746   3            }
1747   2            else
1748   2            {
1749   3            pto_paraleo=False;
1750   3            Debug_txt_Tibbo((unsigned char *) "Vehiculo NO LOOP OFF_BARRERA\r\n");
1751   3            lock=OFF;
1752   3            Estado_expedidor=SEQ_INICIO;
1753   3            }
1754   2        } 
1755   1       
1756   1        return Estado_expedidor;
1757   1      }
1758          unsigned char Wait_Placa(unsigned char *Atributos_Expedidor, unsigned char *Buffer_Write_MF)
1759          {
1760   1        unsigned char Estado_expedidor;
1761   1        
1762   1          Debug_txt_Tibbo((unsigned char *) "Wait_Placa");
1763   1        /*espera la llega de placa o cancel*/
1764   1        while ((ValTimeOutCom != 1) && (ValTimeOutCom <= TIME_WAIT) && (placa_ready == False))
1765   1        {
1766   2          if (rx_ip==0)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
1767   2              {
1768   3                
1769   3                Rx_Monitor();
1770   3              }
1771   2        }
1772   1          /*llego Cancel o placa*/
1773   1          if(placa_ready!=False)
1774   1            {
1775   2              Estado_expedidor = Respuesta_Placa_Cancel(Atributos_Expedidor,Buffer_Write_MF);
1776   2            }
1777   1            else
1778   1              /*no llego placa o cancel*/
1779   1            {
1780   2                Estado_expedidor=SEQ_WAIT_PLACA;
1781   2             if ((ValTimeOutCom == 1) || (ValTimeOutCom > TIME_WAIT))
1782   2             {  
1783   3              if (Timer_wait >= 5)
1784   3               {
1785   4                 strcpy (placa,"NOPLATE");
1786   4                 Estado_expedidor=SEQ_SECOND_PASSWORD;        //SEQ_FRONT_CARD;
1787   4               }
1788   3              else if (Timer_wait <= 4)
1789   3               {
1790   4                ValTimeOutCom=TIME_WAIT ;
1791   4               }
1792   3             }
1793   2            }
1794   1        return Estado_expedidor;
1795   1      }
1796          unsigned char Valida_Vehiculo_Card_Mensual(unsigned char *Atributos_Expedidor)
1797          {
1798   1        unsigned char Estado_expedidor;
1799   1        
1800   1          Debug_txt_Tibbo((unsigned char *) "VEHICULO MENSUAL TARJETA: ");
1801   1          if(*(Atributos_Expedidor + Type_Vehiculo  ) == False)
1802   1           {
1803   2            Debug_txt_Tibbo((unsigned char *) "(0) CARRO");
1804   2           }
1805   1          else
1806   1           {
1807   2            Debug_txt_Tibbo((unsigned char *) "(1) MOTO");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 31  

1808   2           }
1809   1                            
1810   1          Debug_txt_Tibbo((unsigned char *) "\r\n");
1811   1        if ((rd_eeprom(0xa8,EE_VALIDA_TIPO_VEHICULO_MENSUAL)) != True) 
1812   1        {
1813   2          if  (*(Atributos_Expedidor + Type_Vehiculo  ) == Tipo_Vehiculo )          
1814   2          {
1815   3           Debug_txt_Tibbo((unsigned char *) "COINCIDE CARD CON LOOK\r\n ");
1816   3            Estado_expedidor = True ;
1817   3          }
1818   2          
1819   2          else
1820   2          {
1821   3            send_portERR(PRMR_ERROR_TIPO_VEHICULO); 
1822   3            Debug_txt_Tibbo((unsigned char *) "TIPO DE VEHICULO NO CORRESPONDE\r\n ");
1823   3            Estado_expedidor = False; 
1824   3          }
1825   2        } 
1826   1        else 
1827   1        {
1828   2            Debug_txt_Tibbo((unsigned char *) "NO INTERESA COINCIDENCIA CARD CON LOOK\r\n ");
1829   2            Estado_expedidor = True ;
1830   2        }
1831   1          return Estado_expedidor;
1832   1      }
1833          unsigned char Tarjeta_Mensual(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1834          {
1835   1        unsigned char Estado_expedidor;
1836   1      //  unsigned char fecha_asii[7];
1837   1        
1838   1        /*cheque la fecha de expiracion del mensual*/
1839   1        if (Horarios(Atributos_Expedidor) == True)
1840   1        {
1841   2         if ( check_fechaOut(Atributos_Expedidor+Expira_ano) == True )
1842   2            {
1843   3              /*valida el vehiculo en el loop y en la card*/
1844   3              if( Valida_Vehiculo_Card_Mensual(Atributos_Expedidor) == False)
1845   3              {
1846   4              Estado_expedidor = Captura_Expulsa();   
1847   4              }
1848   3              else
1849   3              {
1850   4                Debug_txt_Tibbo((unsigned char *) "MENSUAL AL DIA\r\n");  
1851   4                *(Atributos_Expedidor + Sector) = Sector_1;
1852   4                *(Atributos_Expedidor + Bloque) = Bloque_2;
1853   4                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1854   4                Estado_expedidor=SEQ_WRITE_SECTOR_BLOQUE;
1855   4              }
1856   3            }
1857   2            else 
1858   2            {
1859   3              send_portERR(PRMR_TARJETA_VENCIDA); 
1860   3                  
1861   3              PantallaLCD(TARJETA_VENCIDA);
1862   3              Debug_txt_Tibbo((unsigned char *) "MENSUAL EXPIRA\r\n");
1863   3              Estado_expedidor = SEQ_EXPULSAR_CARD;
1864   3            }
1865   2        }
1866   1        else
1867   1        {
1868   2          
1869   2          Estado_expedidor = SEQ_EXPULSAR_CARD;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 32  

1870   2        }
1871   1        return Estado_expedidor;
1872   1      }
1873          unsigned char Tarjeta_Rotacion(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1874          {
1875   1              *(Atributos_Expedidor + Sector) = Sector_1;
1876   1                *(Atributos_Expedidor + Bloque) = Bloque_2;
1877   1                Armar_Trama_Tarjeta_Sector1_Bloque2(Atributos_Expedidor,Buffer_Write_MF);
1878   1                return  SEQ_WRITE_SECTOR_BLOQUE;
1879   1        
1880   1        
1881   1      }
1882          unsigned char Valida_Tipo_Tarjeta(unsigned char *Atributos_Expedidor,unsigned  char *Buffer_Write_MF )
1883          {
1884   1        unsigned char Estado_expedidor;
1885   1        if(*(Atributos_Expedidor + Tipo_Tarjeta) ==  MENSUALIDAD)
1886   1        {
1887   2          Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA MENSUALIDAD\r\n ");
1888   2          if(MenSual ==  True)
1889   2          {
1890   3          
1891   3          /*APB Habilitado por software*/
1892   3          
1893   3            if( (rd_eeprom(0xa8,EE_HABILITA_APB_MENSUAL) == APB_HABILITADO_SOFT) )
1894   3            {
1895   4              /*APB por Card*/
1896   4           
1897   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO))       
1898   4              {
1899   5                Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1900   5      
1901   5              }
1902   4              else
1903   4              {
1904   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK MENSUAL \r\n");
1905   5                send_portERR(PRMR_SIN_SALIDA);
1906   5                Estado_expedidor = Captura_Expulsa(); 
1907   5              } 
1908   4            }
1909   3          
1910   3          else
1911   3          {
1912   4            Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO MENSUAL \r\n");
1913   4          
1914   4           Estado_expedidor = Tarjeta_Mensual(Atributos_Expedidor,Buffer_Write_MF );
1915   4          }
1916   3        }
1917   2        else
1918   2         {
1919   3          send_portERR(PRMR_NO_CARD_MENSUAL);
1920   3          PantallaLCD(NO_CARD_MENSUAL);     
1921   3          Estado_expedidor = Captura_Expulsa(); 
1922   3         } 
1923   2       }
1924   1        else if (*(Atributos_Expedidor + Tipo_Tarjeta) ==  ROTACION)
1925   1        {
1926   2          
1927   2            Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA ROTACION\r\n ");
1928   2          if(MenSual != True)
1929   2          {
1930   3            if ( (rd_eeprom(0xa8,EE_HABILITA_APB))!= APB_INHABILITADO_SOFT)
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 33  

1931   3            {
1932   4              if((*(Atributos_Expedidor + Apb) == APB_OUT)||(*(Atributos_Expedidor + Apb) == APB_INICIADO) || (*(Atr
             -ibutos_Expedidor + Apb) == APB_NO) )
1933   4                                    
1934   4              {
1935   5                Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
1936   5              }
1937   4              else
1938   4              {
1939   5                Debug_txt_Tibbo((unsigned char *) "ERROR: INT ANTIPASSBACK ROTACION \r\n");
1940   5                send_portERR(PRMR_SIN_SALIDA);
1941   5                PantallaLCD(SIN_SALIDA);
1942   5                Estado_expedidor = Captura_Expulsa();
1943   5              }
1944   4            }
1945   3            else
1946   3            {
1947   4              Debug_txt_Tibbo((unsigned char *) "ANTIPASSBACK INHABILITADO ROTACION \r\n");
1948   4              Estado_expedidor = Tarjeta_Rotacion(Atributos_Expedidor,Buffer_Write_MF );
1949   4            } 
1950   3          }
1951   2          else
1952   2          {
1953   3            /*tarjeta por insercion por boca */ 
1954   3            send_portERR(PRMR_NO_CARD_MENSUAL);
1955   3            PantallaLCD(NO_CARD_MENSUAL);     
1956   3            Estado_expedidor = SEQ_EXPULSAR_CARD;       //Captura_Expulsa();    
1957   3          }
1958   2        }
1959   1        else
1960   1        {
1961   2          Debug_txt_Tibbo((unsigned char *) "TIPO NUEVO DE TARJETA SIN DEFINIR\r\n ");
1962   2          send_portERR(PRMR_NO_ROTACION);
1963   2          
1964   2          Estado_expedidor = Captura_Expulsa();   
1965   2        }
1966   1        
1967   1        return Estado_expedidor;
1968   1      }
1969          /*
1970          unsigned char Festivos()
1971          {
1972            
1973            unsigned char dia_semana,day, month, year,DiaFestivo=0;
1974          
1975            
1976            dia_semana=bcd_hex(lee_clk(RDIA_SEMANA));
1977            day = bcd_hex(lee_clk(RDIA));
1978            month = bcd_hex(lee_clk(RMES));
1979            year = bcd_hex(lee_clk(RANO));
1980            
1981            if (year==20)
1982            {
1983              if (((month==1)&&(day==1))||((month==1)&&(day==6))||((month==3)&&(day==23))||((month==4)&&(day==9))||((m
             -onth==4)&&(day==10))||((month==5)&&(day==1))||((month==5)&&(day==25))||((month==6)&&(day==3)))  
1984              {
1985                DiaFestivo = True;
1986                }
1987              else if (((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==17))||((month==10)&&(day==1
             -2))||((month==11)&&(day==2))||((month==11)&&(day==16))||((month==12)&&(day==8))||((month==12)&&(day==25)))
1988              {
1989                DiaFestivo = True;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 34  

1990              }
1991          
1992            }
1993            else if (year==21)
1994            {
1995              if (((month==1)&&(day==1))||((month==1)&&(day==11))||((month==3)&&(day==22))||((month==4)&&(day==1))||((
             -month==4)&&(day==2))||((month==5)&&(day==1))||((month==5)&&(day==17))||((month==6)&&(day==7))||((month==6)&&(day==14))) 
1996              {
1997                DiaFestivo = True;
1998                }
1999              else if (((month==7)&&(day==5))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==16)
             -)||((month==10)&&(day==18))||((month==11)&&(day==1))||((month==11)&&(day==15))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
2000              {
2001                DiaFestivo = True;
2002              }
2003          
2004            }
2005            else if (year==22)
2006            {
2007              if (((month==1)&&(day==1))||((month==1)&&(day==10))||((month==3)&&(day==21))||((month==4)&&(day==14))||(
             -(month==4)&&(day==15))||((month==5)&&(day==1))||((month==5)&&(day==30))||((month==6)&&(day==20))||((month==6)&&(day==27)
             -))  
2008              {
2009                DiaFestivo = True;
2010                }
2011              else if (((month==7)&&(day==4))||((month==7)&&(day==20))||((month==8)&&(day==7))||((month==8)&&(day==15)
             -)||((month==10)&&(day==17))||((month==11)&&(day==7))||((month==11)&&(day==14))||((month==12)&&(day==8))||((month==12)&&(
             -day==25)))
2012              {
2013                DiaFestivo = True;
2014              }
2015          
2016            
2017            
2018            }
2019            if ((dia_semana == Sabado)||(dia_semana == Domingo)||(DiaFestivo == True))
2020            {
2021              DiaFestivo = True;
2022            }
2023            else
2024            {
2025              DiaFestivo = False;
2026            }
2027            return DiaFestivo;
2028          }
2029          */
2030          /*
2031          unsigned char Dia_Pico_Placa(unsigned char * Atributos_Expedidor)
2032          {
2033            unsigned char Par_Impar;
2034            unsigned char dato;
2035            
2036            if( Festivos() == False)
2037            {
2038            dato=lee_clk(RDIA);
2039          
2040              if((dato % 2 == False) && (*(Atributos_Expedidor + Pico_Placa)  == True))
2041              {
2042              
2043              /*es par*/
2044          /*
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 35  

2045              Par_Impar = True;
2046              
2047              }
2048              else
2049              {
2050              /*es impar */
2051              /*
2052              Par_Impar = False;
2053              }
2054            }
2055            else
2056            {
2057              Par_Impar = True;
2058            }
2059            return Par_Impar;
2060          }
2061          */
2062          unsigned char Horarios(unsigned char * Atributos_Expedidor)
2063          {
2064   1        unsigned char Estado_Horario;
2065   1        
2066   1        unsigned char Addr_horarios [11];
2067   1        unsigned char dia_semana,EE_dia_semana;
2068   1        unsigned int addr;
2069   1        if (*(Atributos_Expedidor + Horario) != False )
2070   1        {
2071   2          /*se Lee la direccion del horario*/
2072   2          strcpy (Addr_horarios,(Addr_Horarios()));
2073   2          
2074   2          addr= Addr_horarios[(*(Atributos_Expedidor + Horario)) -1] ;
2075   2          
2076   2           /*leemos si esta habilitado*/
2077   2          
2078   2          if ((rd_eeprom(0xa8,addr + HABILITA_ADDR)) == True)
2079   2          {
2080   3            /*miramos si el dia de la semana esta habilitado*/
2081   3            dia_semana = lee_clk(RDIA_SEMANA);
2082   3            Debug_txt_Tibbo((unsigned char *) "DIA DE LA SEMANA: ");
2083   3            Debug_chr_Tibbo(dia_semana);
2084   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
2085   3            
2086   3          
2087   3            EE_dia_semana = rd_eeprom(0xa8,addr + dia_semana - 1 ) -0x30;
2088   3            Debug_txt_Tibbo((unsigned char *) "DIA PROGRAMADO: ");
2089   3            Debug_chr_Tibbo(EE_dia_semana);
2090   3            Debug_txt_Tibbo((unsigned char *) "\r\n");
2091   3          
2092   3            if ( EE_dia_semana == dia_semana)
2093   3            {
2094   4              /*miramos si esta en el rango del horario*/
2095   4              Estado_Horario = Bloque_Horario(addr);
2096   4            }
2097   3            else
2098   3            {
2099   4      
2100   4              Debug_txt_Tibbo((unsigned char *) "HORARIO DEL DIA NO PROGRAMADO\r\n");
2101   4              Estado_Horario= False;
2102   4            }
2103   3          }
2104   2          else 
2105   2          {
2106   3            
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 36  

2107   3            Estado_Horario= False;
2108   3            PantallaLCD(HORARIO_NO_PROG);
2109   3            Debug_txt_Tibbo((unsigned char *) "INHABILITADO HORARIO \r\n");
2110   3            
2111   3          }
2112   2          
2113   2        }
2114   1        else
2115   1        {
2116   2          Estado_Horario = True;
2117   2        
2118   2          Debug_txt_Tibbo((unsigned char *) "NO TIENE HORARIO PROGRAMADO\r\n");
2119   2        }
2120   1        return Estado_Horario;
2121   1      }
2122          unsigned int Hora_Maxima(unsigned int addr)
2123          {
2124   1        unsigned char Hora_High,  Minuto_High;
2125   1        unsigned char HoraIni , MinutoIni; 
2126   1        unsigned int  Hora_Prog;
2127   1        
2128   1         Hora_High    = (rd_eeprom(0xa8, (addr + Hora_High_addr_Desde )) - 0x30)  << 4;
2129   1         HoraIni      = Hora_High | ((rd_eeprom(0xa8, (addr + Hora_Low_addr_Desde ))) - 0x30);
2130   1         Minuto_High  = ((rd_eeprom(0xa8, (addr + Minutos_High_addr_Desde ))) - 0x30)  << 4;
2131   1         MinutoIni    =  Minuto_High | ((rd_eeprom(0xa8, (addr +  Minutos_Low_addr_Desde ))) - 0x30);
2132   1         Debug_chr_Tibbo(HoraIni);
2133   1         Debug_chr_Tibbo(MinutoIni);
2134   1         Debug_txt_Tibbo((unsigned char *) "\r\n");
2135   1        
2136   1         return Hora_Prog = (HoraIni *60) + (MinutoIni ) ;
2137   1      }
2138          unsigned char En_Horario(unsigned int HoraNow, unsigned int Hora_Prog,unsigned int addr)
2139          {
2140   1        unsigned char Estado_Horario; 
2141   1        
2142   1        if( Hora_Prog  <=  HoraNow )        //HoraNow >=  Hora_Prog 
2143   1        {
2144   2          
2145   2          /*hasta la hora que puede ingresar el vehiculo */
2146   2          Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA HASTA: ");
2147   2          Hora_Prog = Hora_Maxima(addr+4);
2148   2      
2149   2        
2150   2          if( HoraNow <= Hora_Prog)
2151   2          {
2152   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2153   3            Debug_txt_Tibbo((unsigned char *) "EN HORARIO PROGRAMADO\r\n");
2154   3            Estado_Horario = True;
2155   3          }
2156   2          else
2157   2          {
2158   3            //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2159   3            //PantallaLCD(MENSUAL_FUERA_HORARIO);
2160   3            Debug_txt_Tibbo((unsigned char *) "DESPUES DEL HORARIO PROGRAMADO\r\n");
2161   3            Estado_Horario = False;
2162   3          }
2163   2          
2164   2        }
2165   1        else
2166   1        {
2167   2              //send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2168   2              //PantallaLCD(MENSUAL_FUERA_HORARIO);
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 37  

2169   2              Debug_txt_Tibbo((unsigned char *) "ANTES DEL HORARIO PROGRAMADO\r\n");
2170   2              Estado_Horario = False;
2171   2            
2172   2        }
2173   1        return Estado_Horario;
2174   1      }
2175          
2176          unsigned Bloque_Horario(unsigned int addr)
2177          {
2178   1        unsigned char Estado_Horario; 
2179   1        unsigned int HoraNow, Hora_Prog;
2180   1        
2181   1        /*la hora del momento de entrada del vehiculo*/
2182   1        
2183   1        Debug_txt_Tibbo((unsigned char *) "HORA AHORA: ");
2184   1        Debug_chr_Tibbo(lee_clk(RHORA));
2185   1        Debug_chr_Tibbo(lee_clk(RMIN));
2186   1        Debug_txt_Tibbo((unsigned char *) "\r\n");
2187   1        HoraNow = (lee_clk(RHORA) * 60) + (lee_clk(RMIN) );
2188   1        
2189   1        /* desde la hora en que puede ingresar vehiculo */
2190   1        
2191   1        
2192   1        Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA DESDE: ");
2193   1        Hora_Prog = Hora_Maxima(addr);
2194   1        Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr);
2195   1        if(Estado_Horario == False )
2196   1        {
2197   2          
2198   2            
2199   2            if(rd_eeprom(0xa8,addr + Segundo_Tiempo ) == True)
2200   2            {
2201   3              Debug_txt_Tibbo((unsigned char *) "HORA PROGRAMADA SEGUNDA DESDE: ");
2202   3              Hora_Prog = Hora_Maxima(addr+10);
2203   3              Estado_Horario=En_Horario(HoraNow,Hora_Prog,addr+10);
2204   3            }
2205   2            else
2206   2            {
2207   3              send_portERR(PRMR_MENSUAL_FUERA_HORARIO);
2208   3              PantallaLCD(MENSUAL_FUERA_HORARIO);
2209   3              Estado_Horario = False;
2210   3            }
2211   2        }
2212   1      
2213   1      return Estado_Horario;
2214   1      }
2215          
2216          /*------------------------------------------------------------------------------
2217          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
2218          
2219          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
2220          ------------------------------------------------------------------------------*/
2221          
2222          
2223          unsigned char  Secuencia_inicio_expedidor(void)
2224          {
2225   1        char temp;
2226   1        switch (Estado)
2227   1        {
2228   2          case INICIA_LINTECH:
2229   2      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 38  

2230   2                
2231   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
2232   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
2233   2              
2234   2            
2235   2            return (Estado);
2236   2          break;
2237   2      
2238   2      
2239   2      /*------------------------------------------------------------------------------
2240   2      Envia la primera trama de inicializacion del transporte sin movimiento
2241   2            (0) LA RESPUESTA ES OK
2242   2            (1) NO RESPONDE EL PTO SERIE
2243   2            (2) NO RECIBIDO LA TRAMA 
2244   2            (3) ERROR DE TRAMA CMD (N)
2245   2      ------------------------------------------------------------------------------*/
2246   2            
2247   2          case SEQ_CAPTURE_DATOS_INI:
2248   2      
2249   2            if((temp=Trama_Validacion_P_N())!=0)
2250   2          {
2251   3            if(temp==2)
2252   3            {
2253   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
2254   4            } 
2255   3            else if (temp==3)
2256   3            {
2257   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
2258   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2259   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2260   4            }
2261   3            else
2262   3            {
2263   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2264   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
2265   4            }
2266   3          }
2267   2          else
2268   2          {
2269   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
2270   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2271   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
2272   3          }     
2273   2          return (Estado);
2274   2          break;
2275   2            
2276   2      /*------------------------------------------------------------------------------
2277   2      Envia el cmd de grabar claves a la eeprom del transporte 
2278   2      ------------------------------------------------------------------------------*/
2279   2            
2280   2            case GRABA_EEPROM:
2281   2              
2282   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
2283   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
2284   2            
2285   2            
2286   2      
2287   2            return (Estado);
2288   2              break;
2289   2        
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 39  

2290   2      /*------------------------------------------------------------------------------
2291   2      se analiza la respuesta 
2292   2            (0) LA RESPUESTA ES OK
2293   2            (1) NO RESPONDE EL PTO SERIE
2294   2            (2) NO RECIBIDO LA TRAMA 
2295   2            (3) ERROR DE TRAMA CMD (N)
2296   2      ------------------------------------------------------------------------------*/
2297   2            
2298   2          case SEQ_CAPTURA_OK_EEPROM:
2299   2          
2300   2          if((temp=Trama_Validacion_P_N())!=0)
2301   2          {
2302   3            if(temp==2)
2303   3            {
2304   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
2305   4            }
2306   3            else if (temp==3)
2307   3            {
2308   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
2309   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
2310   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
2311   4            }     
2312   3            else
2313   3            {
2314   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
2315   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
2316   4            }       
2317   3          }
2318   2          else
2319   2          {
2320   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
2321   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
2322   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
2323   3          }     
2324   2      
2325   2          return (Estado);
2326   2          break;
2327   2      
2328   2      /*------------------------------------------------------------------------------
2329   2      Fin de la secuencia de comandos con exito 
2330   2      ------------------------------------------------------------------------------*/    
2331   2            
2332   2              case FIN_OK:
2333   2      
2334   2              return (Estado);
2335   2          break;
2336   2            
2337   2                
2338   2              default:
2339   2              return Estado=INICIA_LINTECH; 
2340   2              break;
2341   2        }
2342   1      }
2343          
2344          /*------------------------------------------------------------------------------
2345          Prosedimiento  q hace paso a paso la secuencia de la MF
2346          atributos
2347          ValTimeOutCom = tiempo que  espera para recibir datos pto serie
2348          Tarjeta_on = detecto vehiculo en loop y tiene tarjeta en boca
2349          g_cEstadoComSeqMF = nos dice en el estado que nos encontramos dentro del seguimiento
2350          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 40  

2351          
2352          unsigned char SecuenciaExpedidorMF( unsigned char EstadoActivo)
2353          {
2354   1        static unsigned char Buffer_Write_MF[17];
2355   1        static unsigned char Atributos_Expedidor[15];
2356   1        static unsigned char Secuencia_Expedidor[4];
2357   1        static unsigned char Nombre_Mensual[17];
2358   1        
2359   1        switch (EstadoActivo)
2360   1        {
2361   2      //***********************************************************************************************
2362   2          
2363   2          case SEQ_INICIO:
2364   2      
2365   2            if ((ValTimeOutCom == True)|| (ValTimeOutCom > TIME_CARD))
2366   2            {
2367   3              
2368   3              
2369   3              lock=OFF;                                                                                   /*rele de disparo a la barrera*/
2370   3              Atascado_GP0_PIN_3 = OFF;                                                                          /*activo el rele de reset del verificad
             -or logica negativa*/    
2371   3              Check_Status(SENSOR_NORMAL);                                                              /* se pregunta al transporte en q estado es
             -tan las TI*/
2372   3              EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_
             -TRANSPORTE);
2373   3              Secuencia_Expedidor [ TareadelCmd  ] = TAREA_PRESENCIA_VEHICULAR;
2374   3            }else
2375   2              {
2376   3              if (rx_ip==False)                                                         /*pregunto si llega datos de monitor pto serie emulado*/
2377   3                {
2378   4                 Rx_Monitor();
2379   4                }
2380   3              }
2381   2            
2382   2            break;
2383   2          case  SEQ_CMD_ACEPTADO:
2384   2          /*cmd comun para todos*/
2385   2            EstadoActivo=rta_cmd_transporte(Secuencia_Expedidor);
2386   2            break;
2387   2          case SEQ_MOVER_CARD_RF:
2388   2            Mov_Card(MovPos_RF);
2389   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_TIPO_CARD);
2390   2            break;
2391   2          case SEQ_CARD_INSERCION_ON:
2392   2            Card_Insercion(Habilita); 
2393   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2394   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_MENSUAL;
2395   2            break;
2396   2          case SEQ_TIPO_CARD:
2397   2            Aut_Card_check_Status();
2398   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2399   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_TIPO_TARJETA;
2400   2            break;
2401   2          case SEQ_LOAD_PASSWORD:
2402   2            LoadVerify_EEprom();
2403   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECTOR
             -_BLOQUE);
2404   2            Atributos_Expedidor [ Sector ]    = Sector_1;
2405   2            Atributos_Expedidor [ Bloque ]    = Bloque_1;
2406   2            break;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 41  

2407   2          case SEQ_READ_SECTOR_BLOQUE:
2408   2            RD_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ]);
2409   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2410   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_LECTURA_TARJETA_SECTOR_BLOQUE;
2411   2            break;
2412   2          case SEQ_WRITE_SECTOR_BLOQUE:
2413   2            WR_MF(Atributos_Expedidor [ Sector ],Atributos_Expedidor [ Bloque ],Buffer_Write_MF);
2414   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);
2415   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_WRITE_TARJETA_SECTOR_BLOQUE;
2416   2            break;
2417   2          case SEQ_CAPTURE_CARD:
2418   2            Mov_Card(MovPos_Capture);
2419   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);     
             -//SEQ_INICIOSEQ_MOVER_CARD_RF
2420   2            break;
2421   2          case SEQ_CARD_INSERCION_OFF:
2422   2            Card_Insercion(Inhabilita);
2423   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_EXPULSAR_CA
             -RD);
2424   2            break;
2425   2          case SEQ_EXPULSAR_CARD:
2426   2            Mov_Card(MovPos_Front);
2427   2            MenSual = False;
2428   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_INICIO);    
2429   2            break;
2430   2          case SEQ_FRONT_CARD:
2431   2            Mov_Card(MovPos_Front);
2432   2            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_DETAIL_CAR
             -D);    
2433   2            break;
2434   2          case SEQ_DETAIL_CARD:
2435   2            if ((ValTimeOutCom==True)|| (ValTimeOutCom > TIME_PULSADOR))
2436   2            {
2437   3            Check_Status(SENSOR_DETAIL);    
2438   3            EstadoActivo=Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA_T
             -RANSPORTE);    
2439   3            Secuencia_Expedidor[TareadelCmd ] = TAREA_OPEN_BARRERA;
2440   3            }
2441   2            break;
2442   2          case SEQ_DETAIL_CARD_TRAMPA:
2443   2            if ((ValTimeOutCom == True)|| (ValTimeOutCom > TIME_WAIT))
2444   2            {
2445   3            Check_Status(SENSOR_DETAIL);    
2446   3            EstadoActivo=Analiza_card_mount_rf();   
2447   3            }
2448   2            break;
2449   2          case SEQ_LOAD_EEPROM:
2450   2            Dwload_EEprom();
2451   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_READ_SECT
             -OR_BLOQUE);  
2452   2            break;
2453   2          case SEQ_ESPERA_VEHICULO_ENTRE:
2454   2            MenSual = False;
2455   2            EstadoActivo = Entrega_Card_Captura();
2456   2            break;
2457   2          case SEQ_PTO_PARALELO:
2458   2            EstadoActivo = Send_Pto_Paralelo(Atributos_Expedidor);
2459   2            break;
2460   2          case SEQ_WAIT_PLACA:
2461   2            EstadoActivo = Wait_Placa(Atributos_Expedidor,Buffer_Write_MF); //Secuencia_Expedidor,EstadoActivo
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 42  

2462   2            break;
2463   2          case SEQ_UID: 
2464   2            Unique_Identifier_UID();
2465   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);    
2466   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_UID ;
2467   2            break;
2468   2          case SEQ_LPR:
2469   2            EstadoActivo = Pregunta_Lpr(Atributos_Expedidor);
2470   2            break;
2471   2          case SEQ_PLACA:
2472   2            pto_paraleo=True;
2473   2            EstadoActivo = Pregunta_Placa ();
2474   2            break;
2475   2          case SEQ_TIPO_TARJETAS:
2476   2            EstadoActivo = Valida_Tipo_Tarjeta(Atributos_Expedidor,Buffer_Write_MF);;
2477   2            break;
2478   2          case SEQ_CAPTURE_CARD_LOOP:
2479   2            Mov_Card(MovPos_Capture);
2480   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);     //SEQ_INICIOSEQ_MOVER_CARD_RF TAREA_PRESENCIA_ROTACION
2481   2            Secuencia_Expedidor[TareadelCmd ] = TAREA_PRESENCIA_ROTACION;
2482   2            break;
2483   2          case SEQ_POWER_OFF:
2484   2            Power_off();
2485   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_UID);
2486   2            break;
2487   2          case SEQ_POWER_ON:
2488   2            Power_off();
2489   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_LOAD_PASS
             -WORD);
2490   2            break;
2491   2          case SEQ_SECOND_PASSWORD:
2492   2            Clave_Seguridad_S2();
2493   2            EstadoActivo = Load_Secuencia_Expedidor(Secuencia_Expedidor,EstadoActivo,SEQ_CMD_ACEPTADO,SEQ_RESPUESTA
             -_TRANSPORTE);
2494   2            Secuencia_Expedidor [TareadelCmd]  = TAREA_WRITE_PLACA_CARD;
2495   2            break;
2496   2      /*------------------------------------------------------------------------------
2497   2          Tareas especificas de cada paso
2498   2      ------------------------------------------------------------------------------*/      
2499   2          case SEQ_RESPUESTA_TRANSPORTE:
2500   2            ValTimeOutCom=TIME_WAIT;
2501   2            if (Secuencia_Expedidor [TareadelCmd]==TAREA_PRESENCIA_VEHICULAR)
2502   2            {
2503   3            EstadoActivo=Responde_Estado_Sensores_Transporte(); 
2504   3              ValTimeOutCom=TIME_PULSADOR;
2505   3            
2506   3            }
2507   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_TIPO_TARJETA)
2508   2                {
2509   3                  
2510   3                  EstadoActivo=Responde_Tipo_Tarjeta();
2511   3                }
2512   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_LECTURA_TARJETA_SECTOR_BLOQUE)
2513   2                {
2514   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2515   3                  {
2516   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque1 (Atributos_Expedidor);
2517   4                  }
2518   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2519   3                  {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 43  

2520   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque0 (Nombre_Mensual);
2521   4                  }
2522   3                  else
2523   3                  {
2524   4                    EstadoActivo=Responde_Lectura_Tarjeta_Sector1_Bloque2(Atributos_Expedidor);
2525   4                  }
2526   3                }
2527   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_WRITE_TARJETA_SECTOR_BLOQUE)
2528   2                { 
2529   3                  if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_2))
2530   3                  { 
2531   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque2 (Atributos_Expedidor,Buffer_Write_MF);
2532   4                  }
2533   3                  else if ((Atributos_Expedidor [ Sector ]== Sector_2)&& (Atributos_Expedidor [ Bloque ]==Bloque_0))
2534   3                  {
2535   4                    EstadoActivo=Responde_Write_Tarjeta_Sector2_Bloque0(Buffer_Write_MF);
2536   4                  }
2537   3                    else if ((Atributos_Expedidor [ Sector ]== Sector_1)&& (Atributos_Expedidor [ Bloque ]==Bloque_1))
2538   3                  {
2539   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque1(Buffer_Write_MF);
2540   4                  }
2541   3                  else
2542   3                  {
2543   4                    EstadoActivo=Responde_Write_Tarjeta_Sector1_Bloque0 (Buffer_Write_MF);
2544   4                  }
2545   3                }
2546   2            else if (Secuencia_Expedidor [TareadelCmd]==TAREA_OPEN_BARRERA)
2547   2                {   
2548   3                  EstadoActivo = Disparo_Lock_Entrada_Vehiculo(Nombre_Mensual);
2549   3                }
2550   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_WRITE_PLACA_CARD)
2551   2                {   
2552   3                  EstadoActivo = Respuesta_Segunda_clave(Atributos_Expedidor,Buffer_Write_MF);
2553   3                }
2554   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_TIPO_MENSUAL) 
2555   2                {
2556   3                  EstadoActivo = Analiza_Presencia_Mensual();
2557   3                }
2558   2                
2559   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_UID ) 
2560   2                {
2561   3                  EstadoActivo = Analiza_Uid_Card(Atributos_Expedidor);
2562   3                } 
2563   2      
2564   2      
2565   2            else if (Secuencia_Expedidor [TareadelCmd] == TAREA_PRESENCIA_ROTACION  ) 
2566   2                {
2567   3                  EstadoActivo = Analiza_Presencia_rotacion();
2568   3                }   
2569   2            else
2570   2                {
2571   3                  Debug_txt_Tibbo((unsigned char *) "TAREA_3\r\n");
2572   3                }
2573   2            break;
2574   2          default:
2575   2          EstadoActivo = SEQ_INICIO;  
2576   2          break;  
2577   2            
2578   2        } 
2579   1        return EstadoActivo;
2580   1      }

C51 COMPILER V9.59.0.0   VERIFICADOR                                                       05/14/2021 10:23:19 PAGE 44  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8170    ----
   CONSTANT SIZE    =   2100    ----
   XDATA SIZE       =    139     257
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
