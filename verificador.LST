C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE VERIFICADOR
OBJECT MODULE PLACED IN .\object\verificador.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE verificador.c LARGE OBJECTADVANCED OPTIMIZE(11,SPEED) REGFILE(.\object\v
                    -erificador1.0.ORC) BROWSE DEFINE(XTAL=11059200) DEBUG TABS(2) OBJECT(.\object\verificador.obj)

line level    source

   1          /*
   2              FUNCIONES PARA DISPENSADOR                                *
   3          */
   4          #include<verificador.h>
   5          #include <reg51.h>
   6          
   7          /*funciones prototipo externas */
   8          
   9          extern void EscribirCadenaSoft_buffer(unsigned char *buffer,unsigned char tamano_cadena);
  10          extern void EscribirCadenaSoft(unsigned char tamano_cadena,unsigned char tipo);
  11          extern void DebugBufferMF(unsigned char *str,unsigned char num_char,char io);
  12          extern void Debug_txt_Tibbo(unsigned char * str);
  13          extern unsigned char  ValidaSensoresPaso(void);
  14          extern void send_portERR(unsigned char cod_err);
  15          extern void Debug_chr_Tibbo(unsigned char Dat);
  16          extern void Debug_HexDec(unsigned char xfc);
  17          extern char check_fechaOut(char *buffer);
  18          extern unsigned char Dir_board();
  19          extern void PantallaLCD(unsigned char cod_msg);
  20          extern void Trama_pto_Paralelo_C_s(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  21          extern void Cmd_LPR_Salida(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2);
  22          extern void Trama_pto_Paralelo(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd);
  23          extern void Trama_pto_Paralelo_P(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char cmd
             -);
  24          extern void analiza_tiempo(char *buffer,unsigned int Val_DctoMinutos);
  25          extern void Trama_pto_Paralelo_new(unsigned char *buffer_S1_B0,unsigned char *buffer_S1_B2,unsigned char c
             -md);
  26          extern void Block_read_Clock_Hex(unsigned char *datos_clock);
  27          
  28          sbit lock = P1^7;           //Relevo  
  29          sbit Atascado = P0^3;       //Rele de on/off del verificador o transporte
  30          sbit led_err_imp = P0^2;      //Error   
  31          /*variables externas*/
  32          
  33          extern unsigned char g_cEstadoComSoft;
  34          extern unsigned char ValTimeOutCom;
  35          extern unsigned char g_cEstadoComSeqMF;
  36          extern unsigned char g_cContByteRx;
  37          extern unsigned char xdata Buffer_Rta_Lintech[];
  38          extern int ID_CLIENTE;
  39          extern int COD_PARK;
  40          extern unsigned int T_GRACIA;                                       /*tiempo de gracia del parqueo*/
  41          extern unsigned char Timer_wait;
  42          extern unsigned int  SIN_COBRO;
  43          extern unsigned char  Tarjeta_on;
  44          /*externo bit*/
  45          
  46          extern bit buffer_ready;
  47          extern unsigned char USE_LPR;
  48          
  49          /*----------------------------------------------------------------------------
  50          Definiciones de sequencias de verificador y expedidor
  51          ------------------------------------------------------------------------------*/
  52          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 2   

  53          #define SEQ_INICIO            0X00  
  54          #define SEQ_CARD_INSERCION    0X01
  55          #define SEQ_CHECK_STATUS      0X02
  56          #define SEQ_RTA_CARD_POS      0x03
  57          #define SEQ_RTA_CAPTURE       0X04
  58          #define SEQ_REQUEST           0x05
  59          #define SEQ_MF_LINTECH        0x06
  60          #define SEQ_RD_S1B1           0x07
  61          #define SEQ_RD_S1B2           0x08
  62          #define SEQ_RD_S1B0           0x09
  63          #define SEQ_WR_S1B2           0x0a
  64          #define SEQ_RTA_S2B0          0x0b
  65          #define SEQ_RD_S1B0_EJECT     0x0c
  66          
  67          #define SEQ_EXPULSAR_TARJ     0x20
  68          #define SEQ_EXPULSAR_CHECK    0x21
  69          #define SEQ_EXPULSAR          0x22
  70          #define SEQ_EXPULSAR_FROM     0x23
  71          
  72          
  73          /*----------------------------------------------------------------------------
  74           definiciones de lintech en la inicializacion de expedidor o verificador
  75          ------------------------------------------------------------------------------*/
  76          
  77          #define INICIA_LINTECH          0x30
  78          #define SEQ_CAPTURE_DATOS_INI   0x31
  79          #define GRABA_EEPROM            0x32
  80          #define SEQ_CAPTURA_OK_EEPROM   0X33
  81          #define FIN_OK                  0x00
  82          
  83          /*----------------------------------------------------------------------------
  84           definiciones de lintech en el comando Check_Status
  85          ------------------------------------------------------------------------------*/
  86          
  87          #define S_DETAIL        0x31
  88          #define S_NORMAL        0x30
  89          
  90          /*------------------------------------------------------------------------------
  91           definiciones de lintech en el comando Card_Insercion
  92          ------------------------------------------------------------------------------*/
  93          
  94          #define Habilita        0x30
  95          #define Inhabilita      0x31
  96          
  97          /*------------------------------------------------------------------------------
  98          Definicion de Lintech en el comando Inicializa
  99          ------------------------------------------------------------------------------*/
 100          
 101          #define TO_FRONT        '0'
 102          #define CAPTURE_BOX     '1'
 103          #define SIN_MOVIMIENTO  '3'
 104          
 105          /*------------------------------------------------------------------------------
 106          Definicion de Lintech en el comando mover tarjeta (Mov_Card)
 107          ------------------------------------------------------------------------------*/
 108          
 109          #define   MovPos_Front        '0'   
 110          #define   MovPos_IC           '1'
 111          #define   MovPos_RF           '2'
 112          #define   MovPos_Capture      '3'
 113          #define   MovPos_EjectFront   '9'
 114          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 3   

 115          /*------------------------------------------------------------------------------
 116          Definicion de la trama Lintech de las respuestas de los cmd
 117          ------------------------------------------------------------------------------*/
 118          
 119          #define Pos_TipoResp        4
 120          #define Pos_Length          3
 121          #define Pos_St0             7
 122          #define Pos_St1             8
 123          #define Pos_St2             9
 124          #define Pos_IniDatMF        0x0a
 125          #define Card_type_H         0x0a
 126          #define Card_type_L         0x0b
 127          
 128          /*----------------------------------------------------------------------------
 129          definicion de recepcion serial 
 130          ------------------------------------------------------------------------------*/
 131          
 132          #define  ESPERA_RX          0           //espera el primer cmd de recepcion del verificado 
 133          
 134          /*----------------------------------------------------------------------------
 135          tiempo de delay entre funciones
 136          ------------------------------------------------------------------------------*/
 137          
 138          #define   TIME_CARD         100   //50
 139          
 140          
 141          /*----------------------------------------------------------------------------
 142          definicion de datos de trama lintech
 143          ------------------------------------------------------------------------------*/
 144          
 145          #define   ETX               03
 146          #define   STX_LINTECH       0xf2
 147          
 148          /*----------------------------------------------------------------------------
 149          msj de lcd tarjeta y lcd serie
 150          ------------------------------------------------------------------------------*/
 151          
 152          #define ERROR_LOOP              0XE0
 153          #define TARJETA_INVALIDA        0XE1
 154          #define TARJETA_SIN_FORMATO     0xDF
 155          #define ERROR_COD_PARK          0XE5
 156          #define SIN_INGRESO             0XE6
 157          #define SIN_PAGO                0XE7
 158          #define EXCEDE_GRACIA           0XE8
 159          
 160          /*----------------------------------------------------------------------------
 161          definiciones para, el debuger. saber si la trama es enviada, o la trama es de respuesta
 162          ------------------------------------------------------------------------------*/
 163          
 164          #define   ENVIADOS          0X0
 165          #define   RESPUESTA         0X01
 166          
 167          /*----------------------------------------------------------------------------
 168          definiciones de la tarjeta MF tipo de cliente esto esta en la posicion (0) de la memoria MF
 169          (0) si el dato es cero esta inactiva
 170          (1) activa o ROTACION
 171          
 172          ------------------------------------------------------------------------------*/
 173          
 174          #define INACTIVA          0x00
 175          #define ROTACION          0x01
 176          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 4   

 177          /*----------------------------------------------------------------------------
 178          posicion de  MF  bloque 1 sector 1
 179          (0) tipo de tarjeta 
 180          (01) el id del cliente
 181          (03)codigo del parqueadero  
 182          ------------------------------------------------------------------------------*/
 183          #define   MF_TIPO_TARJETA   0X00
 184          #define   MF_ID_CLIENTE     0x01
 185          #define   MF_COD_PARK       0x03
 186          
 187          /*----------------------------------------------------------------------------
 188          posicion de  MF bloque 2 sector 1
 189          (00) donde esta grabado la fecha de entrada (año,mes,dia,hora,minutos) estan en hex  
 190          (0b) donde esta grabado la fecha de salida (año,mes,dia,hora,minutos) estan en hex 
 191          ------------------------------------------------------------------------------*/
 192          
 193          #define   MF_FECHA_INT      0X00        /*año,mes,dia,hora,minutos*/
 194          
 195          
 196          #define   MF_DCTO           0x05        /*Tipo de descuento (00)sin descuento, (01xx xxxx) 0x40 fija fecha de salida
             -,
 197                                                    10xx xxxx dcto por porcentaje xx xxxx= valor del porcentaje, 11xx xxxx dcto por diner
             -o */
 198          #define   MF_LSB            0x06
 199          
 200          #define   MF_TIPO_VEHICULO  0x08              /*tipo vehiculo 00 carro, 01 moto, 02 bicicleta, 04 tractomula*/
 201          
 202          #define   MF_IN_PAGO        0x09
 203          #define   MF_APB            0x0A            /*antipassback 00 inicializado, 01 IN, 02 OUT, 03 NO USA*/
 204          
 205          #define   MF_FECHA_OUT      0X0B        /*año,mes,dia,hora,minutos*/
 206          
 207          /*----------------------------------------------------------------------------
 208          Definicion de varaibles globales del objeto
 209          ------------------------------------------------------------------------------*/
 210          
 211          static unsigned char Estado=INICIA_LINTECH;
 212          
 213          
 214          /*----------------------------------------------------------------------------
 215          funcion de inicializacion del transporte
 216          
 217          ------------------------------------------------------------------------------*/
 218          
 219          void Inicializa(unsigned char TipoMovimiento)
 220          {
 221   1        unsigned char j, bcc;
 222   1        unsigned char g_scArrTxComSoft[10];
 223   1        bcc=0;
 224   1        if ((TipoMovimiento==SIN_MOVIMIENTO)||(TipoMovimiento==TO_FRONT)||(TipoMovimiento==CAPTURE_BOX))
 225   1        {
 226   2          
 227   2          Debug_txt_Tibbo((unsigned char *) "Incializa Dispensador\r\n\r\n");
 228   2          
 229   2          g_scArrTxComSoft[0]=STX_LINTECH;
 230   2          g_scArrTxComSoft[1]=0X00;
 231   2          g_scArrTxComSoft[2]=0X00;
 232   2          g_scArrTxComSoft[3]=0X03;
 233   2          g_scArrTxComSoft[4]='C';
 234   2          g_scArrTxComSoft[5]='0';
 235   2          g_scArrTxComSoft[6]=TipoMovimiento;
 236   2          g_scArrTxComSoft[7]=ETX;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 5   

 237   2          for (j=0; j<8; j++)
 238   2          {
 239   3            bcc=g_scArrTxComSoft[j]^bcc;
 240   3          }
 241   2          g_scArrTxComSoft[8]=bcc;
 242   2          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 243   2          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 244   2          DebugBufferMF(g_scArrTxComSoft,9,0);                /*muestra la trama enviada al pto serie a debug por tibbo*/
 245   2          EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);    /* envio la trama por el pto serie*/
 246   2          ValTimeOutCom=TIME_CARD;
 247   2        }
 248   1      }
 249          
 250          /*------------------------------------------------------------------------------
 251          cmd de lintech que responde en que estado de los sensores se encuentra
 252          
 253          (30) solo envia el resumen de los sensores
 254          (31) da un reporte detallado de los sensores
 255          ------------------------------------------------------------------------------*/
 256          
 257          void Check_Status(unsigned char Detalle)
 258          {
 259   1        unsigned char j, bcc;
 260   1        unsigned char g_scArrTxComSoft[10];
 261   1        Debug_txt_Tibbo((unsigned char *) "Check_Status\r\n\r\n");
 262   1      
 263   1        bcc=0;
 264   1      
 265   1        g_scArrTxComSoft[0]=STX_LINTECH;
 266   1        g_scArrTxComSoft[1]=0X00;
 267   1        g_scArrTxComSoft[2]=0X00;
 268   1        g_scArrTxComSoft[3]=0X03;
 269   1        g_scArrTxComSoft[4]='C';
 270   1        g_scArrTxComSoft[5]='1';
 271   1        g_scArrTxComSoft[6]=Detalle;
 272   1        g_scArrTxComSoft[7]=ETX;
 273   1        for (j=0; j<8; j++)
 274   1        {
 275   2          bcc=g_scArrTxComSoft[j]^bcc;
 276   2        }
 277   1        g_scArrTxComSoft[8]=bcc;
 278   1        buffer_ready=0;
 279   1        g_cEstadoComSoft=ESPERA_RX;
 280   1        DebugBufferMF(g_scArrTxComSoft,9,0);
 281   1        EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);
 282   1        ValTimeOutCom=TIME_CARD;
 283   1      }
 284          
 285          /*------------------------------------------------------------------------------
 286          Procedimiento que habilita la insercion o inhabilita la insersion
 287          (31) inhabilita
 288          (30) habilita
 289          ------------------------------------------------------------------------------*/
 290          
 291          void Card_Insercion(char Tipo)
 292          {
 293   1        unsigned char j, bcc;
 294   1        unsigned char g_scArrTxComSoft[10];
 295   1        if (Tipo==Habilita)
 296   1        {
 297   2          Debug_txt_Tibbo((unsigned char *) "Habilita Insersion\r\n\r\n");
 298   2          g_scArrTxComSoft[6]=Habilita;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 6   

 299   2        }
 300   1        else
 301   1        {
 302   2          
 303   2          Debug_txt_Tibbo((unsigned char *) "Inhabilita Insersion\r\n\r\n");
 304   2          g_scArrTxComSoft[6]=Inhabilita;
 305   2        
 306   2        }
 307   1      
 308   1        bcc=0;
 309   1      
 310   1        g_scArrTxComSoft[0]=0xF2;
 311   1        g_scArrTxComSoft[1]=0X00;
 312   1        g_scArrTxComSoft[2]=0X00;
 313   1        g_scArrTxComSoft[3]=0X03;
 314   1        g_scArrTxComSoft[4]='C';
 315   1        g_scArrTxComSoft[5]='3';
 316   1      
 317   1        g_scArrTxComSoft[7]=ETX;
 318   1        for (j=0; j<8; j++)
 319   1        {
 320   2          bcc=g_scArrTxComSoft[j]^bcc;
 321   2        }
 322   1      
 323   1        g_scArrTxComSoft[8]=bcc;
 324   1      
 325   1        buffer_ready=0;
 326   1        g_cEstadoComSoft=ESPERA_RX;
 327   1        DebugBufferMF(g_scArrTxComSoft,9,0);
 328   1        EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);
 329   1        ValTimeOutCom=TIME_CARD;
 330   1      }
 331          
 332          /*------------------------------------------------------------------------------
 333          CMD q mueve la tarjeta 
 334          ------------------------------------------------------------------------------*/
 335          
 336          void Mov_Card(unsigned char Posicion)
 337          {
 338   1        unsigned char j, bcc;
 339   1        unsigned char g_scArrTxComSoft[10];
 340   1        bcc=0;
 341   1      
 342   1        if ((Posicion==MovPos_RF)||(Posicion==MovPos_IC)||(Posicion==MovPos_Front)||(Posicion==MovPos_EjectFront
             -)||(Posicion==MovPos_Capture))
 343   1        {
 344   2          if (Posicion==MovPos_RF)
 345   2          {
 346   3            Debug_txt_Tibbo((unsigned char *) "Moviendo Tarjeta a RF\r\n\r\n");
 347   3          }
 348   2          else if (Posicion==MovPos_IC)
 349   2          {
 350   3            Debug_txt_Tibbo((unsigned char *) "Moviendo Tarjeta a IC\r\n\r\n");
 351   3            }
 352   2          else if (Posicion==MovPos_Front)
 353   2          {
 354   3            Debug_txt_Tibbo((unsigned char *) "Moviendo Tarjeta a Bezel\r\n\r\n");
 355   3          }
 356   2          else if (Posicion==MovPos_EjectFront)
 357   2          {
 358   3            Debug_txt_Tibbo((unsigned char *) "Expulsando Tarjeta\r\n\r\n");
 359   3          }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 7   

 360   2          else if (Posicion==MovPos_Capture)
 361   2          {
 362   3            Debug_txt_Tibbo((unsigned char *) "Capturando Tarjeta\r\n\r\n");
 363   3          }
 364   2      
 365   2          g_scArrTxComSoft[0]=STX_LINTECH;
 366   2          g_scArrTxComSoft[1]=0X00;
 367   2          g_scArrTxComSoft[2]=0X00;
 368   2          g_scArrTxComSoft[3]=0X03;
 369   2          g_scArrTxComSoft[4]='C';
 370   2          g_scArrTxComSoft[5]='2';
 371   2          g_scArrTxComSoft[6]=Posicion;
 372   2          g_scArrTxComSoft[7]=ETX;
 373   2          for (j=0; j<8; j++)
 374   2          {
 375   3            bcc=g_scArrTxComSoft[j]^bcc;
 376   3          }
 377   2          g_scArrTxComSoft[8]=bcc;
 378   2          buffer_ready=0;
 379   2          g_cEstadoComSoft=ESPERA_RX;
 380   2          DebugBufferMF(g_scArrTxComSoft,9,0);
 381   2          EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);
 382   2          ValTimeOutCom=TIME_CARD;
 383   2        }
 384   1      
 385   1      }
 386          
 387          //*******************************************************************************************
 388          // rutina q mira el tipo de tarjeta si es valido para el uso  
 389          //*******************************************************************************************
 390          
 391          void Aut_Card_check_Status(void)
 392          {
 393   1      unsigned char j, bcc;
 394   1      unsigned char g_scArrTxComSoft[10];
 395   1            bcc=0;
 396   1        
 397   1        Debug_txt_Tibbo((unsigned char *) "Aut_Card_check_Status\r\n\r\n");
 398   1        
 399   1        g_scArrTxComSoft[0]=STX_LINTECH;
 400   1          g_scArrTxComSoft[1]=0X00;
 401   1          g_scArrTxComSoft[2]=0X00;
 402   1          g_scArrTxComSoft[3]=0X03;
 403   1          g_scArrTxComSoft[4]='C';
 404   1          g_scArrTxComSoft[5]=0x50;
 405   1          g_scArrTxComSoft[6]=0x31;
 406   1          g_scArrTxComSoft[7]=ETX;
 407   1            for (j=0; j<8; j++)
 408   1          {
 409   2            bcc=g_scArrTxComSoft[j]^bcc;
 410   2          }
 411   1          g_scArrTxComSoft[8]=bcc;
 412   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 413   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 414   1          DebugBufferMF(g_scArrTxComSoft,9,0);                /*muestra la trama enviada al pto serie a debug por tibbo*/
 415   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,9);    /* envio la trama por el pto serie*/
 416   1          ValTimeOutCom=TIME_CARD;
 417   1        } 
 418          
 419          /*------------------------------------------------------------------------------
 420          CMD q programa la clave en el verificador o transporte
 421          ------------------------------------------------------------------------------*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 8   

 422          
 423            void Dwload_EEprom (void)
 424          {
 425   1        unsigned char j, bcc;
 426   1        unsigned char g_scArrTxComSoft[21];
 427   1        bcc=0;
 428   1        Debug_txt_Tibbo((unsigned char *) "Download MF EEprom\r\n\r\n");
 429   1        
 430   1        g_scArrTxComSoft[0]=0xF2;
 431   1        g_scArrTxComSoft[1]=0X00;
 432   1        g_scArrTxComSoft[2]=0X00;
 433   1        g_scArrTxComSoft[3]=0X0E;
 434   1        g_scArrTxComSoft[4]='C';
 435   1        g_scArrTxComSoft[5]=0x60;
 436   1        g_scArrTxComSoft[6]='3';
 437   1        g_scArrTxComSoft[7]=0x00;
 438   1        g_scArrTxComSoft[8]=0Xd0;
 439   1        g_scArrTxComSoft[9]=0X00;
 440   1        g_scArrTxComSoft[10]=0X01;
 441   1        g_scArrTxComSoft[11]=0x06;
 442   1        g_scArrTxComSoft[12]='3';
 443   1        g_scArrTxComSoft[13]='V';
 444   1        g_scArrTxComSoft[14]='0';
 445   1        g_scArrTxComSoft[15]='p';
 446   1        g_scArrTxComSoft[16]='4';
 447   1        g_scArrTxComSoft[17]='r';
 448   1        g_scArrTxComSoft[18]=ETX;
 449   1        
 450   1        for (j=0; j<19; j++)
 451   1          {
 452   2            bcc=g_scArrTxComSoft[j]^bcc;
 453   2          }
 454   1          g_scArrTxComSoft[19]=bcc;
 455   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 456   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 457   1          DebugBufferMF(g_scArrTxComSoft,20,0);               /*muestra la trama enviada al pto serie a debug por tibbo*/
 458   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,20);   /* envio la trama por el pto serie*/
 459   1          ValTimeOutCom=TIME_CARD;
 460   1      }
 461          
 462          /*------------------------------------------------------------------------------
 463          Funcion q verifica si la clave y la carga en el transporte
 464          ------------------------------------------------------------------------------*/
 465          
 466          void LoadVerify_EEprom(void)
 467          {
 468   1        unsigned char j, bcc;
 469   1        unsigned char g_scArrTxComSoft[15];
 470   1        bcc=0;
 471   1        Debug_txt_Tibbo((unsigned char *) "Carga y Verifica de EEprom\r\n\r\n");
 472   1      
 473   1      
 474   1        g_scArrTxComSoft[0]=0xF2;
 475   1        g_scArrTxComSoft[1]=0X00;
 476   1        g_scArrTxComSoft[2]=0X00;
 477   1        g_scArrTxComSoft[3]=0X07;
 478   1        g_scArrTxComSoft[4]='C';
 479   1        g_scArrTxComSoft[5]=0x60;
 480   1        g_scArrTxComSoft[6]='3';
 481   1        g_scArrTxComSoft[7]=0x00;
 482   1        g_scArrTxComSoft[8]=0x21;
 483   1          g_scArrTxComSoft[9]=0x00;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 9   

 484   1        g_scArrTxComSoft[10]=0x01;
 485   1        g_scArrTxComSoft[11]=ETX;
 486   1        g_scArrTxComSoft[12]=0xc6;
 487   1      
 488   1        
 489   1      
 490   1        for (j=0; j<13; j++)
 491   1          {
 492   2            bcc=g_scArrTxComSoft[j]^bcc;
 493   2          }
 494   1          g_scArrTxComSoft[13]=bcc;
 495   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 496   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 497   1          DebugBufferMF(g_scArrTxComSoft,14,0);               /*muestra la trama enviada al pto serie a debug por tibbo*/
 498   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,14);   /* envio la trama por el pto serie*/
 499   1          ValTimeOutCom=TIME_CARD;
 500   1          
 501   1      }
 502          
 503          /*------------------------------------------------------------------------------
 504          Funcion q lee la MF dandole el sector y el bloque
 505          ------------------------------------------------------------------------------*/
 506          
 507          void RD_MF(unsigned char Sector, unsigned char Bloque)
 508          {
 509   1      
 510   1        unsigned char j, bcc;
 511   1        unsigned char g_scArrTxComSoft[15];
 512   1        bcc=0;
 513   1      
 514   1        Debug_txt_Tibbo((unsigned char *) "Leyendo MF > Sector: ");
 515   1        Debug_chr_Tibbo(Sector);
 516   1        
 517   1        Debug_txt_Tibbo((unsigned char *) " Bloque: ");
 518   1        Debug_chr_Tibbo(Bloque);
 519   1        Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 520   1      
 521   1      
 522   1        g_scArrTxComSoft[0]=0xF2;
 523   1        g_scArrTxComSoft[1]=0X00;                   
 524   1        g_scArrTxComSoft[2]=0X00;
 525   1        g_scArrTxComSoft[3]=0X08;
 526   1        g_scArrTxComSoft[4]='C';
 527   1        g_scArrTxComSoft[5]=0X60;
 528   1        g_scArrTxComSoft[6]='3';
 529   1        g_scArrTxComSoft[7]=0x00;
 530   1        g_scArrTxComSoft[8]=0xb0;
 531   1        g_scArrTxComSoft[9]=Sector;
 532   1        g_scArrTxComSoft[10]=Bloque;
 533   1        g_scArrTxComSoft[11]=0x01;
 534   1        g_scArrTxComSoft[12]=ETX;
 535   1      
 536   1        for (j=0; j<13; j++)
 537   1        {
 538   2          bcc=g_scArrTxComSoft[j]^bcc;
 539   2        }
 540   1        g_scArrTxComSoft[13]=bcc;
 541   1      
 542   1      
 543   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 544   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 545   1          DebugBufferMF(g_scArrTxComSoft,14,0);               /*muestra la trama enviada al pto serie a debug por tibbo*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 10  

 546   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,14);   /* envio la trama por el pto serie*/
 547   1          ValTimeOutCom=TIME_CARD;
 548   1      
 549   1      }
 550          
 551          /*------------------------------------------------------------------------------
 552          Funcion q lescribe la MF dandole el sector y el bloque y los datos
 553          ------------------------------------------------------------------------------*/
 554          
 555          
 556          void WR_MF(unsigned char Sector, unsigned char Bloque,unsigned char *buffer)     
 557             
 558          {
 559   1        unsigned char j, bcc;
 560   1        unsigned char g_scArrTxComSoft[31];
 561   1        bcc=0;
 562   1      
 563   1        Debug_txt_Tibbo((unsigned char *) "Escribe MF > Sector: ");
 564   1        Debug_chr_Tibbo(Sector);
 565   1        
 566   1        Debug_txt_Tibbo((unsigned char *) " Bloque: ");
 567   1        Debug_chr_Tibbo(Bloque);
 568   1        Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
 569   1                                          
 570   1        g_scArrTxComSoft[0]=0xF2;
 571   1        g_scArrTxComSoft[1]=0X00;                   
 572   1        g_scArrTxComSoft[2]=0X00;
 573   1        g_scArrTxComSoft[3]=24;                                 /* Numero Datos a programar */ 
 574   1        
 575   1        g_scArrTxComSoft[4]='C';
 576   1        g_scArrTxComSoft[5]=0X60;
 577   1        g_scArrTxComSoft[6]='3';
 578   1        g_scArrTxComSoft[7]=0x00;
 579   1        g_scArrTxComSoft[8]=0xd1;
 580   1        g_scArrTxComSoft[9]=Sector;                             //Sector;
 581   1        g_scArrTxComSoft[10]=Bloque;                            //Bloque;
 582   1        g_scArrTxComSoft[11]=0x01;
 583   1      
 584   1        if(Sector!=2)
 585   1        { 
 586   2      /*------------------------------------------------------------------------------
 587   2      borro la fecha de entrada de entrada 
 588   2      ------------------------------------------------------------------------------*/
 589   2      
 590   2        g_scArrTxComSoft[12]=0x00;                              /*borro la fecha de entrada año mes dia hora minutos*/
 591   2        g_scArrTxComSoft[13]=0x00;
 592   2        g_scArrTxComSoft[14]=0x00;
 593   2        g_scArrTxComSoft[15]=0x00;
 594   2        g_scArrTxComSoft[16]=0x00;
 595   2      
 596   2      /*------------------------------------------------------------------------------
 597   2      borro los descuentos
 598   2      ------------------------------------------------------------------------------*/
 599   2        g_scArrTxComSoft[17]=0x00;
 600   2        g_scArrTxComSoft[18]=0x00;
 601   2        g_scArrTxComSoft[19]=0x00;
 602   2        
 603   2      /*------------------------------------------------------------------------------
 604   2      tipo de vehiculo
 605   2      ------------------------------------------------------------------------------*/
 606   2        
 607   2        g_scArrTxComSoft[20]=*buffer;
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 11  

 608   2        
 609   2      /*------------------------------------------------------------------------------
 610   2      direccion de BOArd_pcb de salida o puerta de salida
 611   2      ------------------------------------------------------------------------------*/  
 612   2        g_scArrTxComSoft[21]=0x0f&Dir_board();
 613   2        
 614   2      /*------------------------------------------------------------------------------
 615   2      programo el APB como salida (02) entrada(01)
 616   2      ------------------------------------------------------------------------------*/
 617   2      g_scArrTxComSoft[22]=02;
 618   2      
 619   2      /*------------------------------------------------------------------------------
 620   2      borro la fecha de salida 
 621   2      ------------------------------------------------------------------------------*/
 622   2      
 623   2        g_scArrTxComSoft[23]=0x00;                              /*borro la fecha de entrada año mes dia hora minutos*/
 624   2        g_scArrTxComSoft[24]=0x00;
 625   2        g_scArrTxComSoft[25]=0x00;
 626   2        g_scArrTxComSoft[26]=0x00;
 627   2        g_scArrTxComSoft[27]=0x00;
 628   2      
 629   2        }
 630   1          else 
 631   1          {
 632   2            for (j=12; j<=28; j++)
 633   2            {
 634   3              g_scArrTxComSoft[j]=0x00; 
 635   3            }
 636   2          }
 637   1      
 638   1      
 639   1      
 640   1      
 641   1        g_scArrTxComSoft[28]=ETX;
 642   1        
 643   1        for (j=0; j<=28; j++)
 644   1        {
 645   2          bcc=bcc^g_scArrTxComSoft[j];
 646   2        }
 647   1        g_scArrTxComSoft[29]=bcc;
 648   1      
 649   1        
 650   1          buffer_ready=0;                                   /* buffer del pto serie (0) inicia a esperar la trama*/
 651   1          g_cEstadoComSoft=ESPERA_RX;                       /* Espera el ASK en el pt o serie para empesar a almacenas*/
 652   1          DebugBufferMF(g_scArrTxComSoft,30,0);               /*muestra la trama enviada al pto serie a debug por tibbo*/
 653   1          EscribirCadenaSoft_buffer(g_scArrTxComSoft,30);   /* envio la trama por el pto serie*/
 654   1          ValTimeOutCom=TIME_CARD;
 655   1        
 656   1      }
 657          
 658          /*------------------------------------------------------------------------------
 659          funcion que valida la trama del verificador o transporte lintech
 660          (0) significa que la trama es valida y sigue en el proceso
 661          (1) falla en la respuesta por pto serie o trama invalida
 662          (2) no ha recibido la trama del verificador o transporte
 663          (3) ERROR DE TRAMA CMD (N)
 664          ------------------------------------------------------------------------------*/
 665          
 666          char Trama_Validacion_P_N()
 667          {
 668   1        char Trama_Validacion_P_N=2;
 669   1        
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 12  

 670   1            if ((ValTimeOutCom==1)||(buffer_ready==1))
 671   1            {
 672   2              if (buffer_ready==1)
 673   2              {
 674   3                buffer_ready=0;
 675   3                  
 676   3              
 677   3                if (Buffer_Rta_Lintech[Pos_TipoResp]=='P')
 678   3                {
 679   4                          
 680   4                  Trama_Validacion_P_N=0;
 681   4                    
 682   4                }
 683   3                else if (Buffer_Rta_Lintech[Pos_TipoResp]=='N')
 684   3                {
 685   4                  
 686   4                  Trama_Validacion_P_N=3;
 687   4                  
 688   4                }
 689   3                else
 690   3                {
 691   4                  Debug_txt_Tibbo((unsigned char *) "Respuesta  DESCONOCIDA \r\n");       /*la respuesta es desconocida*
             -/
 692   4                  Trama_Validacion_P_N=3;   
 693   4                  
 694   4                }
 695   3              }
 696   2              else
 697   2              {
 698   3                          
 699   3                Trama_Validacion_P_N=1;                                                 /*pto serie no responde */
 700   3                                                  
 701   3              }
 702   2      
 703   2            }
 704   1            
 705   1        return Trama_Validacion_P_N;
 706   1      }
 707          
 708          /*------------------------------------------------------------------------------
 709          Secuencia de los cmd de inicio (reset dispositivo y graba eeprom)
 710          
 711          funcion  de los cmd de inicio (reset dispositivo y graba eeprom) retorna un (00) cuando a terminado exitos
             -o
 712          ------------------------------------------------------------------------------*/
 713          
 714          unsigned char  Secuencia_inicio_expedidor(void)
 715          {
 716   1        char temp;
 717   1        switch (Estado)
 718   1        {
 719   2          case INICIA_LINTECH:
 720   2      
 721   2                
 722   2              Inicializa(SIN_MOVIMIENTO);                                       //Inicio el transporte sin movimiento
 723   2              Estado=SEQ_CAPTURE_DATOS_INI;                                     // entra a validar la respuesta del transporte
 724   2              
 725   2            
 726   2            return (Estado);
 727   2          break;
 728   2      
 729   2      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 13  

 730   2      /*------------------------------------------------------------------------------
 731   2      Envia la primera trama de inicializacion del transporte sin movimiento
 732   2            (0) LA RESPUESTA ES OK
 733   2            (1) NO RESPONDE EL PTO SERIE
 734   2            (2) NO RECIBIDO LA TRAMA 
 735   2            (3) ERROR DE TRAMA CMD (N)
 736   2      ------------------------------------------------------------------------------*/
 737   2            
 738   2          case SEQ_CAPTURE_DATOS_INI:
 739   2      
 740   2            if((temp=Trama_Validacion_P_N())!=0)
 741   2          {
 742   3            if(temp==2)
 743   3            {
 744   4            Estado=SEQ_CAPTURE_DATOS_INI;                                                         /*(2)no ha respondido*/
 745   4            } 
 746   3            else if (temp==3)
 747   3            {
 748   4            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO ERROR\r\n\r\n");         /* trama no valida*/
 749   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 750   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 751   4            }
 752   3            else
 753   3            {
 754   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 755   4              Estado=INICIA_LINTECH;                                                              /*(1) no responde el pto*/  
 756   4            }
 757   3          }
 758   2          else
 759   2          {
 760   3            Debug_txt_Tibbo((unsigned char *) "INICIALIZA SIN MOVIMIENTO OK\r\n\r\n");            /* trama valida Habilit
             -ado */
 761   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 762   3            Estado=GRABA_EEPROM;                                                                  /*(0) respuesta ok*/
 763   3          }     
 764   2          return (Estado);
 765   2          break;
 766   2            
 767   2      /*------------------------------------------------------------------------------
 768   2      Envia el cmd de grabar claves a la eeprom del transporte 
 769   2      ------------------------------------------------------------------------------*/
 770   2            
 771   2            case GRABA_EEPROM:
 772   2              
 773   2              Dwload_EEprom();                                                                    //envio el cmd de grabar la eeprom
 774   2              Estado=SEQ_CAPTURA_OK_EEPROM;                                                       // entra a validar la respuesta del transport
             -e
 775   2            
 776   2            
 777   2      
 778   2            return (Estado);
 779   2              break;
 780   2        
 781   2      /*------------------------------------------------------------------------------
 782   2      se analiza la respuesta 
 783   2            (0) LA RESPUESTA ES OK
 784   2            (1) NO RESPONDE EL PTO SERIE
 785   2            (2) NO RECIBIDO LA TRAMA 
 786   2            (3) ERROR DE TRAMA CMD (N)
 787   2      ------------------------------------------------------------------------------*/
 788   2            
 789   2          case SEQ_CAPTURA_OK_EEPROM:
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 14  

 790   2          
 791   2          if((temp=Trama_Validacion_P_N())!=0)
 792   2          {
 793   3            if(temp==2)
 794   3            {
 795   4            Estado=SEQ_CAPTURA_OK_EEPROM;                                                         /*no ha respondido*/
 796   4            }
 797   3            else if (temp==3)
 798   3            {
 799   4            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM ERROR\r\n\r\n");                     /* trama no valida respuest
             -a incorrecta falla en la escritura de la clave*/
 800   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 801   4            Estado=INICIA_LINTECH;                                                                /* (3) Trama invalida cmd (N)*/ 
 802   4            }     
 803   3            else
 804   3            {
 805   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 806   4              Estado=INICIA_LINTECH;                                                              /*NO RESPONDE PTO SERIE */
 807   4            }       
 808   3          }
 809   2          else
 810   2          {
 811   3            Debug_txt_Tibbo((unsigned char *) "DWLOAP EEPROM OK\r\n\r\n");                        /* trama valida Habilitado */
 812   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 813   3            Estado=FIN_OK;                                                                        /*respuesta ok clave grabada con exito*/
 814   3          }     
 815   2      
 816   2          return (Estado);
 817   2          break;
 818   2      
 819   2      /*------------------------------------------------------------------------------
 820   2      Fin de la secuencia de comandos con exito 
 821   2      ------------------------------------------------------------------------------*/    
 822   2            
 823   2              case FIN_OK:
 824   2      
 825   2              return (Estado);
 826   2          break;
 827   2            
 828   2                
 829   2              default:
 830   2              return Estado=INICIA_LINTECH; 
 831   2              break;
 832   2        }
 833   1      }
 834          
 835          /*------------------------------------------------------------------------------
 836          Prosedimiento  q hace paso a paso la secuencia de la MF
 837          ------------------------------------------------------------------------------*/
 838          
 839          void SecuenciaExpedidor(void)
 840          {
 841   1        unsigned char temp;
 842   1        static unsigned char buffer_S1_B0[17];
 843   1        static unsigned char buffer_S1_B1[17];
 844   1        static unsigned char buffer_S1_B2[17];
 845   1        static unsigned char error_rx=0; 
 846   1        unsigned char clock_temp[6];
 847   1        switch (g_cEstadoComSeqMF)
 848   1        {
 849   2      //***********************************************************************************************
 850   2          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 15  

 851   2          case SEQ_INICIO:
 852   2      
 853   2            if (ValTimeOutCom==1)
 854   2            {
 855   3      
 856   3              Card_Insercion(Habilita);                                                         /* se envia el cmd de inicio insercion por boca*
             -/
 857   3              g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                             // entra a validar la respuesta del transp
             -orte
 858   3              
 859   3            }
 860   2       
 861   2          break;
 862   2      
 863   2      /*------------------------------------------------------------------------------
 864   2      Analizo la trama de insercion por boca
 865   2            (0) LA RESPUESTA ES OK
 866   2            (1) NO RESPONDE EL PTO SERIE
 867   2            (2) NO RECIBIDO LA TRAMA 
 868   2            (3) ERROR DE TRAMA CMD (N)
 869   2      ------------------------------------------------------------------------------*/      
 870   2          
 871   2          case SEQ_CARD_INSERCION:  
 872   2            
 873   2          if((temp=Trama_Validacion_P_N())!=0)
 874   2          {
 875   3            if(temp==2)
 876   3            {
 877   4            g_cEstadoComSeqMF=SEQ_CARD_INSERCION;                                                 /*no ha respondido*/
 878   4            } 
 879   3            else if (temp==3)
 880   3            {
 881   4            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION ERROR\r\n\r\n");                    /* trama no valida respuest
             -a incorrecta falla en la escritura */
 882   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/ 
 883   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
 884   4            }     
 885   3            else
 886   3            {
 887   4            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 888   4              if (error_rx>= 3)
 889   4              {
 890   5                error_rx=0;
 891   5                Atascado=1;                                                                           /*apago el verificador*/
 892   5                led_err_imp=0;                                                                        /*error led on*/
 893   5                Timer_wait=0;
 894   5                ValTimeOutCom=3;        
 895   5                g_cEstadoComSeqMF=SEQ_INICIO;     //SEQ_CHECK_STATUS;
 896   5                  break;                                                                              /* respuesta incorrecta*/ 
 897   5              }     
 898   4      
 899   4              error_rx++;
 900   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                       /* respuesta incorrecta*/ 
 901   4            }       
 902   3          }
 903   2          else
 904   2          {
 905   3            Debug_txt_Tibbo((unsigned char *) "CARD_INSERCION OK\r\n\r\n");                       /* trama valida Habilitado *
             -/
 906   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
 907   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*respuesta ok*/
 908   3          }     
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 16  

 909   2            
 910   2          break;
 911   2            
 912   2      /*------------------------------------------------------------------------------
 913   2      chequeo el estado de los sensores 
 914   2      ------------------------------------------------------------------------------*/      
 915   2          
 916   2          case SEQ_CHECK_STATUS:  
 917   2                      
 918   2              Check_Status(S_NORMAL);                                                               /* envio el cmd de pregunta en q estado estan l
             -os sensores*/
 919   2              g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                   // entra a validar la respuesta del trans
             -porte
 920   2             
 921   2            break;      
 922   2              
 923   2      /*------------------------------------------------------------------------------
 924   2      Valido la informacion de los sensores
 925   2            (0) LA RESPUESTA ES OK
 926   2            (1) NO RESPONDE EL PTO SERIE
 927   2            (2) NO RECIBIDO LA TRAMA 
 928   2            (3) ERROR DE TRAMA CMD (N)
 929   2      ------------------------------------------------------------------------------*/    
 930   2      
 931   2          case SEQ_RTA_CARD_POS:
 932   2            
 933   2          if((temp=Trama_Validacion_P_N())!=0)
 934   2          {
 935   3            if(temp==2)
 936   3            {
 937   4            g_cEstadoComSeqMF=SEQ_RTA_CARD_POS;                                                       /*no ha respondido*/
 938   4            } 
 939   3            else if (temp==3)
 940   3            {
 941   4            Debug_txt_Tibbo((unsigned char *) "SEQ_CARD_INSERCION  FALLO\r\n\r\n");                     /* trama no valida*/
 942   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                          /*imprimo la trama recibida*/
 943   4            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                         /* (3) Trama invalida cmd (N)*/ 
 944   4            }     
 945   3            else
 946   3            {
 947   4            Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");
 948   4              if (error_rx>= 3)
 949   4              {
 950   5                error_rx=0;
 951   5                Atascado=1;                                                                           /*apago el verificador*/
 952   5                led_err_imp=0;                                                                        /*error led on*/
 953   5                Timer_wait=0;
 954   5                ValTimeOutCom=3;        
 955   5                g_cEstadoComSeqMF=SEQ_INICIO;     //SEQ_CHECK_STATUS;
 956   5                  break;                                                                              /* respuesta incorrecta*/ 
 957   5              } 
 958   4              error_rx++;
 959   4              g_cEstadoComSeqMF=SEQ_CHECK_STATUS;
 960   4            }     
 961   3          }
 962   2          else
 963   2          {
 964   3            Debug_txt_Tibbo((unsigned char *) "CHECK SATUS OK\r\n\r\n");                                  /* trama valida Habilitado
             - */
 965   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                    /*imprimo la trama recibida
             -*/
 966   3              if (Buffer_Rta_Lintech[Pos_St0]=='0')                                                       /* CANAL LIBRE    no tiene tarjetas en
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 17  

             - el mecanismo*/
 967   3                  {
 968   4                    
 969   4                    Debug_txt_Tibbo((unsigned char *) "No tiene tarjetas en el mecanismo\r\n\r\n");       /* trama valida 
             -Habilitado insercion por boca*/
 970   4                    g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */          
 971   4      
 972   4                    
 973   4                  }
 974   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='1')                                              /*  se detecta la tarjeta en la bo
             -ca TARJETA EN BEZZEL*/
 975   3                  {
 976   4                    
 977   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta en la boca\r\n\r\n");                      /* trama valida Habilita
             -do insercion por boca*/
 978   4                    g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*volvemos a preguntar  */      
 979   4                                           
 980   4                  }
 981   3                  else if (Buffer_Rta_Lintech[Pos_St0]=='2')                                            // TARJETA EN RF
 982   3                  {
 983   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta lista para leer en RF\r\n\r\n");             /* trama valida H
             -abilitado insercion por boca*/
 984   4                                
 985   4                    error_rx=0;
 986   4                    if (ValidaSensoresPaso()!=0)                                                        /*pregunto q alla presencia vehicular*/
 987   4                    {
 988   5                    Debug_txt_Tibbo((unsigned char *) "Vehiculo en el loop\r\n\r\n");                   /* se encuentra un senso
             -r activo*/
 989   5                    Aut_Card_check_Status();                                                            /* se pregunta el tipo de tarjeta si es MF50*
             -/
 990   5                    Tarjeta_on=1;
 991   5                    g_cEstadoComSeqMF=SEQ_REQUEST;                                                      /*vamos al siguiente paso a con validar el
             - cmd*/    
 992   5                    }
 993   4                    else
 994   4                    {
 995   5                      Debug_txt_Tibbo((unsigned char *) "Vehiculo no en el loop\r\n\r\n");              /* no hay vehiculo en e
             -l loop*/
 996   5                      send_portERR(ERROR_LOOP);                                                         /*envio msj al lcd tarjeta*/
 997   5                      PantallaLCD(ERROR_LOOP);                                                          /*envio el msj por la pantalla lcd o la raspb
             -erry*/
 998   5                      g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /*volvemos a preguntar  */  
 999   5                      
1000   5                    }
1001   4                                                                  
1002   4                  }
1003   3                                                                    
1004   3          }     
1005   2            
1006   2          break;
1007   2        
1008   2      
1009   2      /*------------------------------------------------------------------------------
1010   2      El vehiculo esta ubicado en el loop vengo de preguntar el tipo de tarjeta que esta en el lector
1011   2      (1 0)  es una tarjeta valida Mf50 
1012   2      las demas combinaciones son tomadas como no validas
1013   2            (0) LA RESPUESTA ES OK
1014   2            (1) NO RESPONDE EL PTO SERIE
1015   2            (2) NO RECIBIDO LA TRAMA 
1016   2            (3) ERROR DE TRAMA CMD (N)    
1017   2      ------------------------------------------------------------------------------*/  
1018   2      
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 18  

1019   2        case SEQ_REQUEST:
1020   2          
1021   2        if((temp=Trama_Validacion_P_N())!=0)
1022   2          {
1023   3            if(temp==2)
1024   3            {
1025   4            g_cEstadoComSeqMF=SEQ_REQUEST;                                                            /*no ha respondido*/
1026   4            } 
1027   3              else if (temp==3)
1028   3            {
1029   4              
1030   4              Debug_txt_Tibbo((unsigned char *) "SEQ_REQUEST FALLO\r\n\r\n");                       /* trama no valida*/
1031   4              DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                                    /*imprimo la trama recibida*/
1032   4              g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /* error de la trama */ 
1033   4                                                                                                    /* (3) Trama invalida cmd (N)*/ 
1034   4            } 
1035   3            else
1036   3            {
1037   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde SEQ REQUEST...\r\n\r\n");      /* pto serie no
             - responde*/
1038   4              send_portERR(TARJETA_INVALIDA);                                                           /*la tarjeta no es valida no la puede i
             -dentificar*/
1039   4              PantallaLCD(TARJETA_INVALIDA);                                                            /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1040   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                      /* capturo la respuesta y regreso a che
             -quear verificador*/ 
1041   4            
1042   4            }       
1043   3          }
1044   2          else
1045   2          {
1046   3             if (Buffer_Rta_Lintech[Card_type_H]=='1')                                                  /* pregunto si la tarjeta en el tran
             -sporte es MF 50 */
1047   3                    {
1048   4                      if (Buffer_Rta_Lintech[Card_type_L]=='0') 
1049   4                        {
1050   5                          Debug_txt_Tibbo((unsigned char *) "Tarjeta valida MF50\r\n\r\n");             /* trama valida son MF50
             -*/
1051   5                          DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);                            /* se muestra la trama*/
1052   5                          LoadVerify_EEprom();                                                          // verifico q la clave este cargada en el tran
             -sporte
1053   5                          g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                             /* la tarjeta es MF50*/
1054   5                          
1055   5                       }else
1056   4                        {
1057   5                        Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");         /* trama no valida 
             -*/
1058   5                        DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);    
1059   5                        send_portERR(TARJETA_INVALIDA);
1060   5                        PantallaLCD(TARJETA_INVALIDA);                                                  /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1061   5                        g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                            /* capturo la respuesta y regreso a che
             -quear verificador*/
1062   5                         
1063   5                        }
1064   4                   }
1065   3                    else 
1066   3                    {
1067   4                    Debug_txt_Tibbo((unsigned char *) "Tarjeta invalida no es MF50\r\n\r\n");           /* trama no valida *
             -/
1068   4                    DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,1);      
1069   4                    send_portERR(TARJETA_INVALIDA);                                                     //la tarjeta no es valida 
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 19  

1070   4                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1071   4                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* capturo la respuesta y regreso a che
             -quear verificador*/      
1072   4                  
1073   4                    }
1074   3                                                                                                            /*respuesta ok inicia revisando sensores*/
1075   3          }     
1076   2                
1077   2            break;
1078   2      /*------------------------------------------------------------------------------
1079   2      Verifica la eeprom 
1080   2            (0) LA RESPUESTA ES OK
1081   2            (1) NO RESPONDE EL PTO SERIE
1082   2            (2) NO RECIBIDO LA TRAMA 
1083   2            (3) ERROR DE TRAMA CMD (N)
1084   2      ------------------------------------------------------------------------------*/  
1085   2        case SEQ_MF_LINTECH:
1086   2          
1087   2        if((temp=Trama_Validacion_P_N())!=0)
1088   2          {
1089   3            if(temp==2)
1090   3            {
1091   4            g_cEstadoComSeqMF=SEQ_MF_LINTECH;                                                           /*no ha respondido*/
1092   4            }
1093   3            else if (temp==3)
1094   3            {
1095   4            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM ERROR\r\n\r\n");                    /* trama no valida resp
             -uesta incorrecta falla en la escritura de la clave*/
1096   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1097   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1098   4            }       
1099   3            else
1100   3            { 
1101   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1102   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/
1103   4            }
1104   3          }
1105   2          else
1106   2          {
1107   3            Debug_txt_Tibbo((unsigned char *) "LOAD VERIFY EEPROM OK\r\n\r\n");                       /* trama OK CARGA LA EEP
             -ROM Y LA VERIFICA*/
1108   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1109   3            RD_MF(1,1);                                                                               /*leo MF */
1110   3            g_cEstadoComSeqMF=SEQ_RD_S1B1;                                                            /*respuesta ok inicia clave verificada*/
1111   3          }     
1112   2      
1113   2        
1114   2        break;
1115   2      /*------------------------------------------------------------------------------
1116   2      Leo la Mf en el sector 1  bloque 1
1117   2          se lee ID_CLIENTE, COD_PARK Y TIPO_TARJETA
1118   2      ------------------------------------------------------------------------------*/      
1119   2        
1120   2        case SEQ_RD_S1B1:
1121   2          
1122   2      if((temp=Trama_Validacion_P_N())!=0)
1123   2          {
1124   3            if(temp==2)
1125   3            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 20  

1126   4            g_cEstadoComSeqMF=SEQ_RD_S1B1;                                                            /*no ha respondido*/
1127   4            }
1128   3            else if (temp==3)
1129   3            {
1130   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta falla en la escritura de la clave*/
1131   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1132   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1133   4            }       
1134   3            else
1135   3            { 
1136   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1137   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1138   4            }
1139   3          }
1140   2          else
1141   2          {
1142   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B1 OK\r\n\r\n");                              /* trama OK CARGA LA EEPROM 
             -Y LA VERIFICA*/
1143   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1144   3            
1145   3            if (Buffer_Rta_Lintech[Pos_Length] >=0x18)
1146   3            {
1147   4              
1148   4                for (temp=0; temp<16; temp++)
1149   4                {
1150   5                  buffer_S1_B1[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                           /*almaceno la informacion de 
             -MF en un arreglo*/
1151   5                }
1152   4                if (((buffer_S1_B1[MF_ID_CLIENTE]==ID_CLIENTE)&&(buffer_S1_B1[MF_COD_PARK]==COD_PARK))||((ID_CLIENTE=
             -=0)&&(COD_PARK==0)))    
1153   4                {
1154   5                    
1155   5                  Debug_txt_Tibbo((unsigned char *) "ID_CLIENTE: ");
1156   5                  Debug_HexDec(buffer_S1_B1[MF_ID_CLIENTE]);
1157   5                  Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1158   5                  
1159   5                  Debug_txt_Tibbo((unsigned char *) "COD_PARK:");
1160   5                  Debug_HexDec(buffer_S1_B1[MF_COD_PARK]);
1161   5                  Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1162   5      
1163   5      
1164   5                  
1165   5                  if  ((buffer_S1_B1[MF_TIPO_TARJETA]==ROTACION))         
1166   5                  {
1167   6                    Debug_txt_Tibbo((unsigned char *) "TIPO DE TARJETA 1 ROTACION: ");
1168   6                    Debug_chr_Tibbo(buffer_S1_B1[MF_TIPO_TARJETA]);
1169   6                    Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1170   6                    
1171   6                    RD_MF(1, 2);                                                                        /* Leo fecha y hora de ingreso y de salida*/
1172   6                    g_cEstadoComSeqMF=SEQ_RD_S1B2;
1173   6                    
1174   6                  }
1175   5                  else 
1176   5                  {
1177   6                    send_portERR(TARJETA_INVALIDA);
1178   6                    PantallaLCD(TARJETA_INVALIDA);                                                      /*envio el msj por la pantalla lcd o la ra
             -spberry*/
1179   6                    g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* expulso la tarjeta */    
1180   6                  }
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 21  

1181   5                }
1182   4                else
1183   4                {
1184   5                  send_portERR(ERROR_COD_PARK);
1185   5                  PantallaLCD(ERROR_COD_PARK);                                                        /*envio el msj por la pantalla lcd o la rasp
             -berry*/
1186   5                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;                                                /* codigo de parqueo erro expulso la tar
             -jeta */    
1187   5                }
1188   4            }
1189   3            else
1190   3            {
1191   4              send_portERR(TARJETA_SIN_FORMATO);
1192   4              PantallaLCD(TARJETA_SIN_FORMATO);                                                       /*envio el msj por la pantalla lcd o la r
             -aspberry*/
1193   4              g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1194   4            }
1195   3            
1196   3          }     
1197   2        break;
1198   2      /*------------------------------------------------------------------------------
1199   2      Leo la Mf en el  sector 1 bloque 2
1200   2        Se lee Fecha in, fecha out
1201   2      ------------------------------------------------------------------------------*/
1202   2        case SEQ_RD_S1B2:
1203   2              
1204   2        if((temp=Trama_Validacion_P_N())!=0)
1205   2          {
1206   3            if(temp==2)
1207   3            {
1208   4            g_cEstadoComSeqMF=SEQ_RD_S1B2;                                                            /*no ha respondido*/
1209   4            }
1210   3            else if (temp==3)
1211   3            {
1212   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta falla en la escritura de la clave*/
1213   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1214   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1215   4            }       
1216   3            else
1217   3            { 
1218   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1219   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1220   4            }
1221   3          }
1222   2          else
1223   2          {
1224   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B2 OK\r\n\r\n");                              /* trama OK CARGA LA EEPROM 
             -Y LA VERIFICA*/
1225   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1226   3            for (temp=0; temp<16; temp++)
1227   3            {
1228   4              buffer_S1_B2[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                             /*almaceno la informacion de M
             -F en un arreglo*/
1229   4            }
1230   3            
1231   3            if((buffer_S1_B2[MF_APB]==02)||(buffer_S1_B2[MF_APB]==0) )                              /*Pregunto por el antipasban s
             -i es 02 ya salio y no posee entrada*/
1232   3            {                                                                                                             /*00 inhabilitada la tarjeta*/
1233   4            Debug_txt_Tibbo((unsigned char *) "ERROR: SIN INGRESO\r\n\r\n");
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 22  

1234   4            send_portERR(SIN_INGRESO);
1235   4            PantallaLCD(SIN_INGRESO);
1236   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1237   4              break;
1238   4            }
1239   3            
1240   3            if(SIN_COBRO!=0)                                                                                                /*SINCOBRO =0 deshabilitado  =(1) sin c
             -obro = (2) sin cobro salida el mismo dia*/
1241   3            {
1242   4              if (SIN_COBRO==1)
1243   4              {
1244   5                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
1245   5                RD_MF(1, 0);                                                                                                /* Leo el ticket */
1246   5                g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                              /*sin cobro*/
1247   5                break;
1248   5              }
1249   4              else if( SIN_COBRO ==2)
1250   4              {
1251   5                Block_read_Clock_Hex(clock_temp);                                                                           /*leo el reloj año,mes,dia*/
1252   5                        
1253   5          
1254   5                if ((buffer_S1_B2[0]==clock_temp[0])&&(buffer_S1_B2[1]==clock_temp[1])&&(buffer_S1_B2[2]==clock_temp[
             -2]))    /*se analiza la fecha de entrada de la tarjeta MF y la fecha del dia */
1255   5                {
1256   6                  Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
1257   6                  RD_MF(1, 0);                                                                                              /* Leo el ticket */
1258   6                  g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                                            /*sin cobro el mismo dia*/
1259   6                  break;
1260   6                }                                                                                         
1261   5                  else
1262   5                  {
1263   6                  Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");                                             /*excede el time
             -po de gracia del dia */
1264   6                  send_portERR(EXCEDE_GRACIA);
1265   6                  PantallaLCD(EXCEDE_GRACIA);                                                                               /*envio el msj por la pantalla lc
             -d o la raspberry*/
1266   6                  g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;
1267   6                  break;              
1268   6                  }
1269   5                
1270   5                
1271   5              }
1272   4            }
1273   3          
1274   3            
1275   3            else if(T_GRACIA!=0)                                                                    /*si es diferente de cero tiene tiempo de gracia*
             -/
1276   3            {
1277   4              Debug_txt_Tibbo((unsigned char *) "Tiempo Gracia: ");
1278   4              Debug_chr_Tibbo(T_GRACIA);                                                            /*imprimo la trama recibida*/ 
1279   4              Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");    
1280   4              analiza_tiempo(buffer_S1_B2,T_GRACIA);                                                // Simula Fecha Max de Salida.
1281   4            
1282   4            }
1283   3            
1284   3            temp=check_fechaOut(buffer_S1_B2+MF_FECHA_OUT);                                         /*se analiza la fecha de salida*/
1285   3              if(temp==1)
1286   3              {
1287   4                  Debug_txt_Tibbo((unsigned char *) "TARJETA SIN PAGO\r\n\r\n");
1288   4                  send_portERR(SIN_PAGO);
1289   4                  PantallaLCD(SIN_PAGO);                                                            /*envio el msj por la pantalla lcd o la raspberr
             -y*/
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 23  

1290   4                  RD_MF(1, 0);                                                                      /**leo el ticket*/  
1291   4                  g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;          
1292   4                              
1293   4              }
1294   3              else if (temp==2)
1295   3              {
1296   4                Debug_txt_Tibbo((unsigned char *) "Excede T.GRACIA\r\n\r\n");
1297   4                send_portERR(EXCEDE_GRACIA);
1298   4                PantallaLCD(EXCEDE_GRACIA);                                                       /*envio el msj por la pantalla lcd o la raspbe
             -rry*/
1299   4                g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;  
1300   4              }
1301   3              else
1302   3              {
1303   4                Debug_txt_Tibbo((unsigned char *) "Salida Autorizada\r\n\r\n");
1304   4                RD_MF(1, 0);                                                                      /* Leo el ticket */
1305   4                g_cEstadoComSeqMF=SEQ_RD_S1B0;  
1306   4              }
1307   3            
1308   3          }
1309   2        
1310   2            
1311   2            
1312   2            
1313   2        break;
1314   2      
1315   2      /*------------------------------------------------------------------------------
1316   2      Leo la Mf en el  sector 1 bloque 0
1317   2          lee el ticket
1318   2      ------------------------------------------------------------------------------*/    
1319   2          
1320   2        case SEQ_RD_S1B0:
1321   2        
1322   2        if((temp=Trama_Validacion_P_N())!=0)
1323   2          {
1324   3            if(temp==2)
1325   3            {
1326   4            g_cEstadoComSeqMF=SEQ_RD_S1B0;                                                            /*no ha respondido*/
1327   4            }
1328   3            else if (temp==3)
1329   3            {
1330   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el leer el bloque*/
1331   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1332   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1333   4            }       
1334   3            else
1335   3            { 
1336   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1337   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1338   4            }
1339   3          }
1340   2          else
1341   2          {
1342   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1343   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1344   3            
1345   3        for (temp=0; temp<16; temp++)
1346   3            {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 24  

1347   4              
1348   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
1349   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1350   4              {
1351   5                break;
1352   5              }
1353   4            }
1354   3            Debug_txt_Tibbo((unsigned char *) "Numero Ticket: ");
1355   3            Debug_txt_Tibbo(buffer_S1_B0);
1356   3            Debug_txt_Tibbo((unsigned char *) "\r\n\r\n");
1357   3            
1358   3            lock=1;   
1359   3            Tarjeta_on=0;
1360   3            Timer_wait=0;                                                                               /*activo la barrera*/
1361   3            Trama_pto_Paralelo_new(buffer_S1_B0,buffer_S1_B2,'s');                                      /*transmito pto paralelo*/
1362   3            if(USE_LPR)
1363   3            {
1364   4              Cmd_LPR_Salida(buffer_S1_B0,buffer_S1_B2);                                                /*envio datos a Monitor*/
1365   4            }
1366   3            
1367   3            WR_MF(1, 2,buffer_S1_B2+MF_TIPO_VEHICULO);
1368   3            g_cEstadoComSeqMF=SEQ_WR_S1B2;
1369   3          }
1370   2        break;
1371   2        
1372   2        case SEQ_WR_S1B2:
1373   2          if((temp=Trama_Validacion_P_N())!=0)
1374   2          {
1375   3            if(temp==2)
1376   3            {
1377   4            g_cEstadoComSeqMF=SEQ_WR_S1B2;                                                            /*no ha respondido*/
1378   4            }
1379   3            else if (temp==3)
1380   3            {
1381   4            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el escribir bloque*/
1382   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1383   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1384   4            }       
1385   3            else
1386   3            { 
1387   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1388   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1389   4            }
1390   3          }
1391   2          else
1392   2          {
1393   3            Debug_txt_Tibbo((unsigned char *) "SEQ_WR_S1B2 OK\r\n\r\n");                              /* trama OK CARGA numero de 
             -ticket*/
1394   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1395   3            WR_MF(2, 0,buffer_S1_B2+MF_TIPO_VEHICULO);
1396   3            g_cEstadoComSeqMF=SEQ_RTA_S2B0; 
1397   3          }
1398   2          break;
1399   2        
1400   2        case SEQ_RTA_S2B0:
1401   2      
1402   2        if((temp=Trama_Validacion_P_N())!=0)
1403   2          {
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 25  

1404   3            if(temp==2)
1405   3            {
1406   4            g_cEstadoComSeqMF=SEQ_RTA_S2B0;                                                           /*no ha respondido*/
1407   4            }
1408   3            else if (temp==3)
1409   3            {
1410   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 ERROR\r\n\r\n");                            /* trama no valida respue
             -sta incorrecta el leer el bloque*/
1411   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1412   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1413   4            }       
1414   3            else
1415   3            { 
1416   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1417   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1418   4            }
1419   3          }
1420   2          else
1421   2          {
1422   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RTA_S2B0 OK\r\n\r\n");                             /* trama OK CARGA numero de
             - ticket*/
1423   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1424   3            
1425   3      
1426   3        
1427   3            Debug_txt_Tibbo((unsigned char *) "ok tarjeta ok...\r\n\r\n");                              /* pto serie no responde*/
1428   3            Mov_Card(MovPos_Capture);
1429   3            lock=0; 
1430   3            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;
1431   3          }
1432   2          break;
1433   2      /*------------------------------------------------------------------------------
1434   2      El vehiculo no se encuentra en el loop  ejecto la tarjeta y espero la respuesta
1435   2            (0) LA RESPUESTA ES OK
1436   2            (1) NO RESPONDE EL PTO SERIE
1437   2            (2) NO RECIBIDO LA TRAMA 
1438   2            (3) ERROR DE TRAMA CMD (N)
1439   2      ------------------------------------------------------------------------------*/  
1440   2      
1441   2        case SEQ_RTA_CAPTURE:
1442   2          
1443   2          if((temp=Trama_Validacion_P_N())!=0)
1444   2          {
1445   3            if(temp==2)
1446   3            {
1447   4                
1448   4            g_cEstadoComSeqMF=SEQ_RTA_CAPTURE;                                                    /*no ha respondido*/
1449   4          
1450   4            } 
1451   3              else if (temp==3)
1452   3            {
1453   4            Debug_txt_Tibbo((unsigned char *) "NO EJECT TARJET ERROR\r\n\r\n");                   /* Tama incorrecta no ejec
             -ta la tarjeta*/
1454   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1455   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* (3) Trama invalida cmd (N)*/ 
1456   4            } 
1457   3            else
1458   3            {
1459   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n"); /* respuesta incor
             -recta*/  
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 26  

1460   4              g_cEstadoComSeqMF=SEQ_INICIO; 
1461   4            
1462   4            }       
1463   3          }
1464   2          else
1465   2          {
1466   3            Debug_txt_Tibbo((unsigned char *) "EJECT TARJET OK\r\n\r\n");                         /* trama ok la tarjeta fue ej
             -ectada*/
1467   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                            /*imprimo la trama recibida*/
1468   3            g_cEstadoComSeqMF=SEQ_CHECK_STATUS;                                                   /*respuesta ok inicia revisando sensores*/
1469   3          }     
1470   2            
1471   2      
1472   2          break;      
1473   2      /*------------------------------------------------------------------------------
1474   2      Leo la Mf en el  sector 1 bloque 0 leo el ticket
1475   2      LA tarjeta no tiene pago    
1476   2        
1477   2      ------------------------------------------------------------------------------*/
1478   2        
1479   2        
1480   2        case SEQ_RD_S1B0_EJECT: 
1481   2          
1482   2          if((temp=Trama_Validacion_P_N())!=0)
1483   2          {
1484   3            if(temp==2)
1485   3            {
1486   4            g_cEstadoComSeqMF=SEQ_RD_S1B0_EJECT;                                                            /*no ha respondido*/
1487   4            }
1488   3            else if (temp==3)
1489   3            {
1490   4            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0 ERROR\r\n\r\n");                           /* trama no valida respues
             -ta incorrecta el leer el bloque*/
1491   4            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -  
1492   4            g_cEstadoComSeqMF=SEQ_INICIO;                                                             /* (3) Trama invalida cmd (N)*/ 
1493   4            }       
1494   3            else
1495   3            { 
1496   4              Debug_txt_Tibbo((unsigned char *) "Dispensador No Responde PTO SERIE ...\r\n\r\n");       
1497   4              g_cEstadoComSeqMF=SEQ_INICIO;                                                           /* respuesta incorrecta*/
1498   4            }
1499   3          }
1500   2          else
1501   2          {
1502   3            Debug_txt_Tibbo((unsigned char *) "SEQ_RD_S1B0_EJECT OK\r\n\r\n");                              /* trama OK CARGA nume
             -ro de ticket*/
1503   3            DebugBufferMF(Buffer_Rta_Lintech,g_cContByteRx,RESPUESTA);                                /*imprimo la trama recibida*/
             -    
1504   3            
1505   3        for (temp=0; temp<16; temp++)
1506   3            {
1507   4              
1508   4              buffer_S1_B0[temp]=Buffer_Rta_Lintech[Pos_IniDatMF+temp];                                 /*almaceno la informacion de
             - MF el ticket*/
1509   4              if(Buffer_Rta_Lintech[Pos_IniDatMF+temp]==0)
1510   4              {
1511   5                break;
1512   5              }
1513   4            }
1514   3            Trama_pto_Paralelo_P(buffer_S1_B0,buffer_S1_B2,'P');    
1515   3            g_cEstadoComSeqMF=SEQ_EXPULSAR_TARJ;    
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 27  

1516   3          } 
1517   2            break;
1518   2        
1519   2      /*------------------------------------------------------------------------------
1520   2      expulsa la tarjeta por que no pertenece a MF50
1521   2      ------------------------------------------------------------------------------*/    
1522   2        
1523   2        case SEQ_EXPULSAR_TARJ:
1524   2            Card_Insercion(Inhabilita); 
1525   2            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;
1526   2        break;
1527   2        
1528   2        
1529   2        case SEQ_EXPULSAR_CHECK:
1530   2        if((temp=Trama_Validacion_P_N())!=0)
1531   2          {
1532   3            if(temp==2)
1533   3            {
1534   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_CHECK;                                                       /*no ha respondido*/
1535   4            } 
1536   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
1537   3          }
1538   2          else
1539   2          {
1540   3            g_cEstadoComSeqMF=SEQ_EXPULSAR;                                                             /*respuesta ok inicia clave verificada*/
1541   3          }   
1542   2          
1543   2          break;
1544   2          
1545   2        case SEQ_EXPULSAR:
1546   2          Mov_Card(MovPos_EjectFront);
1547   2        g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;
1548   2        
1549   2        case SEQ_EXPULSAR_FROM:                       
1550   2          if((temp=Trama_Validacion_P_N())!=0)
1551   2          {
1552   3            if(temp==2)
1553   3            {
1554   4            g_cEstadoComSeqMF=SEQ_EXPULSAR_FROM;                                                        /*no ha respondido*/
1555   4            } 
1556   3            else  g_cEstadoComSeqMF=SEQ_INICIO;                                                         /* respuesta incorrecta*/                             
             -                    
1557   3          }
1558   2          else
1559   2          {
1560   3            g_cEstadoComSeqMF=SEQ_INICIO;                                                               /*respuesta ok inicia clave verificada*/
1561   3          }   
1562   2          
1563   2        break;
1564   2        
1565   2      /*------------------------------------------------------------------------------
1566   2      expulsa la tarjeta por que no pertenece a MF50
1567   2      ------------------------------------------------------------------------------*/      
1568   2          
1569   2              default:
1570   2              g_cEstadoComSeqMF=SEQ_INICIO; 
1571   2              break;  
1572   2            
1573   2        } 
1574   1      }
1575          
C51 COMPILER V9.59.0.0   VERIFICADOR                                                       11/29/2019 11:25:15 PAGE 28  

1576          
1577            


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4800    ----
   CONSTANT SIZE    =   1426    ----
   XDATA SIZE       =     53     158
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
